/*! For license information please see gameplay.js.LICENSE.txt */
!function (e) { var t = {}; function n(i) { if (t[i]) return t[i].exports; var r = t[i] = { i: i, l: !1, exports: {} }; return e[i].call(r.exports, r, r.exports, n), r.l = !0, r.exports } n.m = e, n.c = t, n.d = function (e, t, i) { n.o(e, t) || Object.defineProperty(e, t, { enumerable: !0, get: i }) }, n.r = function (e) { "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e, "__esModule", { value: !0 }) }, n.t = function (e, t) { if (1 & t && (e = n(e)), 8 & t) return e; if (4 & t && "object" == typeof e && e && e.__esModule) return e; var i = Object.create(null); if (n.r(i), Object.defineProperty(i, "default", { enumerable: !0, value: e }), 2 & t && "string" != typeof e) for (var r in e) n.d(i, r, function (t) { return e[t] }.bind(null, r)); return i }, n.n = function (e) { var t = e && e.__esModule ? function () { return e.default } : function () { return e }; return n.d(t, "a", t), t }, n.o = function (e, t) { return Object.prototype.hasOwnProperty.call(e, t) }, n.p = "", n(n.s = 1) }([function (e, t, n) { (function (n) { var i; !function () { "use strict"; var r = function () { this.init() }; r.prototype = { init: function () { var e = this || s; return e._counter = 1e3, e._html5AudioPool = [], e.html5PoolSize = 10, e._codecs = {}, e._howls = [], e._muted = !1, e._volume = 1, e._canPlayEvent = "canplaythrough", e._navigator = "undefined" != typeof window && window.navigator ? window.navigator : null, e.masterGain = null, e.noAudio = !1, e.usingWebAudio = !0, e.autoSuspend = !0, e.ctx = null, e.autoUnlock = !0, e._setup(), e }, volume: function (e) { var t = this || s; if (e = parseFloat(e), t.ctx || d(), void 0 !== e && e >= 0 && e <= 1) { if (t._volume = e, t._muted) return t; t.usingWebAudio && t.masterGain.gain.setValueAtTime(e, s.ctx.currentTime); for (var n = 0; n < t._howls.length; n++)if (!t._howls[n]._webAudio) for (var i = t._howls[n]._getSoundIds(), r = 0; r < i.length; r++) { var o = t._howls[n]._soundById(i[r]); o && o._node && (o._node.volume = o._volume * e) } return t } return t._volume }, mute: function (e) { var t = this || s; t.ctx || d(), t._muted = e, t.usingWebAudio && t.masterGain.gain.setValueAtTime(e ? 0 : t._volume, s.ctx.currentTime); for (var n = 0; n < t._howls.length; n++)if (!t._howls[n]._webAudio) for (var i = t._howls[n]._getSoundIds(), r = 0; r < i.length; r++) { var o = t._howls[n]._soundById(i[r]); o && o._node && (o._node.muted = !!e || o._muted) } return t }, stop: function () { for (var e = this || s, t = 0; t < e._howls.length; t++)e._howls[t].stop(); return e }, unload: function () { for (var e = this || s, t = e._howls.length - 1; t >= 0; t--)e._howls[t].unload(); return e.usingWebAudio && e.ctx && void 0 !== e.ctx.close && (e.ctx.close(), e.ctx = null, d()), e }, codecs: function (e) { return (this || s)._codecs[e.replace(/^x-/, "")] }, _setup: function () { var e = this || s; if (e.state = e.ctx && e.ctx.state || "suspended", e._autoSuspend(), !e.usingWebAudio) if ("undefined" != typeof Audio) try { void 0 === (new Audio).oncanplaythrough && (e._canPlayEvent = "canplay") } catch (t) { e.noAudio = !0 } else e.noAudio = !0; try { (new Audio).muted && (e.noAudio = !0) } catch (e) { } return e.noAudio || e._setupCodecs(), e }, _setupCodecs: function () { var e = this || s, t = null; try { t = "undefined" != typeof Audio ? new Audio : null } catch (t) { return e } if (!t || "function" != typeof t.canPlayType) return e; var n = t.canPlayType("audio/mpeg;").replace(/^no$/, ""), i = e._navigator ? e._navigator.userAgent : "", r = i.match(/OPR\/([0-6].)/g), o = r && parseInt(r[0].split("/")[1], 10) < 33, a = -1 !== i.indexOf("Safari") && -1 === i.indexOf("Chrome"), l = i.match(/Version\/(.*?) /), c = a && l && parseInt(l[1], 10) < 15; return e._codecs = { mp3: !(o || !n && !t.canPlayType("audio/mp3;").replace(/^no$/, "")), mpeg: !!n, opus: !!t.canPlayType('audio/ogg; codecs="opus"').replace(/^no$/, ""), ogg: !!t.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, ""), oga: !!t.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, ""), wav: !!(t.canPlayType('audio/wav; codecs="1"') || t.canPlayType("audio/wav")).replace(/^no$/, ""), aac: !!t.canPlayType("audio/aac;").replace(/^no$/, ""), caf: !!t.canPlayType("audio/x-caf;").replace(/^no$/, ""), m4a: !!(t.canPlayType("audio/x-m4a;") || t.canPlayType("audio/m4a;") || t.canPlayType("audio/aac;")).replace(/^no$/, ""), m4b: !!(t.canPlayType("audio/x-m4b;") || t.canPlayType("audio/m4b;") || t.canPlayType("audio/aac;")).replace(/^no$/, ""), mp4: !!(t.canPlayType("audio/x-mp4;") || t.canPlayType("audio/mp4;") || t.canPlayType("audio/aac;")).replace(/^no$/, ""), weba: !(c || !t.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, "")), webm: !(c || !t.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, "")), dolby: !!t.canPlayType('audio/mp4; codecs="ec-3"').replace(/^no$/, ""), flac: !!(t.canPlayType("audio/x-flac;") || t.canPlayType("audio/flac;")).replace(/^no$/, "") }, e }, _unlockAudio: function () { var e = this || s; if (!e._audioUnlocked && e.ctx) { e._audioUnlocked = !1, e.autoUnlock = !1, e._mobileUnloaded || 44100 === e.ctx.sampleRate || (e._mobileUnloaded = !0, e.unload()), e._scratchBuffer = e.ctx.createBuffer(1, 1, 22050); var t = function (n) { for (; e._html5AudioPool.length < e.html5PoolSize;)try { var i = new Audio; i._unlocked = !0, e._releaseHtml5Audio(i) } catch (n) { e.noAudio = !0; break } for (var r = 0; r < e._howls.length; r++)if (!e._howls[r]._webAudio) for (var s = e._howls[r]._getSoundIds(), o = 0; o < s.length; o++) { var a = e._howls[r]._soundById(s[o]); a && a._node && !a._node._unlocked && (a._node._unlocked = !0, a._node.load()) } e._autoResume(); var l = e.ctx.createBufferSource(); l.buffer = e._scratchBuffer, l.connect(e.ctx.destination), void 0 === l.start ? l.noteOn(0) : l.start(0), "function" == typeof e.ctx.resume && e.ctx.resume(), l.onended = function () { l.disconnect(0), e._audioUnlocked = !0, document.removeEventListener("touchstart", t, !0), document.removeEventListener("touchend", t, !0), document.removeEventListener("click", t, !0), document.removeEventListener("keydown", t, !0); for (var n = 0; n < e._howls.length; n++)e._howls[n]._emit("unlock") } }; return document.addEventListener("touchstart", t, !0), document.addEventListener("touchend", t, !0), document.addEventListener("click", t, !0), document.addEventListener("keydown", t, !0), e } }, _obtainHtml5Audio: function () { var e = this || s; if (e._html5AudioPool.length) return e._html5AudioPool.pop(); var t = (new Audio).play(); return t && "undefined" != typeof Promise && (t instanceof Promise || "function" == typeof t.then) && t.catch((function () { console.warn("HTML5 Audio pool exhausted, returning potentially locked audio object.") })), new Audio }, _releaseHtml5Audio: function (e) { var t = this || s; return e._unlocked && t._html5AudioPool.push(e), t }, _autoSuspend: function () { var e = this; if (e.autoSuspend && e.ctx && void 0 !== e.ctx.suspend && s.usingWebAudio) { for (var t = 0; t < e._howls.length; t++)if (e._howls[t]._webAudio) for (var n = 0; n < e._howls[t]._sounds.length; n++)if (!e._howls[t]._sounds[n]._paused) return e; return e._suspendTimer && clearTimeout(e._suspendTimer), e._suspendTimer = setTimeout((function () { if (e.autoSuspend) { e._suspendTimer = null, e.state = "suspending"; var t = function () { e.state = "suspended", e._resumeAfterSuspend && (delete e._resumeAfterSuspend, e._autoResume()) }; e.ctx.suspend().then(t, t) } }), 3e4), e } }, _autoResume: function () { var e = this; if (e.ctx && void 0 !== e.ctx.resume && s.usingWebAudio) return "running" === e.state && "interrupted" !== e.ctx.state && e._suspendTimer ? (clearTimeout(e._suspendTimer), e._suspendTimer = null) : "suspended" === e.state || "running" === e.state && "interrupted" === e.ctx.state ? (e.ctx.resume().then((function () { e.state = "running"; for (var t = 0; t < e._howls.length; t++)e._howls[t]._emit("resume") })), e._suspendTimer && (clearTimeout(e._suspendTimer), e._suspendTimer = null)) : "suspending" === e.state && (e._resumeAfterSuspend = !0), e } }; var s = new r, o = function (e) { e.src && 0 !== e.src.length ? this.init(e) : console.error("An array of source files must be passed with any new Howl.") }; o.prototype = { init: function (e) { var t = this; return s.ctx || d(), t._autoplay = e.autoplay || !1, t._format = "string" != typeof e.format ? e.format : [e.format], t._html5 = e.html5 || !1, t._muted = e.mute || !1, t._loop = e.loop || !1, t._pool = e.pool || 5, t._preload = "boolean" != typeof e.preload && "metadata" !== e.preload || e.preload, t._rate = e.rate || 1, t._sprite = e.sprite || {}, t._src = "string" != typeof e.src ? e.src : [e.src], t._volume = void 0 !== e.volume ? e.volume : 1, t._xhr = { method: e.xhr && e.xhr.method ? e.xhr.method : "GET", headers: e.xhr && e.xhr.headers ? e.xhr.headers : null, withCredentials: !(!e.xhr || !e.xhr.withCredentials) && e.xhr.withCredentials }, t._duration = 0, t._state = "unloaded", t._sounds = [], t._endTimers = {}, t._queue = [], t._playLock = !1, t._onend = e.onend ? [{ fn: e.onend }] : [], t._onfade = e.onfade ? [{ fn: e.onfade }] : [], t._onload = e.onload ? [{ fn: e.onload }] : [], t._onloaderror = e.onloaderror ? [{ fn: e.onloaderror }] : [], t._onplayerror = e.onplayerror ? [{ fn: e.onplayerror }] : [], t._onpause = e.onpause ? [{ fn: e.onpause }] : [], t._onplay = e.onplay ? [{ fn: e.onplay }] : [], t._onstop = e.onstop ? [{ fn: e.onstop }] : [], t._onmute = e.onmute ? [{ fn: e.onmute }] : [], t._onvolume = e.onvolume ? [{ fn: e.onvolume }] : [], t._onrate = e.onrate ? [{ fn: e.onrate }] : [], t._onseek = e.onseek ? [{ fn: e.onseek }] : [], t._onunlock = e.onunlock ? [{ fn: e.onunlock }] : [], t._onresume = [], t._webAudio = s.usingWebAudio && !t._html5, void 0 !== s.ctx && s.ctx && s.autoUnlock && s._unlockAudio(), s._howls.push(t), t._autoplay && t._queue.push({ event: "play", action: function () { t.play() } }), t._preload && "none" !== t._preload && t.load(), t }, load: function () { var e = null; if (s.noAudio) this._emit("loaderror", null, "No audio support."); else { "string" == typeof this._src && (this._src = [this._src]); for (var t = 0; t < this._src.length; t++) { var n, i; if (this._format && this._format[t]) n = this._format[t]; else { if ("string" != typeof (i = this._src[t])) { this._emit("loaderror", null, "Non-string found in selected audio sources - ignoring."); continue } (n = /^data:audio\/([^;,]+);/i.exec(i)) || (n = /\.([^.]+)$/.exec(i.split("?", 1)[0])), n && (n = n[1].toLowerCase()) } if (n || console.warn('No file extension was found. Consider using the "format" property or specify an extension.'), n && s.codecs(n)) { e = this._src[t]; break } } if (e) return this._src = e, this._state = "loading", "https:" === window.location.protocol && "http:" === e.slice(0, 5) && (this._html5 = !0, this._webAudio = !1), new a(this), this._webAudio && c(this), this; this._emit("loaderror", null, "No codec support for selected audio sources.") } }, play: function (e, t) { var n = this, i = null; if ("number" == typeof e) i = e, e = null; else { if ("string" == typeof e && "loaded" === n._state && !n._sprite[e]) return null; if (void 0 === e && (e = "__default", !n._playLock)) { for (var r = 0, o = 0; o < n._sounds.length; o++)n._sounds[o]._paused && !n._sounds[o]._ended && (r++, i = n._sounds[o]._id); 1 === r ? e = null : i = null } } var a = i ? n._soundById(i) : n._inactiveSound(); if (!a) return null; if (i && !e && (e = a._sprite || "__default"), "loaded" !== n._state) { a._sprite = e, a._ended = !1; var l = a._id; return n._queue.push({ event: "play", action: function () { n.play(l) } }), l } if (i && !a._paused) return t || n._loadQueue("play"), a._id; n._webAudio && s._autoResume(); var c = Math.max(0, a._seek > 0 ? a._seek : n._sprite[e][0] / 1e3), A = Math.max(0, (n._sprite[e][0] + n._sprite[e][1]) / 1e3 - c), u = 1e3 * A / Math.abs(a._rate), h = n._sprite[e][0] / 1e3, d = (n._sprite[e][0] + n._sprite[e][1]) / 1e3; a._sprite = e, a._ended = !1; var p = function () { a._paused = !1, a._seek = c, a._start = h, a._stop = d, a._loop = !(!a._loop && !n._sprite[e][2]) }; if (!(c >= d)) { var f = a._node; if (n._webAudio) { var g = function () { n._playLock = !1, p(), n._refreshBuffer(a); var e = a._muted || n._muted ? 0 : a._volume; f.gain.setValueAtTime(e, s.ctx.currentTime), a._playStart = s.ctx.currentTime, void 0 === f.bufferSource.start ? a._loop ? f.bufferSource.noteGrainOn(0, c, 86400) : f.bufferSource.noteGrainOn(0, c, A) : a._loop ? f.bufferSource.start(0, c, 86400) : f.bufferSource.start(0, c, A), u !== 1 / 0 && (n._endTimers[a._id] = setTimeout(n._ended.bind(n, a), u)), t || setTimeout((function () { n._emit("play", a._id), n._loadQueue() }), 0) }; "running" === s.state && "interrupted" !== s.ctx.state ? g() : (n._playLock = !0, n.once("resume", g), n._clearTimer(a._id)) } else { var m = function () { f.currentTime = c, f.muted = a._muted || n._muted || s._muted || f.muted, f.volume = a._volume * s.volume(), f.playbackRate = a._rate; try { var i = f.play(); if (i && "undefined" != typeof Promise && (i instanceof Promise || "function" == typeof i.then) ? (n._playLock = !0, p(), i.then((function () { n._playLock = !1, f._unlocked = !0, t ? n._loadQueue() : n._emit("play", a._id) })).catch((function () { n._playLock = !1, n._emit("playerror", a._id, "Playback was unable to start. This is most commonly an issue on mobile devices and Chrome where playback was not within a user interaction."), a._ended = !0, a._paused = !0 }))) : t || (n._playLock = !1, p(), n._emit("play", a._id)), f.playbackRate = a._rate, f.paused) return void n._emit("playerror", a._id, "Playback was unable to start. This is most commonly an issue on mobile devices and Chrome where playback was not within a user interaction."); "__default" !== e || a._loop ? n._endTimers[a._id] = setTimeout(n._ended.bind(n, a), u) : (n._endTimers[a._id] = function () { n._ended(a), f.removeEventListener("ended", n._endTimers[a._id], !1) }, f.addEventListener("ended", n._endTimers[a._id], !1)) } catch (e) { n._emit("playerror", a._id, e) } }; "data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA" === f.src && (f.src = n._src, f.load()); var v = window && window.ejecta || !f.readyState && s._navigator.isCocoonJS; if (f.readyState >= 3 || v) m(); else { n._playLock = !0, n._state = "loading"; var y = function () { n._state = "loaded", m(), f.removeEventListener(s._canPlayEvent, y, !1) }; f.addEventListener(s._canPlayEvent, y, !1), n._clearTimer(a._id) } } return a._id } n._ended(a) }, pause: function (e) { var t = this; if ("loaded" !== t._state || t._playLock) return t._queue.push({ event: "pause", action: function () { t.pause(e) } }), t; for (var n = t._getSoundIds(e), i = 0; i < n.length; i++) { t._clearTimer(n[i]); var r = t._soundById(n[i]); if (r && !r._paused && (r._seek = t.seek(n[i]), r._rateSeek = 0, r._paused = !0, t._stopFade(n[i]), r._node)) if (t._webAudio) { if (!r._node.bufferSource) continue; void 0 === r._node.bufferSource.stop ? r._node.bufferSource.noteOff(0) : r._node.bufferSource.stop(0), t._cleanBuffer(r._node) } else isNaN(r._node.duration) && r._node.duration !== 1 / 0 || r._node.pause(); arguments[1] || t._emit("pause", r ? r._id : null) } return t }, stop: function (e, t) { var n = this; if ("loaded" !== n._state || n._playLock) return n._queue.push({ event: "stop", action: function () { n.stop(e) } }), n; for (var i = n._getSoundIds(e), r = 0; r < i.length; r++) { n._clearTimer(i[r]); var s = n._soundById(i[r]); s && (s._seek = s._start || 0, s._rateSeek = 0, s._paused = !0, s._ended = !0, n._stopFade(i[r]), s._node && (n._webAudio ? s._node.bufferSource && (void 0 === s._node.bufferSource.stop ? s._node.bufferSource.noteOff(0) : s._node.bufferSource.stop(0), n._cleanBuffer(s._node)) : isNaN(s._node.duration) && s._node.duration !== 1 / 0 || (s._node.currentTime = s._start || 0, s._node.pause(), s._node.duration === 1 / 0 && n._clearSound(s._node))), t || n._emit("stop", s._id)) } return n }, mute: function (e, t) { var n = this; if ("loaded" !== n._state || n._playLock) return n._queue.push({ event: "mute", action: function () { n.mute(e, t) } }), n; if (void 0 === t) { if ("boolean" != typeof e) return n._muted; n._muted = e } for (var i = n._getSoundIds(t), r = 0; r < i.length; r++) { var o = n._soundById(i[r]); o && (o._muted = e, o._interval && n._stopFade(o._id), n._webAudio && o._node ? o._node.gain.setValueAtTime(e ? 0 : o._volume, s.ctx.currentTime) : o._node && (o._node.muted = !!s._muted || e), n._emit("mute", o._id)) } return n }, volume: function () { var e, t, n, i = this, r = arguments; if (0 === r.length) return i._volume; if (1 === r.length || 2 === r.length && void 0 === r[1]) { var o = i._getSoundIds(), a = o.indexOf(r[0]); a >= 0 ? t = parseInt(r[0], 10) : e = parseFloat(r[0]) } else r.length >= 2 && (e = parseFloat(r[0]), t = parseInt(r[1], 10)); if (!(void 0 !== e && e >= 0 && e <= 1)) return (n = t ? i._soundById(t) : i._sounds[0]) ? n._volume : 0; if ("loaded" !== i._state || i._playLock) return i._queue.push({ event: "volume", action: function () { i.volume.apply(i, r) } }), i; void 0 === t && (i._volume = e), t = i._getSoundIds(t); for (var l = 0; l < t.length; l++)(n = i._soundById(t[l])) && (n._volume = e, r[2] || i._stopFade(t[l]), i._webAudio && n._node && !n._muted ? n._node.gain.setValueAtTime(e, s.ctx.currentTime) : n._node && !n._muted && (n._node.volume = e * s.volume()), i._emit("volume", n._id)); return i }, fade: function (e, t, n, i) { var r = this; if ("loaded" !== r._state || r._playLock) return r._queue.push({ event: "fade", action: function () { r.fade(e, t, n, i) } }), r; e = Math.min(Math.max(0, parseFloat(e)), 1), t = Math.min(Math.max(0, parseFloat(t)), 1), n = parseFloat(n), r.volume(e, i); for (var o = r._getSoundIds(i), a = 0; a < o.length; a++) { var l = r._soundById(o[a]); if (l) { if (i || r._stopFade(o[a]), r._webAudio && !l._muted) { var c = s.ctx.currentTime, A = c + n / 1e3; l._volume = e, l._node.gain.setValueAtTime(e, c), l._node.gain.linearRampToValueAtTime(t, A) } r._startFadeInterval(l, e, t, n, o[a], void 0 === i) } } return r }, _startFadeInterval: function (e, t, n, i, r, s) { var o = this, a = t, l = n - t, c = Math.abs(l / .01), A = Math.max(4, c > 0 ? i / c : i), u = Date.now(); e._fadeTo = n, e._interval = setInterval((function () { var r = (Date.now() - u) / i; u = Date.now(), a += l * r, a = Math.round(100 * a) / 100, a = l < 0 ? Math.max(n, a) : Math.min(n, a), o._webAudio ? e._volume = a : o.volume(a, e._id, !0), s && (o._volume = a), (n < t && a <= n || n > t && a >= n) && (clearInterval(e._interval), e._interval = null, e._fadeTo = null, o.volume(n, e._id), o._emit("fade", e._id)) }), A) }, _stopFade: function (e) { var t = this._soundById(e); return t && t._interval && (this._webAudio && t._node.gain.cancelScheduledValues(s.ctx.currentTime), clearInterval(t._interval), t._interval = null, this.volume(t._fadeTo, e), t._fadeTo = null, this._emit("fade", e)), this }, loop: function () { var e, t, n, i = this, r = arguments; if (0 === r.length) return i._loop; if (1 === r.length) { if ("boolean" != typeof r[0]) return !!(n = i._soundById(parseInt(r[0], 10))) && n._loop; e = r[0], i._loop = e } else 2 === r.length && (e = r[0], t = parseInt(r[1], 10)); for (var s = i._getSoundIds(t), o = 0; o < s.length; o++)(n = i._soundById(s[o])) && (n._loop = e, i._webAudio && n._node && n._node.bufferSource && (n._node.bufferSource.loop = e, e && (n._node.bufferSource.loopStart = n._start || 0, n._node.bufferSource.loopEnd = n._stop, i.playing(s[o]) && (i.pause(s[o], !0), i.play(s[o], !0))))); return i }, rate: function () { var e, t, n, i = this, r = arguments; if (0 === r.length) t = i._sounds[0]._id; else if (1 === r.length) { var o = i._getSoundIds(), a = o.indexOf(r[0]); a >= 0 ? t = parseInt(r[0], 10) : e = parseFloat(r[0]) } else 2 === r.length && (e = parseFloat(r[0]), t = parseInt(r[1], 10)); if ("number" != typeof e) return (n = i._soundById(t)) ? n._rate : i._rate; if ("loaded" !== i._state || i._playLock) return i._queue.push({ event: "rate", action: function () { i.rate.apply(i, r) } }), i; void 0 === t && (i._rate = e), t = i._getSoundIds(t); for (var l = 0; l < t.length; l++)if (n = i._soundById(t[l])) { i.playing(t[l]) && (n._rateSeek = i.seek(t[l]), n._playStart = i._webAudio ? s.ctx.currentTime : n._playStart), n._rate = e, i._webAudio && n._node && n._node.bufferSource ? n._node.bufferSource.playbackRate.setValueAtTime(e, s.ctx.currentTime) : n._node && (n._node.playbackRate = e); var c = i.seek(t[l]), A = (i._sprite[n._sprite][0] + i._sprite[n._sprite][1]) / 1e3 - c, u = 1e3 * A / Math.abs(n._rate); !i._endTimers[t[l]] && n._paused || (i._clearTimer(t[l]), i._endTimers[t[l]] = setTimeout(i._ended.bind(i, n), u)), i._emit("rate", n._id) } return i }, seek: function () { var e, t, n = this, i = arguments; if (0 === i.length) n._sounds.length && (t = n._sounds[0]._id); else if (1 === i.length) { var r = n._getSoundIds(), o = r.indexOf(i[0]); o >= 0 ? t = parseInt(i[0], 10) : n._sounds.length && (t = n._sounds[0]._id, e = parseFloat(i[0])) } else 2 === i.length && (e = parseFloat(i[0]), t = parseInt(i[1], 10)); if (void 0 === t) return 0; if ("number" == typeof e && ("loaded" !== n._state || n._playLock)) return n._queue.push({ event: "seek", action: function () { n.seek.apply(n, i) } }), n; var a = n._soundById(t); if (a) { if (!("number" == typeof e && e >= 0)) { if (n._webAudio) { var l = n.playing(t) ? s.ctx.currentTime - a._playStart : 0, c = a._rateSeek ? a._rateSeek - a._seek : 0; return a._seek + (c + l * Math.abs(a._rate)) } return a._node.currentTime } var A = n.playing(t); A && n.pause(t, !0), a._seek = e, a._ended = !1, n._clearTimer(t), n._webAudio || !a._node || isNaN(a._node.duration) || (a._node.currentTime = e); var u = function () { A && n.play(t, !0), n._emit("seek", t) }; if (A && !n._webAudio) { var h = function () { n._playLock ? setTimeout(h, 0) : u() }; setTimeout(h, 0) } else u() } return n }, playing: function (e) { if ("number" == typeof e) { var t = this._soundById(e); return !!t && !t._paused } for (var n = 0; n < this._sounds.length; n++)if (!this._sounds[n]._paused) return !0; return !1 }, duration: function (e) { var t = this._duration, n = this._soundById(e); return n && (t = this._sprite[n._sprite][1] / 1e3), t }, state: function () { return this._state }, unload: function () { for (var e = this, t = e._sounds, n = 0; n < t.length; n++)t[n]._paused || e.stop(t[n]._id), e._webAudio || (e._clearSound(t[n]._node), t[n]._node.removeEventListener("error", t[n]._errorFn, !1), t[n]._node.removeEventListener(s._canPlayEvent, t[n]._loadFn, !1), t[n]._node.removeEventListener("ended", t[n]._endFn, !1), s._releaseHtml5Audio(t[n]._node)), delete t[n]._node, e._clearTimer(t[n]._id); var i = s._howls.indexOf(e); i >= 0 && s._howls.splice(i, 1); var r = !0; for (n = 0; n < s._howls.length; n++)if (s._howls[n]._src === e._src || e._src.indexOf(s._howls[n]._src) >= 0) { r = !1; break } return l && r && delete l[e._src], s.noAudio = !1, e._state = "unloaded", e._sounds = [], e = null, null }, on: function (e, t, n, i) { var r = this["_on" + e]; return "function" == typeof t && r.push(i ? { id: n, fn: t, once: i } : { id: n, fn: t }), this }, off: function (e, t, n) { var i = this["_on" + e], r = 0; if ("number" == typeof t && (n = t, t = null), t || n) for (r = 0; r < i.length; r++) { var s = n === i[r].id; if (t === i[r].fn && s || !t && s) { i.splice(r, 1); break } } else if (e) this["_on" + e] = []; else { var o = Object.keys(this); for (r = 0; r < o.length; r++)0 === o[r].indexOf("_on") && Array.isArray(this[o[r]]) && (this[o[r]] = []) } return this }, once: function (e, t, n) { return this.on(e, t, n, 1), this }, _emit: function (e, t, n) { for (var i = this["_on" + e], r = i.length - 1; r >= 0; r--)i[r].id && i[r].id !== t && "load" !== e || (setTimeout(function (e) { e.call(this, t, n) }.bind(this, i[r].fn), 0), i[r].once && this.off(e, i[r].fn, i[r].id)); return this._loadQueue(e), this }, _loadQueue: function (e) { if (this._queue.length > 0) { var t = this._queue[0]; t.event === e && (this._queue.shift(), this._loadQueue()), e || t.action() } return this }, _ended: function (e) { var t = e._sprite; if (!this._webAudio && e._node && !e._node.paused && !e._node.ended && e._node.currentTime < e._stop) return setTimeout(this._ended.bind(this, e), 100), this; var n = !(!e._loop && !this._sprite[t][2]); if (this._emit("end", e._id), !this._webAudio && n && this.stop(e._id, !0).play(e._id), this._webAudio && n) { this._emit("play", e._id), e._seek = e._start || 0, e._rateSeek = 0, e._playStart = s.ctx.currentTime; var i = 1e3 * (e._stop - e._start) / Math.abs(e._rate); this._endTimers[e._id] = setTimeout(this._ended.bind(this, e), i) } return this._webAudio && !n && (e._paused = !0, e._ended = !0, e._seek = e._start || 0, e._rateSeek = 0, this._clearTimer(e._id), this._cleanBuffer(e._node), s._autoSuspend()), this._webAudio || n || this.stop(e._id, !0), this }, _clearTimer: function (e) { if (this._endTimers[e]) { if ("function" != typeof this._endTimers[e]) clearTimeout(this._endTimers[e]); else { var t = this._soundById(e); t && t._node && t._node.removeEventListener("ended", this._endTimers[e], !1) } delete this._endTimers[e] } return this }, _soundById: function (e) { for (var t = 0; t < this._sounds.length; t++)if (e === this._sounds[t]._id) return this._sounds[t]; return null }, _inactiveSound: function () { this._drain(); for (var e = 0; e < this._sounds.length; e++)if (this._sounds[e]._ended) return this._sounds[e].reset(); return new a(this) }, _drain: function () { var e = this._pool, t = 0, n = 0; if (!(this._sounds.length < e)) { for (n = 0; n < this._sounds.length; n++)this._sounds[n]._ended && t++; for (n = this._sounds.length - 1; n >= 0; n--) { if (t <= e) return; this._sounds[n]._ended && (this._webAudio && this._sounds[n]._node && this._sounds[n]._node.disconnect(0), this._sounds.splice(n, 1), t--) } } }, _getSoundIds: function (e) { if (void 0 === e) { for (var t = [], n = 0; n < this._sounds.length; n++)t.push(this._sounds[n]._id); return t } return [e] }, _refreshBuffer: function (e) { return e._node.bufferSource = s.ctx.createBufferSource(), e._node.bufferSource.buffer = l[this._src], e._panner ? e._node.bufferSource.connect(e._panner) : e._node.bufferSource.connect(e._node), e._node.bufferSource.loop = e._loop, e._loop && (e._node.bufferSource.loopStart = e._start || 0, e._node.bufferSource.loopEnd = e._stop || 0), e._node.bufferSource.playbackRate.setValueAtTime(e._rate, s.ctx.currentTime), this }, _cleanBuffer: function (e) { var t = s._navigator && s._navigator.vendor.indexOf("Apple") >= 0; if (s._scratchBuffer && e.bufferSource && (e.bufferSource.onended = null, e.bufferSource.disconnect(0), t)) try { e.bufferSource.buffer = s._scratchBuffer } catch (e) { } return e.bufferSource = null, this }, _clearSound: function (e) { /MSIE |Trident\//.test(s._navigator && s._navigator.userAgent) || (e.src = "data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA") } }; var a = function (e) { this._parent = e, this.init() }; a.prototype = { init: function () { var e = this._parent; return this._muted = e._muted, this._loop = e._loop, this._volume = e._volume, this._rate = e._rate, this._seek = 0, this._paused = !0, this._ended = !0, this._sprite = "__default", this._id = ++s._counter, e._sounds.push(this), this.create(), this }, create: function () { var e = this._parent, t = s._muted || this._muted || this._parent._muted ? 0 : this._volume; return e._webAudio ? (this._node = void 0 === s.ctx.createGain ? s.ctx.createGainNode() : s.ctx.createGain(), this._node.gain.setValueAtTime(t, s.ctx.currentTime), this._node.paused = !0, this._node.connect(s.masterGain)) : s.noAudio || (this._node = s._obtainHtml5Audio(), this._errorFn = this._errorListener.bind(this), this._node.addEventListener("error", this._errorFn, !1), this._loadFn = this._loadListener.bind(this), this._node.addEventListener(s._canPlayEvent, this._loadFn, !1), this._endFn = this._endListener.bind(this), this._node.addEventListener("ended", this._endFn, !1), this._node.src = e._src, this._node.preload = !0 === e._preload ? "auto" : e._preload, this._node.volume = t * s.volume(), this._node.load()), this }, reset: function () { var e = this._parent; return this._muted = e._muted, this._loop = e._loop, this._volume = e._volume, this._rate = e._rate, this._seek = 0, this._rateSeek = 0, this._paused = !0, this._ended = !0, this._sprite = "__default", this._id = ++s._counter, this }, _errorListener: function () { this._parent._emit("loaderror", this._id, this._node.error ? this._node.error.code : 0), this._node.removeEventListener("error", this._errorFn, !1) }, _loadListener: function () { var e = this._parent; e._duration = Math.ceil(10 * this._node.duration) / 10, 0 === Object.keys(e._sprite).length && (e._sprite = { __default: [0, 1e3 * e._duration] }), "loaded" !== e._state && (e._state = "loaded", e._emit("load"), e._loadQueue()), this._node.removeEventListener(s._canPlayEvent, this._loadFn, !1) }, _endListener: function () { var e = this._parent; e._duration === 1 / 0 && (e._duration = Math.ceil(10 * this._node.duration) / 10, e._sprite.__default[1] === 1 / 0 && (e._sprite.__default[1] = 1e3 * e._duration), e._ended(this)), this._node.removeEventListener("ended", this._endFn, !1) } }; var l = {}, c = function (e) { var t = e._src; if (l[t]) return e._duration = l[t].duration, void h(e); if (/^data:[^;]+;base64,/.test(t)) { for (var n = atob(t.split(",")[1]), i = new Uint8Array(n.length), r = 0; r < n.length; ++r)i[r] = n.charCodeAt(r); u(i.buffer, e) } else { var s = new XMLHttpRequest; s.open(e._xhr.method, t, !0), s.withCredentials = e._xhr.withCredentials, s.responseType = "arraybuffer", e._xhr.headers && Object.keys(e._xhr.headers).forEach((function (t) { s.setRequestHeader(t, e._xhr.headers[t]) })), s.onload = function () { var t = (s.status + "")[0]; "0" === t || "2" === t || "3" === t ? u(s.response, e) : e._emit("loaderror", null, "Failed loading audio file with status: " + s.status + ".") }, s.onerror = function () { e._webAudio && (e._html5 = !0, e._webAudio = !1, e._sounds = [], delete l[t], e.load()) }, A(s) } }, A = function (e) { try { e.send() } catch (t) { e.onerror() } }, u = function (e, t) { var n = function () { t._emit("loaderror", null, "Decoding audio data failed.") }, i = function (e) { e && t._sounds.length > 0 ? (l[t._src] = e, h(t, e)) : n() }; "undefined" != typeof Promise && 1 === s.ctx.decodeAudioData.length ? s.ctx.decodeAudioData(e).then(i).catch(n) : s.ctx.decodeAudioData(e, i, n) }, h = function (e, t) { t && !e._duration && (e._duration = t.duration), 0 === Object.keys(e._sprite).length && (e._sprite = { __default: [0, 1e3 * e._duration] }), "loaded" !== e._state && (e._state = "loaded", e._emit("load"), e._loadQueue()) }, d = function () { if (s.usingWebAudio) { try { "undefined" != typeof AudioContext ? s.ctx = new AudioContext : "undefined" != typeof webkitAudioContext ? s.ctx = new webkitAudioContext : s.usingWebAudio = !1 } catch (e) { s.usingWebAudio = !1 } s.ctx || (s.usingWebAudio = !1); var e = /iP(hone|od|ad)/.test(s._navigator && s._navigator.platform), t = s._navigator && s._navigator.appVersion.match(/OS (\d+)_(\d+)_?(\d+)?/), n = t ? parseInt(t[1], 10) : null; if (e && n && n < 9) { var i = /safari/.test(s._navigator && s._navigator.userAgent.toLowerCase()); s._navigator && !i && (s.usingWebAudio = !1) } s.usingWebAudio && (s.masterGain = void 0 === s.ctx.createGain ? s.ctx.createGainNode() : s.ctx.createGain(), s.masterGain.gain.setValueAtTime(s._muted ? 0 : s._volume, s.ctx.currentTime), s.masterGain.connect(s.ctx.destination)), s._setup() } }; void 0 === (i = function () { return { Howler: s, Howl: o } }.apply(t, [])) || (e.exports = i), t.Howler = s, t.Howl = o, void 0 !== n ? (n.HowlerGlobal = r, n.Howler = s, n.Howl = o, n.Sound = a) : "undefined" != typeof window && (window.HowlerGlobal = r, window.Howler = s, window.Howl = o, window.Sound = a) }(), function () { "use strict"; var e; HowlerGlobal.prototype._pos = [0, 0, 0], HowlerGlobal.prototype._orientation = [0, 0, -1, 0, 1, 0], HowlerGlobal.prototype.stereo = function (e) { if (!this.ctx || !this.ctx.listener) return this; for (var t = this._howls.length - 1; t >= 0; t--)this._howls[t].stereo(e); return this }, HowlerGlobal.prototype.pos = function (e, t, n) { return this.ctx && this.ctx.listener ? (t = "number" != typeof t ? this._pos[1] : t, n = "number" != typeof n ? this._pos[2] : n, "number" != typeof e ? this._pos : (this._pos = [e, t, n], void 0 !== this.ctx.listener.positionX ? (this.ctx.listener.positionX.setTargetAtTime(this._pos[0], Howler.ctx.currentTime, .1), this.ctx.listener.positionY.setTargetAtTime(this._pos[1], Howler.ctx.currentTime, .1), this.ctx.listener.positionZ.setTargetAtTime(this._pos[2], Howler.ctx.currentTime, .1)) : this.ctx.listener.setPosition(this._pos[0], this._pos[1], this._pos[2]), this)) : this }, HowlerGlobal.prototype.orientation = function (e, t, n, i, r, s) { if (!this.ctx || !this.ctx.listener) return this; var o = this._orientation; return t = "number" != typeof t ? o[1] : t, n = "number" != typeof n ? o[2] : n, i = "number" != typeof i ? o[3] : i, r = "number" != typeof r ? o[4] : r, s = "number" != typeof s ? o[5] : s, "number" != typeof e ? o : (this._orientation = [e, t, n, i, r, s], void 0 !== this.ctx.listener.forwardX ? (this.ctx.listener.forwardX.setTargetAtTime(e, Howler.ctx.currentTime, .1), this.ctx.listener.forwardY.setTargetAtTime(t, Howler.ctx.currentTime, .1), this.ctx.listener.forwardZ.setTargetAtTime(n, Howler.ctx.currentTime, .1), this.ctx.listener.upX.setTargetAtTime(i, Howler.ctx.currentTime, .1), this.ctx.listener.upY.setTargetAtTime(r, Howler.ctx.currentTime, .1), this.ctx.listener.upZ.setTargetAtTime(s, Howler.ctx.currentTime, .1)) : this.ctx.listener.setOrientation(e, t, n, i, r, s), this) }, Howl.prototype.init = (e = Howl.prototype.init, function (t) { return this._orientation = t.orientation || [1, 0, 0], this._stereo = t.stereo || null, this._pos = t.pos || null, this._pannerAttr = { coneInnerAngle: void 0 !== t.coneInnerAngle ? t.coneInnerAngle : 360, coneOuterAngle: void 0 !== t.coneOuterAngle ? t.coneOuterAngle : 360, coneOuterGain: void 0 !== t.coneOuterGain ? t.coneOuterGain : 0, distanceModel: void 0 !== t.distanceModel ? t.distanceModel : "inverse", maxDistance: void 0 !== t.maxDistance ? t.maxDistance : 1e4, panningModel: void 0 !== t.panningModel ? t.panningModel : "HRTF", refDistance: void 0 !== t.refDistance ? t.refDistance : 1, rolloffFactor: void 0 !== t.rolloffFactor ? t.rolloffFactor : 1 }, this._onstereo = t.onstereo ? [{ fn: t.onstereo }] : [], this._onpos = t.onpos ? [{ fn: t.onpos }] : [], this._onorientation = t.onorientation ? [{ fn: t.onorientation }] : [], e.call(this, t) }), Howl.prototype.stereo = function (e, n) { var i = this; if (!i._webAudio) return i; if ("loaded" !== i._state) return i._queue.push({ event: "stereo", action: function () { i.stereo(e, n) } }), i; var r = void 0 === Howler.ctx.createStereoPanner ? "spatial" : "stereo"; if (void 0 === n) { if ("number" != typeof e) return i._stereo; i._stereo = e, i._pos = [e, 0, 0] } for (var s = i._getSoundIds(n), o = 0; o < s.length; o++) { var a = i._soundById(s[o]); if (a) { if ("number" != typeof e) return a._stereo; a._stereo = e, a._pos = [e, 0, 0], a._node && (a._pannerAttr.panningModel = "equalpower", a._panner && a._panner.pan || t(a, r), "spatial" === r ? void 0 !== a._panner.positionX ? (a._panner.positionX.setValueAtTime(e, Howler.ctx.currentTime), a._panner.positionY.setValueAtTime(0, Howler.ctx.currentTime), a._panner.positionZ.setValueAtTime(0, Howler.ctx.currentTime)) : a._panner.setPosition(e, 0, 0) : a._panner.pan.setValueAtTime(e, Howler.ctx.currentTime)), i._emit("stereo", a._id) } } return i }, Howl.prototype.pos = function (e, n, i, r) { var s = this; if (!s._webAudio) return s; if ("loaded" !== s._state) return s._queue.push({ event: "pos", action: function () { s.pos(e, n, i, r) } }), s; if (n = "number" != typeof n ? 0 : n, i = "number" != typeof i ? -.5 : i, void 0 === r) { if ("number" != typeof e) return s._pos; s._pos = [e, n, i] } for (var o = s._getSoundIds(r), a = 0; a < o.length; a++) { var l = s._soundById(o[a]); if (l) { if ("number" != typeof e) return l._pos; l._pos = [e, n, i], l._node && (l._panner && !l._panner.pan || t(l, "spatial"), void 0 !== l._panner.positionX ? (l._panner.positionX.setValueAtTime(e, Howler.ctx.currentTime), l._panner.positionY.setValueAtTime(n, Howler.ctx.currentTime), l._panner.positionZ.setValueAtTime(i, Howler.ctx.currentTime)) : l._panner.setPosition(e, n, i)), s._emit("pos", l._id) } } return s }, Howl.prototype.orientation = function (e, n, i, r) { var s = this; if (!s._webAudio) return s; if ("loaded" !== s._state) return s._queue.push({ event: "orientation", action: function () { s.orientation(e, n, i, r) } }), s; if (n = "number" != typeof n ? s._orientation[1] : n, i = "number" != typeof i ? s._orientation[2] : i, void 0 === r) { if ("number" != typeof e) return s._orientation; s._orientation = [e, n, i] } for (var o = s._getSoundIds(r), a = 0; a < o.length; a++) { var l = s._soundById(o[a]); if (l) { if ("number" != typeof e) return l._orientation; l._orientation = [e, n, i], l._node && (l._panner || (l._pos || (l._pos = s._pos || [0, 0, -.5]), t(l, "spatial")), void 0 !== l._panner.orientationX ? (l._panner.orientationX.setValueAtTime(e, Howler.ctx.currentTime), l._panner.orientationY.setValueAtTime(n, Howler.ctx.currentTime), l._panner.orientationZ.setValueAtTime(i, Howler.ctx.currentTime)) : l._panner.setOrientation(e, n, i)), s._emit("orientation", l._id) } } return s }, Howl.prototype.pannerAttr = function () { var e, n, i, r = this, s = arguments; if (!r._webAudio) return r; if (0 === s.length) return r._pannerAttr; if (1 === s.length) { if ("object" != typeof s[0]) return (i = r._soundById(parseInt(s[0], 10))) ? i._pannerAttr : r._pannerAttr; e = s[0], void 0 === n && (e.pannerAttr || (e.pannerAttr = { coneInnerAngle: e.coneInnerAngle, coneOuterAngle: e.coneOuterAngle, coneOuterGain: e.coneOuterGain, distanceModel: e.distanceModel, maxDistance: e.maxDistance, refDistance: e.refDistance, rolloffFactor: e.rolloffFactor, panningModel: e.panningModel }), r._pannerAttr = { coneInnerAngle: void 0 !== e.pannerAttr.coneInnerAngle ? e.pannerAttr.coneInnerAngle : r._coneInnerAngle, coneOuterAngle: void 0 !== e.pannerAttr.coneOuterAngle ? e.pannerAttr.coneOuterAngle : r._coneOuterAngle, coneOuterGain: void 0 !== e.pannerAttr.coneOuterGain ? e.pannerAttr.coneOuterGain : r._coneOuterGain, distanceModel: void 0 !== e.pannerAttr.distanceModel ? e.pannerAttr.distanceModel : r._distanceModel, maxDistance: void 0 !== e.pannerAttr.maxDistance ? e.pannerAttr.maxDistance : r._maxDistance, refDistance: void 0 !== e.pannerAttr.refDistance ? e.pannerAttr.refDistance : r._refDistance, rolloffFactor: void 0 !== e.pannerAttr.rolloffFactor ? e.pannerAttr.rolloffFactor : r._rolloffFactor, panningModel: void 0 !== e.pannerAttr.panningModel ? e.pannerAttr.panningModel : r._panningModel }) } else 2 === s.length && (e = s[0], n = parseInt(s[1], 10)); for (var o = r._getSoundIds(n), a = 0; a < o.length; a++)if (i = r._soundById(o[a])) { var l = i._pannerAttr; l = { coneInnerAngle: void 0 !== e.coneInnerAngle ? e.coneInnerAngle : l.coneInnerAngle, coneOuterAngle: void 0 !== e.coneOuterAngle ? e.coneOuterAngle : l.coneOuterAngle, coneOuterGain: void 0 !== e.coneOuterGain ? e.coneOuterGain : l.coneOuterGain, distanceModel: void 0 !== e.distanceModel ? e.distanceModel : l.distanceModel, maxDistance: void 0 !== e.maxDistance ? e.maxDistance : l.maxDistance, refDistance: void 0 !== e.refDistance ? e.refDistance : l.refDistance, rolloffFactor: void 0 !== e.rolloffFactor ? e.rolloffFactor : l.rolloffFactor, panningModel: void 0 !== e.panningModel ? e.panningModel : l.panningModel }; var c = i._panner; c ? (c.coneInnerAngle = l.coneInnerAngle, c.coneOuterAngle = l.coneOuterAngle, c.coneOuterGain = l.coneOuterGain, c.distanceModel = l.distanceModel, c.maxDistance = l.maxDistance, c.refDistance = l.refDistance, c.rolloffFactor = l.rolloffFactor, c.panningModel = l.panningModel) : (i._pos || (i._pos = r._pos || [0, 0, -.5]), t(i, "spatial")) } return r }, Sound.prototype.init = function (e) { return function () { var t = this._parent; this._orientation = t._orientation, this._stereo = t._stereo, this._pos = t._pos, this._pannerAttr = t._pannerAttr, e.call(this), this._stereo ? t.stereo(this._stereo) : this._pos && t.pos(this._pos[0], this._pos[1], this._pos[2], this._id) } }(Sound.prototype.init), Sound.prototype.reset = function (e) { return function () { var t = this._parent; return this._orientation = t._orientation, this._stereo = t._stereo, this._pos = t._pos, this._pannerAttr = t._pannerAttr, this._stereo ? t.stereo(this._stereo) : this._pos ? t.pos(this._pos[0], this._pos[1], this._pos[2], this._id) : this._panner && (this._panner.disconnect(0), this._panner = void 0, t._refreshBuffer(this)), e.call(this) } }(Sound.prototype.reset); var t = function (e, t) { "spatial" === (t = t || "spatial") ? (e._panner = Howler.ctx.createPanner(), e._panner.coneInnerAngle = e._pannerAttr.coneInnerAngle, e._panner.coneOuterAngle = e._pannerAttr.coneOuterAngle, e._panner.coneOuterGain = e._pannerAttr.coneOuterGain, e._panner.distanceModel = e._pannerAttr.distanceModel, e._panner.maxDistance = e._pannerAttr.maxDistance, e._panner.refDistance = e._pannerAttr.refDistance, e._panner.rolloffFactor = e._pannerAttr.rolloffFactor, e._panner.panningModel = e._pannerAttr.panningModel, void 0 !== e._panner.positionX ? (e._panner.positionX.setValueAtTime(e._pos[0], Howler.ctx.currentTime), e._panner.positionY.setValueAtTime(e._pos[1], Howler.ctx.currentTime), e._panner.positionZ.setValueAtTime(e._pos[2], Howler.ctx.currentTime)) : e._panner.setPosition(e._pos[0], e._pos[1], e._pos[2]), void 0 !== e._panner.orientationX ? (e._panner.orientationX.setValueAtTime(e._orientation[0], Howler.ctx.currentTime), e._panner.orientationY.setValueAtTime(e._orientation[1], Howler.ctx.currentTime), e._panner.orientationZ.setValueAtTime(e._orientation[2], Howler.ctx.currentTime)) : e._panner.setOrientation(e._orientation[0], e._orientation[1], e._orientation[2])) : (e._panner = Howler.ctx.createStereoPanner(), e._panner.pan.setValueAtTime(e._stereo, Howler.ctx.currentTime)), e._panner.connect(e._node), e._paused || e._parent.pause(e._id, !0).play(e._id, !0) } }() }).call(this, n(2)) }, function (e, t, n) { e.exports = n(23) }, function (e, t) { var n; n = function () { return this }(); try { n = n || new Function("return this")() } catch (e) { "object" == typeof window && (n = window) } e.exports = n }, function (e, t, n) { var i = { "./BoostCircle.png": 4, "./ParticleCircle.png": 5, "./ParticleSquare.jpg": 6, "./cloud.png": 7, "./confetti.png": 8, "./points.png": 9, "./splash_0.png": 10, "./splash_1.png": 11, "./splash_2.png": 12 }; function r(e) { var t = s(e); return n(t) } function s(e) { if (!n.o(i, e)) { var t = new Error("Cannot find module '" + e + "'"); throw t.code = "MODULE_NOT_FOUND", t } return i[e] } r.keys = function () { return Object.keys(i) }, r.resolve = s, e.exports = r, r.id = 3 }, function (e, t, n) { "use strict"; n.r(t), t.default = "data:image/png;base64,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" }, function (e, t, n) { "use strict"; n.r(t), t.default = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAACXBIWXMAAAsTAAALEwEAmpwYAAABWUlEQVRYhc2Xv0rDUBSHv/oHhL5A6+AQQRAndVFEOomj7+QTdCh9jG4dHDsIDm2dRBDM0CV9gYKQ4Tj0plxv/rQXk5P8IMtNcr6Py73JPS0Roc7s1UoHDjyfPwcegTvgDOgCR8APEAFfwCvwAnzuVFFEdrnuRWQkfhmZ9wprbwPvi8jAE+xmYOp4CxyLyPSf8CRTUy/FaUn2LugCb8CJ5xopygK4Yb1WNskSOATegYsS4Uk+gEsgTgaytmG/Ijimbt8ecGfgCphVBLdzDcwhPQPPCvA/HHsGAuBbSQDgFAjtGXhShG94tkBPWaDnCgTKAoEr0FEW6LgCbWWBtiuwUhZYuQJLZYGlKxAqC4SuwERZYAIN+xKGwFgJPja85v0N58CwYvgwgUNDT0Qx8MD6DFdmFqZubA/mdUYRcEt562Fm6kWpOwXH8tr7ApXOKK8vyEvpvaGvQOn5BY6dfwJtyyOwAAAAAElFTkSuQmCC" }, function (e, t, n) { "use strict"; n.r(t), t.default = "data:image/jpeg;base64,/9j/7gAhQWRvYmUAZIAAAAABAwAQAwIDBgAAAAAAAAAAAAAAAP/bAIQADAgICAkIDAkJDBELCgsRFQ8MDA8VGBMTFRMTGBEMDAwMDAwRDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAENCwsNDg0QDg4QFA4ODhQUDg4ODhQRDAwMDAwREQwMDAwMDBEMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwM/8IAEQgAQABAAwEiAAIRAQMRAf/EAF4AAQEAAAAAAAAAAAAAAAAAAAAHAQEAAAAAAAAAAAAAAAAAAAAAEAEBAAAAAAAAAAAAAAAAAABAYBEBAAAAAAAAAAAAAAAAAAAAYBIBAAAAAAAAAAAAAAAAAAAAQP/aAAwDAQECEQMRAAAAqoAAAAAAAAAAAAAAAP/aAAgBAgABBQAH/9oACAEDAAEFAAf/2gAIAQEAAQUAgP/aAAgBAgIGPwAH/9oACAEDAgY/AAf/2gAIAQEBBj8AAf/Z" }, function (e, t, n) { "use strict"; n.r(t), t.default = "data:image/png;base64,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" }, function (e, t, n) { "use strict"; n.r(t), t.default = "data:image/png;base64,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" }, function (e, t, n) { "use strict"; n.r(t), t.default = "data:image/png;base64,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" }, function (e, t, n) { "use strict"; n.r(t), t.default = "data:image/png;base64,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" }, function (e, t, n) { "use strict"; n.r(t), t.default = "data:image/png;base64,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" }, function (e, t, n) { "use strict"; n.r(t), t.default = "data:image/png;base64,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" }, function (e, t, n) { var i = { "./BoostArrow.glb": 14, "./Pie.glb": 15, "./PieMin.glb": 16, "./PieMin2.glb": 17, "./PieRounded.glb": 18 }; function r(e) { var t = s(e); return n(t) } function s(e) { if (!n.o(i, e)) { var t = new Error("Cannot find module '" + e + "'"); throw t.code = "MODULE_NOT_FOUND", t } return i[e] } r.keys = function () { return Object.keys(i) }, r.resolve = s, e.exports = r, r.id = 13 }, function (e, t, n) { "use strict"; n.r(t), t.default = "data:model/gltf-binary;base64,Z2xURgIAAAD8FAAAeAQAAEpTT057ImFzc2V0Ijp7ImdlbmVyYXRvciI6Iktocm9ub3MgZ2xURiBCbGVuZGVyIEkvTyB2MS41LjE3IiwidmVyc2lvbiI6IjIuMCJ9LCJzY2VuZSI6MCwic2NlbmVzIjpbeyJuYW1lIjoiU2NlbmUiLCJub2RlcyI6WzBdfV0sIm5vZGVzIjpbeyJtZXNoIjowLCJuYW1lIjoiQm9vc3RBcnJvdyJ9XSwibWF0ZXJpYWxzIjpbeyJkb3VibGVTaWRlZCI6dHJ1ZSwibmFtZSI6Ik1hdGVyaWFsLjAwMSIsInBick1ldGFsbGljUm91Z2huZXNzIjp7ImJhc2VDb2xvckZhY3RvciI6WzAuMDkwNTU5NjUzOTM3ODE2NjIsMC44MDAwMDAwNzE1MjU1NzM3LDAuMDMxMTU1MzU1Mjc0Njc3Mjc3LDFdLCJtZXRhbGxpY0ZhY3RvciI6MCwicm91Z2huZXNzRmFjdG9yIjowLjV9fV0sIm1lc2hlcyI6W3sibmFtZSI6IkN1YmUuMDAzIiwicHJpbWl0aXZlcyI6W3siYXR0cmlidXRlcyI6eyJQT1NJVElPTiI6MCwiTk9STUFMIjoxLCJURVhDT09SRF8wIjoyfSwiaW5kaWNlcyI6MywibWF0ZXJpYWwiOjB9XX1dLCJhY2Nlc3NvcnMiOlt7ImJ1ZmZlclZpZXciOjAsImNvbXBvbmVudFR5cGUiOjUxMjYsImNvdW50IjoxMjAsIm1heCI6WzAuNTA0MzMyMDY1NTgyMjc1NCwxLjY3MDU1MTE4MDgzOTUzODYsMC4wNzc1NDg3NjQ2NDYwNTMzMV0sIm1pbiI6Wy0wLjUwNDMzMjA2NTU4MjI3NTQsLTAuMTQwNTYwNDYzMDcwODY5NDUsLTAuMDc3NTQ4NzY0NjQ2MDUzMzFdLCJ0eXBlIjoiVkVDMyJ9LHsiYnVmZmVyVmlldyI6MSwiY29tcG9uZW50VHlwZSI6NTEyNiwiY291bnQiOjEyMCwidHlwZSI6IlZFQzMifSx7ImJ1ZmZlclZpZXciOjIsImNvbXBvbmVudFR5cGUiOjUxMjYsImNvdW50IjoxMjAsInR5cGUiOiJWRUMyIn0seyJidWZmZXJWaWV3IjozLCJjb21wb25lbnRUeXBlIjo1MTIzLCJjb3Vu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" }, function (e, t, n) { "use strict"; n.r(t), t.default = "data:model/gltf-binary;base64,Z2xURgIAAAA4CAAARAQAAEpTT057ImFzc2V0Ijp7ImdlbmVyYXRvciI6Iktocm9ub3MgZ2xURiBCbGVuZGVyIEkvTyB2MS41LjE3IiwidmVyc2lvbiI6IjIuMCJ9LCJzY2VuZSI6MCwic2NlbmVzIjpbeyJuYW1lIjoiU2NlbmUiLCJub2RlcyI6WzBdfV0sIm5vZGVzIjpbeyJtZXNoIjowLCJuYW1lIjoiUGllIiwicm90YXRpb24iOlswLjcwNzEwNjgyODY4OTU3NTIsMCwwLDAuNzA3MTA2NzA5NDgwMjg1Nl0sInRyYW5zbGF0aW9uIjpbMCwwLjQwMzU4MjY5MjE0NjMwMTI3LDBdfV0sIm1hdGVyaWFscyI6W3siZG91YmxlU2lkZWQiOnRydWUsIm5hbWUiOiJDaGVlc2VfTGV2ZWxfMDEiLCJwYnJNZXRhbGxpY1JvdWdobmVzcyI6eyJiYXNlQ29sb3JGYWN0b3IiOlswLjgwMDAwMDAxMTkyMDkyOSwwLjgwMDAwMDAxMTkyMDkyOSwwLjgwMDAwMDAxMTkyMDkyOSwxXSwibWV0YWxsaWNGYWN0b3IiOjAsInJvdWdobmVzc0ZhY3RvciI6MC41fX1dLCJtZXNoZXMiOlt7Im5hbWUiOiJQaWUiLCJwcmltaXRpdmVzIjpbeyJhdHRyaWJ1dGVzIjp7IlBPU0lUSU9OIjowLCJOT1JNQUwiOjF9LCJpbmRpY2VzIjoyLCJtYXRlcmlhbCI6MH1dfV0sImFjY2Vzc29ycyI6W3siYnVmZmVyVmlldyI6MCwiY29tcG9uZW50VHlwZSI6NTEyNiwiY291bnQiOjM2LCJtYXgiOlstNS45MDA1NTg5NzQ3NTg0OTYzZS0wOCwxLjk3OTkwMDk1NjE1Mzg2OTYsMC42OTYwNTU4ODkxMjk2Mzg3XSwibWluIjpbLTIuNzk5OTk5OTUyMzE2Mjg0LDguODUwODM4MDcxMzM5MjRlLTA3LDAuMjI0MTY3NzkzOTg5MTgxNTJdLCJ0eXBlIjoiVkVDMyJ9LHsiYnVmZmVyVmlldyI6MSwiY29tcG9uZW50VHlwZSI6NTEyNiwiY291bnQiOjM2LCJ0eXBlIjoiVkVDMyJ9LHsiYnVmZmVyVmlldyI6MiwiY29tcG9uZW50VHlwZSI6NTEyMywiY291bnQiOjYwLCJ0eXBlIjoiU0NBTEFSIn1dLCJidWZmZXJWaWV3cyI6W3siYnVmZmVyIjowLCJieXRlTGVuZ3RoIjo0MzIsImJ5dGVPZmZzZXQiOjB9LHsiYnVmZmVyIjowLCJieXRlTGVuZ3RoIjo0MzIsImJ5dGVPZmZzZXQiOjQzMn0seyJidWZmZXIiOjAsImJ5dGVMZW5ndGgiOjEyMCwiYnl0ZU9mZnNldCI6ODY0fV0sImJ1ZmZlcnMiOlt7ImJ5dGVMZW5ndGgiOjk4NH1dfSDYAwAAQklOAFVtfbN/lm01PoxlPi8zM8BOHg82PoxlPrXBL8Bh1ws/PoxlPiGPJcBwJ4k/PoxlPs7/FMDeHcc/PoxlPkRt/b9lbf0/PoxlPlVtfbN/lm01PoxlPlVtfbN/lm01uDAyPzMzM8Apdgk2tTAyPy8zM8BOHg82PoxlPlVtfbN/lm01PoxlPkRt/b9lbf0/PoxlPkRt/b9lbf0/uDAyP1VtfbN/lm01uDAyP7XBL8Bh1ws/tTAyPzMzM8Apdgk2tTAyP1VtfbN/lm01uDAyPyGPJcBwJ4k/tzAyP87/FMDeHcc/tzAyP0Rt/b9lbf0/uDAyP7XBL8Bh1ws/PoxlPi8zM8BOHg82PoxlPjMzM8Apdgk2tTAyP7XBL8Bh1ws/tTAyP7XBL8Bh1ws/tTAyPyGPJcBwJ4k/tzAyPyGPJcBwJ4k/PoxlPrXBL8Bh1ws/PoxlPiGPJcBwJ4k/tzAyP87/FMDeHcc/tzAyP87/FMDeHcc/PoxlPiGPJcBwJ4k/PoxlPs7/FMDeHcc/PoxlPs7/FMDeHcc/tzAyP0Rt/b9lbf0/uDAyP0Rt/b9lbf0/PoxlPgAAAABWJQAzAACAvwAAAADFXycxAACAvwAAAAC8miwzAACAvwAAAAC/XyczAACAvwAAAADPX6cyAACAvwAAAADMXyczAACAv3jC4LQAAIC/yhijsq0K37QAAIC/AAAAgHl87bT//3+/gWortEY077QAAIC/nM0/tPwENT/pBDU/AAAAgP0ENT/qBDU/AAAAgPwENT/pBDU/AAAAgPwENT/qBDU/AAAAgNc4tLPF/Ye0//9/P5IkibMAAAAAAACAP3apjbPDI+azAACAPwnog7PNwoK0AACAPyA0TrPMXyczAACAPy6xpbOwD3szAACAP23Efr+Lvcg9LayotWzEfr8Lvcg96o46tmzEfr91vcg9p3HMtWrEfr/yvcg9AAAAgAT6dL9joJQ+AAAAgAP6dL9goJQ+AAAAgAP6dL9ioJQ+AAAAgAL6dL9loJQ+AAAAgJfFYb/vWvE+AAAAgJbFYb/rWvE+AAAAgJfFYb/vWvE+AAAAgJXFYb/wWvE+AAAAgP3jRb+iZyI/AAAAgP3jRb+iZyI/AAAAgPzjRb+hZyI/AAAAgP3jRb+hZyI/AAAAgAAAAQACAAIAAwAAAAMABAAAAAQABQAAAAYABwAIAAkABgAIAAoACwAMAA0ACgAMAA4ADwAQABAAEQAOABAAEgARABAAEwASABQAFQAWABcAFAAWABgAGQAaABsAGAAaABwAHQAeAB8AHAAeACAAIQAiACMAIAAiAA==" }, function (e, t, n) { "use strict"; n.r(t), t.default = "data:model/gltf-binary;base64,Z2xURgIAAADgBgAAbAQAAEpTT057ImFzc2V0Ijp7ImdlbmVyYXRvciI6Iktocm9ub3MgZ2xURiBCbGVuZGVyIEkvTyB2MS41LjE3IiwidmVyc2lvbiI6IjIuMCJ9LCJzY2VuZSI6MCwic2NlbmVzIjpbeyJuYW1lIjoiU2NlbmUiLCJub2RlcyI6WzBdfV0sIm5vZGVzIjpbeyJtZXNoIjowLCJuYW1lIjoiUGllIiwicm90YXRpb24iOlswLjY5MzMwMTczNzMwODUwMjIsLTAuMTM5MDQyMzMyNzY4NDQwMjUsMC4xMzkwNDIzNDc2Njk2MDE0NCwwLjY5MzMwMTYxODA5OTIxMjZdLCJ0cmFuc2xhdGlvbiI6WzAsMC4yNzI4Mjk1NjI0MjU2MTM0LDBdfV0sIm1hdGVyaWFscyI6W3siZG91YmxlU2lkZWQiOnRydWUsIm5hbWUiOiJDaGVlc2VfTGV2ZWxfMDEiLCJwYnJNZXRhbGxpY1JvdWdobmVzcyI6eyJiYXNlQ29sb3JGYWN0b3IiOlswLjgwMDAwMDAxMTkyMDkyOSwwLjgwMDAwMDAxMTkyMDkyOSwwLjgwMDAwMDAxMTkyMDkyOSwxXSwibWV0YWxsaWNGYWN0b3IiOjAsInJvdWdobmVzc0ZhY3RvciI6MC41fX1dLCJtZXNoZXMiOlt7Im5hbWUiOiJQaWUiLCJwcmltaXRpdmVzIjpbeyJhdHRyaWJ1dGVzIjp7IlBPU0lUSU9OIjowLCJOT1JNQUwiOjF9LCJpbmRpY2VzIjoyLCJtYXRlcmlhbCI6MH1dfV0sImFjY2Vzc29ycyI6W3siYnVmZmVyVmlldyI6MCwiY29tcG9uZW50VHlwZSI6NTEyNiwiY291bnQiOjIyLCJtYXgiOlstMS4xOTIwOTI4OTU1MDc4MTI1ZS0wNywxLjk3OTkwMDk1NjE1Mzg2OTYsMC40NjE2NDA4MzQ4MDgzNDk2XSwibWluIjpbLTIuNTg2ODYxMTMzNTc1NDM5NSw4LjM0NDY1MDI2ODU1NDY4OGUtMDcsLTAuMDEwMjQ3MjQ1NDMwOTQ2MzVdLCJ0eXBlIjoiVkVDMyJ9LHsiYnVmZmVyVmlldyI6MSwiY29tcG9uZW50VHlwZSI6NTEyNiwiY291bnQiOjIyLCJ0eXBlIjoiVkVDMyJ9LHsiYnVmZmVyVmlldyI6MiwiY29tcG9uZW50VHlwZSI6NTEyMywiY291bnQiOjM2LCJ0eXBlIjoiU0NBTEFSIn1dLCJidWZmZXJWaWV3cyI6W3siYnVmZmVyIjowLCJieXRlTGVuZ3RoIjoyNjQsImJ5dGVPZmZzZXQiOjB9LHsiYnVmZmVyIjowLCJieXRlTGVuZ3RoIjoyNjQsImJ5dGVPZmZzZXQiOjI2NH0seyJidWZmZXIiOjAsImJ5dGVMZW5ndGgiOjcyLCJieXRlT2Zmc2V0Ijo1Mjh9XSwiYnVmZmVycyI6W3siYnl0ZUxlbmd0aCI6NjAwfV19ICAgWAIAAEJJTgAAAAC0AABgNRDkJ7wijyXAcCeJPxDkJ7zO/xTA3h3HPxDkJ7xFbf2/ZW39PxDkJ7wAAAC0AABgNRDkJ7wAAAC0AABgNRDkJ7xFbf2/ZW39PxDkJ7xFbf2/ZW39PzBc7D4AAAC0AABgNTBc7D4AAAC0AABgNTBc7D4AAAC0AABgNTBc7D4ijyXAcCeJPy5c7D7O/xTA3h3HPy5c7D5Fbf2/ZW39PzBc7D4ijyXAcCeJPy5c7D7O/xTA3h3HPy5c7D7O/xTA3h3HPxDkJ7wijyXAcCeJPxDkJ7zO/xTA3h3HPxDkJ7zO/xTA3h3HPy5c7D5Fbf2/ZW39PzBc7D5Fbf2/ZW39PxDkJ7wAAAAAAAAAAAAAgL8AAAAAAAAAAAAAgL8AAAAAAAAAAAAAgL8AAAAAAAAAAAAAgL8t78O+W4NsvwAAAID9BDU/6gQ1PwAAAID8BDU/6gQ1PwAAAID7BDU/6QQ1PwAAAID8BDU/6AQ1PwAAAIAt78O+W4NsvwAAAIAaNE6zzl+nMQAAgD/AC6KyxV8nMgAAgD8jNE6zw1+nMQAAgD8wsaWzAAAAAAAAgD8KCXG/wXysvgAAAICUxWG/9VrxPgAAAICUxWG/+lrxPgAAAIAMCXG/v3ysvgAAAID/40W/nmciPwAAAID/40W/oGciPwAAAID/40W/nWciPwAAAIAA5EW/nWciPwAAAIABAAIAAAACAAMAAAAFAAYABwAIAAUABwAEAAkADgAEAA4AEQAKAAwACwAKAA0ADAAOAA8AEAARAA4AEAASABMAFAAVABIAFAA=" }, function (e, t, n) { "use strict"; n.r(t), t.default = "data:model/gltf-binary;base64,Z2xURgIAAABsBgAAcAQAAEpTT057ImFzc2V0Ijp7ImdlbmVyYXRvciI6Iktocm9ub3MgZ2xURiBCbGVuZGVyIEkvTyB2MS41LjE3IiwidmVyc2lvbiI6IjIuMCJ9LCJzY2VuZSI6MCwic2NlbmVzIjpbeyJuYW1lIjoiU2NlbmUiLCJub2RlcyI6WzBdfV0sIm5vZGVzIjpbeyJtZXNoIjowLCJuYW1lIjoiUGllIiwicm90YXRpb24iOlswLjY5MzUxOTU5MjI4NTE1NjIsLTAuMTM3OTUxNzYxNDg0MTQ2MTIsMC4xMzc5NTE3NzYzODUzMDczLDAuNjkzNTE5NDczMDc1ODY2N10sInRyYW5zbGF0aW9uIjpbMCwwLjI3MjgyOTU2MjQyNTYxMzQsMF19XSwibWF0ZXJpYWxzIjpbeyJkb3VibGVTaWRlZCI6dHJ1ZSwibmFtZSI6IkNoZWVzZV9MZXZlbF8wMS4wMDEiLCJwYnJNZXRhbGxpY1JvdWdobmVzcyI6eyJiYXNlQ29sb3JGYWN0b3IiOlswLjgwMDAwMDAxMTkyMDkyOSwwLjgwMDAwMDAxMTkyMDkyOSwwLjgwMDAwMDAxMTkyMDkyOSwxXSwibWV0YWxsaWNGYWN0b3IiOjAsInJvdWdobmVzc0ZhY3RvciI6MC41fX1dLCJtZXNoZXMiOlt7Im5hbWUiOiJQaWUuMDAxIiwicHJpbWl0aXZlcyI6W3siYXR0cmlidXRlcyI6eyJQT1NJVElPTiI6MCwiTk9STUFMIjoxfSwiaW5kaWNlcyI6MiwibWF0ZXJpYWwiOjB9XX1dLCJhY2Nlc3NvcnMiOlt7ImJ1ZmZlclZpZXciOjAsImNvbXBvbmVudFR5cGUiOjUxMjYsImNvdW50IjoxOCwibWF4IjpbLTEuMTkyMDkyODk1NTA3ODEyNWUtMDcsMS41NTU1OTg5NzQyMjc5MDUzLDAuNDYxNjQwODM0ODA4MzQ5Nl0sIm1pbiI6Wy0yLjU4Njg2MTEzMzU3NTQzOTUsOC4zNDQ2NTAyNjg1NTQ2ODhlLTA3LC0wLjAxMDI0NzI0NTQzMDk0NjM1XSwidHlwZSI6IlZFQzMifSx7ImJ1ZmZlclZpZXciOjEsImNvbXBvbmVudFR5cGUiOjUxMjYsImNvdW50IjoxOCwidHlwZSI6IlZFQzMifSx7ImJ1ZmZlclZpZXciOjIsImNvbXBvbmVudFR5cGUiOjUxMjMsImNvdW50IjoyNCwidHlwZSI6IlNDQUxBUiJ9XSwiYnVmZmVyVmlld3MiOlt7ImJ1ZmZlciI6MCwiYnl0ZUxlbmd0aCI6MjE2LCJieXRlT2Zmc2V0IjowfSx7ImJ1ZmZlciI6MCwiYnl0ZUxlbmd0aCI6MjE2LCJieXRlT2Zmc2V0IjoyMTZ9LHsiYnVmZmVyIjowLCJieXRlTGVuZ3RoIjo0OCwiYnl0ZU9mZnNldCI6NDMyfV0sImJ1ZmZlcnMiOlt7ImJ5dGVMZW5ndGgiOjQ4MH1dfeABAABCSU4AAAAAtAAAYDUQ5Ce8AAAAtAAAYDUQ5Ce8AAAAtAAAYDUQ5Ce8Io8lwHAniT8Q5Ce8Io8lwHAniT8Q5Ce8Io8lwHAniT8Q5Ce8zv8UwN4dxz8Q5Ce8zv8UwN4dxz8Q5Ce8zv8UwN4dxz8Q5Ce8AAAAtAAAYDUwXOw+AAAAtAAAYDUwXOw+AAAAtAAAYDUwXOw+Io8lwHAniT8uXOw+Io8lwHAniT8uXOw+Io8lwHAniT8uXOw+zv8UwN4dxz8uXOw+zv8UwN4dxz8uXOw+zv8UwN4dxz8uXOw+Le/DvluDbL8AAACAAAAAAAAAAAAAAIC/5TkOPyrbVD8AAACAlMVhv/la8T4AAACALe/DvluDbL8AAACAAAAAAAAAAAAAAIC/lMVhv/la8T4AAACAAAAAAAAAAAAAAIC/5TkOPyrbVD8AAACALe/DvluDbL8AAACAwAuissVfJzIAAIA/5TkOPyrbVD8AAACAlMVhv/la8T4AAACALe/DvluDbL8AAACAwAuissVfJzIAAIA/lMVhv/la8T4AAACAwAuissVfJzIAAIA/5TkOPyrbVD8AAACABQAHAAEABAAAAAkABAAJAA0ACgAQAA4ACAARAAsACAALAAIABgADAAwABgAMAA8A" }, function (e, t, n) { "use strict"; n.r(t), t.default = "data:model/gltf-binary;base64,Z2xURgIAAAC0FQAAcAQAAEpTT057ImFzc2V0Ijp7ImdlbmVyYXRvciI6Iktocm9ub3MgZ2xURiBCbGVuZGVyIEkvTyB2MS41LjE3IiwidmVyc2lvbiI6IjIuMCJ9LCJzY2VuZSI6MCwic2NlbmVzIjpbeyJuYW1lIjoiU2NlbmUiLCJub2RlcyI6WzBdfV0sIm5vZGVzIjpbeyJtZXNoIjowLCJuYW1lIjoiUGllIiwicm90YXRpb24iOlswLjY5MzMwMTczNzMwODUwMjIsLTAuMTM5MDQyMzMyNzY4NDQwMjUsMC4xMzkwNDIzNDc2Njk2MDE0NCwwLjY5MzMwMTYxODA5OTIxMjZdLCJ0cmFuc2xhdGlvbiI6WzAsMC4yNzI4Mjk1NjI0MjU2MTM0LDBdfV0sIm1hdGVyaWFscyI6W3siZG91YmxlU2lkZWQiOnRydWUsIm5hbWUiOiJDaGVlc2VfTGV2ZWxfMDEiLCJwYnJNZXRhbGxpY1JvdWdobmVzcyI6eyJiYXNlQ29sb3JGYWN0b3IiOlswLjgwMDAwMDAxMTkyMDkyOSwwLjgwMDAwMDAxMTkyMDkyOSwwLjgwMDAwMDAxMTkyMDkyOSwxXSwibWV0YWxsaWNGYWN0b3IiOjAsInJvdWdobmVzc0ZhY3RvciI6MC41fX1dLCJtZXNoZXMiOlt7Im5hbWUiOiJQaWUiLCJwcmltaXRpdmVzIjpbeyJhdHRyaWJ1dGVzIjp7IlBPU0lUSU9OIjowLCJOT1JNQUwiOjF9LCJpbmRpY2VzIjoyLCJtYXRlcmlhbCI6MH1dfV0sImFjY2Vzc29ycyI6W3siYnVmZmVyVmlldyI6MCwiY29tcG9uZW50VHlwZSI6NTEyNiwiY291bnQiOjE2MiwibWF4IjpbLTAuMDI4MDc1NjEzMDgxNDU1MjMsMS45NTM1NTQyNzI2NTE2NzI0LDAuNDYxNjQwODM0ODA4MzQ5Nl0sIm1pbiI6Wy0yLjU2NDYxNTcyNjQ3MDk0NzMsMC4wMTc1Njg0NDY2OTU4MDQ1OTYsLTAuMDEwMjQ3MjQ1NDMwOTQ2MzVdLCJ0eXBlIjoiVkVDMyJ9LHsiYnVmZmVyVmlldyI6MSwiY29tcG9uZW50VHlwZSI6NTEyNiwiY291bnQiOjE2MiwidHlwZSI6IlZFQzMifSx7ImJ1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" }, function (e, t, n) { var i = { "./Platform.mp3": 20, "./Splash.mp3": 21 }; function r(e) { var t = s(e); return n(t) } function s(e) { if (!n.o(i, e)) { var t = new Error("Cannot find module '" + e + "'"); throw t.code = "MODULE_NOT_FOUND", t } return i[e] } r.keys = function () { return Object.keys(i) }, r.resolve = s, e.exports = r, r.id = 19 }, function (e, t, n) { "use strict"; n.r(t), t.default = "data:audio/mpeg;base64,SUQzBAAAAAAAaVRJVDIAAAAgAAADMDQ1MTdfbWVjaGFuaWNfY2xpY2tpbmdfYnV0dG9uAFREUkMAAAASAAADMjAxNC0wMy0xM1QyMjoxMQBUU1NFAAAADwAAA0xhdmY1OC43Ni4xMDAAAAAAAAAAAAAAAP/7UAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFhpbmcAAAAPAAAACQAAHcQAKioqKioqKioqKipGRkZGRkZGRkZGRmlpaWlpaWlpaWlpjIyMjIyMjIyMjIykpKSkpKSkpKSkpL29vb29vb29vb291dXV1dXV1dXV1dX5+fn5+fn5+fn5+f//////////////AAAAAExhdmM1OC4xMwAAAAAAAAAAAAAAACQFcgAAAAAAAB3EqSpvpwAAAAAAAAAAAAAAAAAAAAD/++BkAAACygDUbQQACjDgCXygAAEiddE5+cwQAsak5zczggAElJySNy2y3gdHDw8AAAAAAw8PDw8AAP4Bh//4AI//D39DwAAAABGHh4ePAAAR6M/////iMP//AAD//w8PP/AAAAMPf/gBn////gAAAACMPDw88AAAD95h48kkBdIn7hBwuD4Pg4GAwUXLh+XB8HwffLh+XP8Hwff4nD7vWH5AHw/Z8EP/y5/4IAgAkjKsAQkRAJlcS243EWmAcMHIUDZnoFgoLm0CCZGCgOSIWBxgwBmPAYZZHAOO5hkYGFwkYLIph8cukFgCKtHWiaUI2KB1kAKgjJ5kRxASlpKKmcCVTEo7FQ5gQC67YLKYzqQYEGIiS8IDR9N5UTIGTyQXYK2BiD9WpThYjDt14PgSZk/IxYeCqzSvH4q28WtNYarc9/X0lMTgCO0TQZqQyN8Z2ORKB77/xNjNPyiuSyUR2LONhOZ3PllDI5fF5DSxWXVIag2YjlV+eRR9KSX/Q09FSUf9giQ2o45FJK4AlnynLKVVcZTWrSqrSymt3///////////////////+tjurllW3jjllW3jVyv01XdLqtW3VmQBCu8gGDwvS/nqWBwxWMyjGUSRjjNEOsWsrEcMwYVV20h0SOL0t4yikxpM1aoOYbhcnMaByAmxkqWDKkvbz49bZb+QhI5KDA0CBpVLdNM5Hd09L9rjPY9E319ujGIdfyg40SG9RdsVZyX+zmXapexmHZFuBLtnGzz+9s/em5zX1t9/eVv/rXv////1zmVTL/5f3l8sXDPxfcfmLda0pz2YVF00CoH//3vY1ilpLmlxKQMKUhsygyZKcaVqckbjYAB4KZcEnPCRjAQdsVDxiLFC6yZfUAMAEjBgUeDzECQcDVPiEYRSLOKfM3ADBRE1VfKX0Chm82IOGQWncAjIcOeqLM5WERlcNXglDCq5UA0FedgReSKXn0qr6d+HnblqiSgjYFkP3DjatephIbCGlslcuOuZJmnxjtV26aHn0o5JLoDae/LdJ2H767CAEFwLtspUah+1cp56SxGSQiV3q9PE6mMzXsXrMvh56WlSKTvxHMKXOOwFPS6LPz85hal0zQv1Wk8D9ry+QQ4+kDw0u1Nx3jBChXsAoHAHIrN8rFXpSAHwp7lNJInAMQAczCmmdWI0Es0jJhkx8BAwZFbGw+guBdRrlcMsEMGGgbqcvMZHSeKRNpjQkudKprFGWREncfRBT5ARXZkRSNYjvM1e+/dX3X/nDb+o9/MiCJOpCm/pG6jWgb0TIxpnVaTaGWgEBIkVKm0IxAIRpTkCBMyAc1QWQKeCQRGZTaHEBwQYRlDjJIQNYhAwQNzJyCMbh8x6MDvCKMPgwxgxGMwZhmIKXhQMwwT/+9Bk0AAG+E9Pbm9AAHdJOh/MzAAl+X9H+c0SBB2vp783oggAjFvhIGHDzQrwUwM0+OYwNRCEA2Xp+hDkySwOdQybcGisIwaAJg6RhMLIC4KCIT0dg4iliYMKpBCUj2ZgQAGIkTanGAgKrZGRgIICxQMAR9jgoAMWBZeWTU/DFxN4IAVXGQua26pQlMgKbiABRWDBgQOCMvZHZh0MDocH9pWxNFeFmKaruShmUmo6ipGZoPgooXgYpEJu3AIVDsHMWFauhQ8KuWm06tzXnnfwlATkhk965Lm+WIkHceMwwoaAq4cFAG1IAAEaDlJhAXNKNCHCZrj2P/////f/+hIfFOf//////z0NsydIhHdgADUBQJwAAwQEANKZRahHABujfmqJZghwGR4MAgyTMDJSIEa0sVk5kYeb1TbginyOORGDyKDhmAFNhdxZZqAwBXm1BzReFn7NkGzJBGGIiGMMHOCKxC1AoLXtVr4sCgT5ZwWGmRDsMlsx//7wv7/NYUmMmMKFQ+HQYCeLC///J499/O5FHqXKwdM9aRZR4xGbCEgYv5/51LEsoZXz/hyvG4ElcwJKAaDBQMywEEszVgwSfMuBNSBXU8EByzkFyLj4xzKB6eKT/K9vLHvCQGZygbQEYxUZQMaIsgUYIcjKEDG9//////////z///////9f8DeHCgF9IsmpTbP//360oe211RwGAAAAAAAQAAAAABZwaMDYiyMjHUwWfkTAsbgcWjSxMAg7MtG8w6jTCqcPLoM8xkjDQoNMpU8s+jrCzOd4AAh1EoDJEyxRTOwPMyxk0bjDaHLAQlDlaZmLZlVEGP0EYaNhzqhHRVmYvXZmcPGOmuY3CQEBI8Rzk5hGDUYfMBkwZmABuIBWayNxn4AGcI6FQYPA8hEBYEQgAAKL4GB4MJhicDP+ZchwGLhiAvmmSCYECIIDRgUhCwvaoj2qVCgwaZAUg0mR4WDgwFAGZMLBg08LnNKL41WagMZjDp1MBgqPBQChggMBCtqyDy+jHIWC4iMskYQg4MCQCGoBEAcbX2MoFU0sGDYI4MzjIwetDE6rZGXeFQkkUhzKgDLNmBAIy5kRgIArUhkhEZjQig0ElAWM//vgZJiADOlfUe5zhBD6yvpvzeQQMQWfM13eACuTM6a3taAFKhw08LTKsfNFlo1QFDrbvOqGUytNT7TtNTRI+sY1RCICJXmDAWMAVyQqJCQEoDDG4uC4CV8ABaNHUOBBgMDjgjHBKIxSYWGBjk/GHg7KRYKP33//////f+wXX////////rEdXOPB///////3FEkDABgAoAIAAAAAMAgD/M8SsMjyjdcUCpRkoY1hJMZDTEwsxcCGj9D9TIwQuMhJQ5IEQizpkCTw9aTCRIvGFMR/J4BVYR5s/Xs5QsgVTR1gRmhbIlObk/bKoZs/A9lX9l/3aioNOMQUt7/45dtPiwdn6xWDydI1DU0iYABA+OpIzKktSabdprjTVzNjVYsGAEgMMDFCIhKjBgCEbCEdYws5ucXdOBFktyiJbAHBpiEgLoshFgVYgEEocZ5UqlEZuUUE16WGSARgCO6eLtMBYq7MFvb40m1hXaKBMGX+FCQ62DEobW9KoPnaq5VqbXcv////////+Q+sghyEAAAAAADmEgjGAASGLoHmEorAUVnTMEQVMERGAQbmGYfGJ4cGHohGVYzHGJUmqQPkQ8mX6NGco5mvRIYNAwCMhh8EGFQMMAFAiHCkGnABHwMDxhUJGZyIIz4dLORicnhA+GooVhMwoER4NmBwAYKGZiIJpkBwIMMg8oERe8w8ATCoMJAAsgKgcw8D0+RgNGHQgFh2GGEsAcAABYIZBQqRggWDoEBwaMJAdp6iwUAhhkPGGwckcjmFAKVQwYVBiwyX5g0FBUDmAQAYVCQVCxEP0JgVC5igKmAxIYxEij6I5gYiKKuUuowiLjEYcTpGAoMDcOEqh4hAoWCiFsu7i2BaMOGDAynIhGYTBZjAVhgiBIJMQiJs4wIzFQKUEd0wQBBUFGGwMqoSBkwuFjAQbEIGJA0YPF4JABjYWmIAaXwMDhoxOMDFAjKAUIAmTBILAExMSzIAXMcBcFAldBggPmFwkkAFRQEFJK51r9XH///////1//+//Hf6y/fcvx1/e5Z2sN/nruqvaCFAAAABQAAebU6wF+WimjImKAGOGhy1RZYrMkBQ0qA41WF3U0Qh4aYSXxYm0wFAljpIJNplGlPLGKgYaEa+snugDTMw1l////////+P/+opP7ghyWgfqaQ5I50jSkUn8YfAvP0rImY977FAYFCUrE7W7RJP4woZFAEhF1Q92UuSYISYADSQW87tGFAK9EYUOIhYqgeuYtuHDZmG3cAIQxZQWEL3pNZIuhw/HHL5mW2VZlzGHRHR7HLBF5nKtbx3jj3eOP//////////////////////853D+8/f/z7tjuefN36n31lFYgAAAAAADnfiyHMibwEEmRGAAEDIxIws6IiI//vgZA4AB4Bmzmt4VeqYyMnNaXrHGhmbOe2xvKoaomc9xdJ8DAwQcq4MQOzJE4xwTZ8YGIgYbAREpq3BoUUc5XKPIXAEzIKbuHICfw9tJmtPKDtuajUqeaaa9L1XSFoavc4061K4bHHllmc47NLFFoMSEZAfFxYZaxA77OVd9es/TLRhFmkiTdbtIrpjbWYwp93ItArURGpK63LXdnYGa81p/0bU6XZaFNPxegpJJTtzZanMzllqCJt2ut3glkFPQQS5SZdhPVnKlLYVeshQtlUighvZYsNB7+kxoAULkAQQA3ANCFH4LQNSp///+ZZ/U9+ypMqpahoh9AAAC4AADk6poVNAJgCZVEGkIAQA7DX5zKSQJCJXAbDpZPCADIKsZiLsyBwXlp3paf+1GwYCeWcVPfrQ68/P+Ym//8BZfIgE46/zZdM+mkib/JeKRmqSSaoeRYSgQh2nY/g2db6GUV513rsM400ulMMTz+z1pwpmBeczmmTZ//d/x6FJLlCsUoTLVxpfO///+mm88AUQ8FzFpVgMhANpEAc7sBMwNS0BihaHEBoYyNNICbFSmWEgAYTEBMRA5mAWJBAhBQQCuSjWjAorD0Fr1kc+3FnUj2CRAgBVVsGdgopWqLBOERdh10qom6sRiHZmFTjgx1ob+139nXhfl9ngZGW9po06SYbtFw8UhiKQ1FRrVo+x9SlJpU4ttEYwEZAJZLRcfF8rFpk9Hq9DbPPWa2UnJ9yokB7Fo1F8xGUOwgsMGiPUlCELwJknHTcu/UkFmJiICMhxgSsbf///rUu+p+v0EzKtKszepgWVkDEgAQSAHOJnoWEellCACmAhGOBACAe6DAiPBwKgJ23ZX6DQIsLI68qqTdn94thxUHkbqA+UgqQyZOvIJf+Dj5d//NO3Tf+IxeKhqcCeacoCWEK/800yEX/43TKi79A+SYn0mtTa1FlokaTD/OF5Q5YCHoXIKIl///UroY4iHhxgwpiUKg3Y0WwMiEAeG7kAppCpvTBiRpiiZjQZkyq6TUqgNebIAEiAZrsoEABvC/SrFGJeoLI5C5sHYzMjYChiGMWCvQFQkCl9ncdBQ0SHuTSX7tqAr7/O87Urm+1LPynGKzbZVfT9jIUS5FOAJAsVFMFd/j1zYygAIXPMAO1KvsXO02gHDSq0Y//ilg/RKTS1FE0l1JykdqSF2CUPA+zMqfqTDbCKl8uskjf///1a+zpLrrWtnQZVAxM0zybAISzAkKiUiiAO0yROywx2mRExl9BlVYjUiMzlPU3TZ1Ka1TRCSz2P6QDRewdxdLiSDPO7+HoklvBw0/o+hLr3vvcSjaTKjio7SwkrG8c281fJO/m/bLX2rcdy77cl3X1o/qdZRCyEC8k8Bv//9NIys6Jx//vAZJWABcVnzetJhyp36JnPYXKfFCUtO6yxuSHOIid9hMp8Vp8MnXDxJ/1ZQdbIg+R7LlO9EO5buVUjLZDADNwEIhiBBYgGsKXPeXkQWQCF/miKxUTQXJrSrKpzgyJDiVsvdVQ2VOWqJuDA0+Ifhu4PY4onioyQyuglQaLW+oFD84HKx6nHh/6kZaPomjpYaCsqYX7KGsHsvDqtLfXtMB5NPRyocmOD17HTLmnrll7IHv/cqCTDcSH+svgr4wo6f//M3ojRiqgINPgjGbUaKANsaA60c3QQPViTQgWHZ3y40YFBO8/OFvP+/uGYPil7/puP/+n9D//+ky12Wi49JfeVZYiwI4ME5AohNoIroTRm857LdBTqwF5BV2+3ecpvcnD1DYwWVVhqUZ7//UWAaQHNPHv//91FNCxzCVgO1QlpZjNTMptIhYbHwyYNQbxMFBwNfGYJmYKIKGKEgogXnBIEeAVWxNHUsb17mAvLPv1UZ9Obl0UdZrjN4fponXjD/H0TsBwsOnMJjyHZi3uwEw4ZZYcSPHa2qtp2hDSnjlm0lI6x0XKl9oUUlPVr2sLetNz3Xb4z/McmmGyRDQdF1p/ss8DdIaZfMG6eomRam//9WRInTjhp8iSGLBUp3QlMA5EiJwWPfkcPGWAK2CMoZM4asYm8YQOULCUSiupB/6Ruq/HNfNpMHNXadQNa7bUIYMBe/50vVKVC9AWoRxEyi9ETzNabkq5VR0ZcWrBYtdQ5afcPHrnJZvZpc+0v6Hlf/J6+XUX2vE7L+J3IazML1N/JyjF0HQan/QUEFk8XUG+tQ5IfkiGf/+wLwKIB4TAIWwHAoLVu6qjjbI7I+Dx8TBz14AgubdUTXQCCBwkt8RBDAgxgKj826xl2vI011I79KruUuzV7liwxi7xWlPN+1s5CTGydy4pMHCUgPHputLszhs8cvNry0rlxOast5b0brs775bLCeNxg5hT/+8BEzgAE3kpNe0yF2JipWb9pkp8U+ZU57TIXamwlZv2kwyQ7IzM5WkyFbpuPGp2FSpcuZeOrWXY+LoPLyLEgsynC6fXyYE9gjiIlakak2YEluJRb////9N7alOrdr9VZlIGzAzw0IyqFsahK4nHh8iqKXhxMyYwygIcJkxALghogY8WQgV/svRuRpY6mqtSCfm3DpKCr3LFlECwM39Or9t4JZXTV36h+taMTeGlFgUkjgTE3aJ2es0XRwXPEREcaLbGSjM5GEC74jC7QxIkR4jmWV/pHrM1YxvGJxlcJfpNP1VIv1OCBEMNneyCB/cUC3/+vQ1ooKh0sYvBQEAwqBXhqNIUc5DGXxu895esINDw0yB0SeGdBooBcKYoUNAmWFwHnwSbZqXzlaXzKHYlXYtu7nguba/GLqlYa5BhNUuJqRyaA4LIk5+cofzFTKJ5VAfHptt+DWoXJT9pJpomGwDJkRpIhJCqMtUNyBKgjNHCTCBCchxdREQqoZishDQimdAknNMJSQs6IpGBES1H////6Oi3ppdbGmKyT0KEcwoVVUJhnhTZRkcLbeG4UuMyeBRowokEIRIAsOx4x5FVAHC01DECmrxJOJ/VhnOblWch0ojK8a+eC5lur9gd9VewIDUcExgFbdauxRPqTFY/ajIkoipRaekdcqYbXV92uKcVXfrBK66y8a15S222hwco6106Q+2kcVqNBU49R5s8QT9axNmR82HNnCHOhy8KABHSeUcKpOFgwKZIMZifjWsn/////X32VpU0V+pBS11H1gTQzGisTUZRJx2RTWyYux4LizEHS1gXep6AA2DnC43zEjj8QOrtHGH2Kuu3Jy7stcukl8WxfxilmvOM8lKxtoPWtA+IROIA8SBofGyFDc15MKIAsheVxmHfc8SXXnSpXaatSl15pGDMCycZnzOaQYksxM98Ns6xJ175KzWN/l4ot9HQfIyFCttskR//7wETtgAUUZ837SVXara0Zr2mRuxSllzHtJPeqsrQnPaTG7EZMHQlHy6jk9////XQylVMMXzmORjjyLoupQdpall3PS1yScPDwCdcKvNnwwDAxMRH1NgoJMIIT5coWOxiAC5zXX6UjXZQ7bsutAueVqo4A8Mnadriq0RsSmxUUslIS4MrGWkR8uNkgLk8u6a7SrzeRUNtIGm6fHYK6jQHk5dROcWnSQJsQbxYKEwlZaedvFkOISdeaRImVC+fKJvrJYniLutMIMHuokBLxsXSKk6idPlEbx5zptMG////+7LUp31Lsl2pUjBd/6duUZFAAGHxsHYnJMX2YUaBpiRBCoRAW7AxxlClQlIlleSeq9Q+QZQzHIGXGOGZHScWWzAMmCWFh4rQLXA2cLLSJj6JAiR4b5qQBIg5OmJIk0xqTxeNCobDmlgpGRWOnyaKCSCBrOmRUOpFZaKVMzTKpdKaCRNKOmpyamhPEVcc8kjxqszNHMGPnJuU1ol5MmVmpmZJrKZSNHUo4REcBgTpXLzqMSucRci6bKNS4Yf///UrXQp2WmqtSqkWdM6k6zqhN///1M/TZ3RQFmJxlZz+kbbXHyxcMal3cAdpaWCCYG2JDlA4HAEGUwVU4EaKlY0ZWhpkhp4IcaHqtqmpBkQd1OtgE4iumLPv3FpZDjvSClpJy9OV5HfpIE+frZ36axP3rvYBpr8en4amqPPO7GbO8dTNqzlN1o3ayprN2l1R1KN3JrG52kl1DS2JD/bFLyilHcLWdLHJHT1sNVLkvi374OiuW5+XUuFSjns/tz929vuExO///////////////v//8ub/uG95f+tdx3fr4XMe6udBgSYSGV1ZXRkJba4nRKGwCDCwtTsMZCgxaGzTM+OTlYyKFjDonMEgswqGTTENMbH0y+LCYdmQgKigZOC4NBxiDhwZcIta0lwALebUZoiiIIvYDgjLcCpQCeFRw//vgRPgABmBnyu1mAAjJjPmvrWABZqI3JfnMgE8aSCY/P9IQMCo8u9j0RbLLEGXaUNMANYzZi8aEarCgseZZivxg4WBU0LlNKhULVjfJS90LrLZbDKirjVdVrURq2ZK2zuO5NOkzyNJfS9zG6OGtjHfK2WWTL17xZnk3IpO0l221ZMtFcz9OVD0DMlyzx/8d41smguFcfiVS6Hvo/ZlBdZ2YJk0ilmUqvapt5bpceZfr////////X5Z8z7n3DuHOf3meWu1d483ytrL9b5/6//3l/d//Ofv+fl3n2sMP7rDXN/v9713D/13997c/Xfx3jr9Za7v9475l+Xddq4ogGniTd0ZjWFVjdbJk6FQKDCRwF0qgBRgYoDEYBgAJGUnJGZnDAMKGAOZgKgC8YC0AMmBlANhjWI9sYKaGGGAKgBgjAGTAHgFEwGMAfMIxBsjARQR8wmAgCgEYNAuYSg2YlkQYQkis1uA0DT/A4MzAEGDciITIJRTYhBw4CjAECGLPQYFAQIQICAMQXMNTSMDgJMPSKMlyEkSpK7EJOHAQOgOgPKgAq1mFo8GPoUGKBUjIBmIQyiQBgYAmKJQmBABJrq8JgDQwRoR4ZqYVA2YEBWJCSYUigIwKMIwkd9tXGSUbay8IYAaUJZdu6RaxkwFCguACV5gMCqhpgEALTH6dld7107wyKAX2Wspo01HhpbX2WqXyRpLkFqmRJ1Pi7T1pC0jmwUnFbfCBZFqB+rvfRxExkrF3rgZGzt03nbiumDHBYUkUyJmyVN1hv//////P/ufuQ1NlDqOBArX3NZ3F2dw00x+muNdaS+SVUeXdInSh9L2AWIxCGYhvXPw3rn443OXOb+rfzwt4WsdV+csbt456t3LGsM7FfO7nYv4YYcr2c+qBOky56ZVBKwrotNZFi6TOnSeZaN1rL8vrByt00zqTvtG1MRAABFBfChQABCCvBfiqTEFNRTMuMTAwqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq//tQZKeP8DAAQS8AAA4HYAgl4AABQAABpAAAACAAADSAAAAEqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqg==" }, function (e, t, n) { "use strict"; n.r(t), t.default = "data:audio/mpeg;base64,SUQzAwAAAABKGlRZRVIAAAAGAAAAMjAxNABUREFUAAAABgAAADE0MDMAVElNRQAAAAYAAAAyMTQ1AFBSSVYAABzgAABYTVAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4KPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS41LWMwMjEgNzkuMTU1MjQxLCAyMDEzLzExLzI1LTIxOjEwOjQwICAgICAgICAiPgogPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4KICA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIgogICAgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iCiAgICB4bWxuczpzdEV2dD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL3NUeXBlL1Jlc291cmNlRXZlbnQjIgogICAgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiCiAgICB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iCiAgICB4bWxuczp4bXBETT0iaHR0cDovL25zLmFkb2JlLmNvbS94bXAvMS4wL0R5bmFtaWNNZWRpYS8iCiAgICB4bWxuczpkYz0iaHR0cDovL3B1cmwub3JnL2RjL2VsZW1lbnRzLzEuMS8iCiAgICB4bWxuczpiZXh0PSJodHRwOi8vbnMuYWRvYmUuY29tL2J3Zi9iZXh0LzEuMC8iCiAgIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6MjdkZjI4OWItY2VhZi00OWIyLTkxMDYtODhhNjYyNTU4YzVjIgogICB4bXBNTTpEb2N1bWVudElEPSI4NzViZTRlNy01ZmRkLWY0NmQtMWZiNS0wNDIxMDAwMDAwNDkiCiAgIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDo5MzE4Yzc0MS0zYzYwLTQ5YjktYTRkMi02ODU4MWQ2MjBhYzYiCiAgIHhtcDpNZXRhZGF0YURhdGU9IjIwMTQtMDMtMTRUMjE6NDU6NTgtMDQ6MDAiCiAgIHhtcDpNb2RpZnlEYXRlPSIyMDE0LTAzLTE0VDIxOjQ1OjU4LTA0OjAwIgogICB4bXA6Q3JlYXRlRGF0ZT0iMjAxNC0wMy0xNFQyMTo0NToyOC0wNDowMCIKICAgeG1wRE06YXVkaW9TYW1wbGVSYXRlPSI0NDEwMCIKICAgeG1wRE06YXVkaW9TYW1wbGVUeXBlPSIxNkludCIKICAgeG1wRE06YXVkaW9DaGFubmVsVHlwZT0iU3RlcmVvIgogICB4bXBETTpzdGFydFRpbWVTY2FsZT0iMzAwMDAiCiAgIHhtcERNOnN0YXJ0VGltZVNhbXBsZVNpemU9IjEwMDEiCiAgIHhtcERNOnBhcnRPZkNvbXBpbGF0aW9uPSJmYWxzZSIKICAgZGM6Zm9ybWF0PSJNUDMiCiAgIGJleHQ6ZGVzY3JpcHRpb249IkZPTEVZIFNMSU1FIFNQTEFUIDAxIgogICBiZXh0Om9yaWdpbmF0b3I9IkFkb2JlIFN5c3RlbXMgSW5jIgogICBiZXh0Om9yaWdpbmF0aW9uRGF0ZT0iMjAxNC0wMy0wNSIKICAgYmV4dDpvcmlnaW5hdGlvblRpbWU9IjE3OjU4OjQ3IgogICBiZXh0OnRpbWVSZWZlcmVuY2U9IjAiCiAgIGJleHQ6dmVyc2lvbj0iMSI+CiAgIDx4bXBNTTpIaXN0b3J5PgogICAgPHJkZjpTZXE+CiAgICAgPHJkZjpsaQogICAgICBzdEV2dDphY3Rpb249InNhdmVkIgogICAgICBzdEV2dDppbnN0YW5jZUlEPSJkN2JiZWMwMC05MmVmLWQ2NDMtM2ExMC01ZWQ4MDAwMDAwNzYiCiAgICAgIHN0RXZ0OndoZW49IjIwMTQtMDMtMTRUMjE6NDU6NTgtMDQ6MDAiCiAgICAgIHN0RXZ0OnNvZnR3YXJlQWdlbnQ9IkFkb2JlIEFkb2JlIE1lZGlhIEVuY29kZXIgQ0MgKE1hY2ludG9zaCkiCiAgICAgIHN0RXZ0OmNoYW5nZWQ9Ii8iLz4KICAgICA8cmRmOmxpCiAgICAgIHN0RXZ0OmFjdGlvbj0ic2F2ZWQiCiAgICAgIHN0RXZ0Omluc3RhbmNlSUQ9Ijc4NmYwYjIxLTUwZWYtNGIwMS03M2FlLWEyZTgwMDAwMDA3NiIKICAgICAgc3RFdnQ6d2hlbj0iMjAxNC0wMy0xMlQxMTo1NzowOS0wNDowMCIKICAgICAgc3RFdnQ6c29mdHdhcmVBZ2VudD0iQWRvYmUgQWRvYmUgTWVkaWEgRW5jb2RlciBDQyAoTWFjaW50b3NoKSIKICAgICAgc3RFdnQ6Y2hhbmdlZD0iLyIvPgogICAgIDxyZGY6bGkKICAgICAgc3RFdnQ6YWN0aW9uPSJzYXZlZCIKICAgICAgc3RFdnQ6aW5zdGFuY2VJRD0iYzYzM2ZiMWEtM2I0NC02N2NiLTRiODEtZDVjMzAwMDAwMDc2IgogICAgICBzdEV2dDp3aGVuPSIyMDE0LTAzLTA1VDE3OjU4OjQ3LTA1OjAwIgogICAgICBzdEV2dDpzb2Z0d2FyZUFnZW50PSJBZG9iZSBBZG9iZSBNZWRpYSBFbmNvZGVyIENDIChNYWNpbnRvc2gpIgogICAgICBzdEV2dDpjaGFuZ2VkPSIvIi8+CiAgICAgPHJkZjpsaQogICAgICBzdEV2dDphY3Rpb249InNhdmVkIgogICAgICBzdEV2dDppbnN0YW5jZUlEPSJ4bXAuaWlkOkVCMDVBM0JFMDcyMDY4MTE4REJCRTZEMUVGMEJGOTkwIgogICAgICBzdEV2dDp3aGVuPSIyMDEzLTA0LTI5VDE3OjQzOjIwLTA0OjAwIgogICAgICBzdEV2dDpzb2Z0d2FyZUFnZW50PSJBZG9iZSBBZG9iZSBNZWRpYSBFbmNvZGVyIDUuNS4wIgogICAgICBzdEV2dDpjaGFuZ2VkPSIvbWV0YWRhdGE7L2NvbnRlbnQiLz4KICAgICA8cmRmOmxpCiAgICAgIHN0RXZ0OmFjdGlvbj0ic2F2ZWQiCiAgICAgIHN0RXZ0Omluc3RhbmNlSUQ9InhtcC5paWQ6Q0VGRTk1QzQwNzIwNjgxMThEQkJFNkQxRUYwQkY5OTAiCiAgICAgIHN0RXZ0OndoZW49IjIwMTMtMDQtMjlUMTc6NDM6MzAtMDQ6MDAiCiAgICAgIHN0RXZ0OnNvZnR3YXJlQWdlbnQ9IkFkb2JlIEFkb2JlIE1lZGlhIEVuY29kZXIgNS41LjAiCiAgICAgIHN0RXZ0OmNoYW5nZWQ9Ii9tZXRhZGF0YSIvPgogICAgIDxyZGY6bGkKICAgICAgc3RFdnQ6YWN0aW9uPSJzYXZlZCIKICAgICAgc3RFdnQ6aW5zdGFuY2VJRD0ieG1wLmlpZDowQTgyNERCMTBDMjA2ODExOEE2REM2N0NFOEJCQzE0RiIKICAgICAgc3RFdnQ6d2hlbj0iMjAxMy0wNC0yOVQxOTozMzowMi0wNDowMCIKICAgICAgc3RFdnQ6c29mdHdhcmVBZ2VudD0iQWRvYmUgQWRvYmUgTWVkaWEgRW5jb2RlciA1LjUuMSIvPgogICAgIDxyZGY6bGkKICAgICAgc3RFdnQ6YWN0aW9uPSJtb2RpZmllZCIKICAgICAgc3RFdnQ6cGFyYW1ldGVycz0idW5rbm93biBtb2RpZmljYXRpb25zIi8+CiAgICAgPHJkZjpsaQogICAgICBzdEV2dDphY3Rpb249InNhdmVkIgogICAgICBzdEV2dDppbnN0YW5jZUlEPSJjZDRkNDNmNS04YWQ3LTQzNDYtYzllYy0wYmQwMDAwMDAwNzYiCiAgICAgIHN0RXZ0OndoZW49IjIwMTQtMDMtMDVUMTc6MTE6MTktMDU6MDAiCiAgICAgIHN0RXZ0OnNvZnR3YXJlQWdlbnQ9IkFkb2JlIEFkb2JlIE1lZGlhIEVuY29kZXIgQ0MgKE1hY2ludG9zaCkiCiAgICAgIHN0RXZ0OmNoYW5nZWQ9Ii8iLz4KICAgICA8cmRmOmxpCiAgICAgIHN0RXZ0OmFjdGlvbj0ic2F2ZWQiCiAgICAgIHN0RXZ0Omluc3RhbmNlSUQ9InhtcC5paWQ6OTIxZjhkZTAtY2UxNy00MjczLThiNDQtMDJmZmI2MzA2ZDAyIgogICAgICBzdEV2dDp3aGVuPSIyMDE0LTAzLTA1VDE3OjU4OjQ3LTA1OjAwIgogICAgICBzdEV2dDpzb2Z0d2FyZUFnZW50PSJBZG9iZSBBZG9iZSBNZWRpYSBFbmNvZGVyIENDIChNYWNpbnRvc2gpIgogICAgICBzdEV2dDpjaGFuZ2VkPSIvIi8+CiAgICAgPHJkZjpsaQogICAgICBzdEV2dDphY3Rpb249InNhdmVkIgogICAgICBzdEV2dDppbnN0YW5jZUlEPSJ4bXAuaWlkOmRmOWIwZTFiLWY1YWQtNGY4Yi04YTFhLTEyMWNkNmJlY2QzMiIKICAgICAgc3RFdnQ6d2hlbj0iMjAxNC0wMy0wNVQxNzo1ODo0Ny0wNTowMCIKICAgICAgc3RFdnQ6c29mdHdhcmVBZ2VudD0iQWRvYmUgQWRvYmUgTWVkaWEgRW5jb2RlciBDQyAoTWFjaW50b3NoKSIKICAgICAgc3RFdnQ6Y2hhbmdlZD0iL21ldGFkYXRhIi8+CiAgICAgPHJkZjpsaQogICAgICBzdEV2dDphY3Rpb249InNhdmVkIgogICAgICBzdEV2dDppbnN0YW5jZUlEPSJ4bXAuaWlkOjUxYjg4NzBiLWNjY2QtNGRmZi05M2JjLWJkMTI2MTE4ZmJkZiIKICAgICAgc3RFdnQ6d2hlbj0iMjAxNC0wMy0xMlQxMTo1NzowOS0wNDowMCIKICAgICAgc3RFdnQ6c29mdHdhcmVBZ2VudD0iQWRvYmUgQWRvYmUgTWVkaWEgRW5jb2RlciBDQyAoTWFjaW50b3NoKSIKICAgICAgc3RFdnQ6Y2hhbmdlZD0iLyIvPgogICAgIDxyZGY6bGkKICAgICAgc3RFdnQ6YWN0aW9uPSJzYXZlZCIKICAgICAgc3RFdnQ6aW5zdGFuY2VJRD0ieG1wLmlpZDo3MGJkMTJkZi02MTRjLTQ2MGMtOTlmMi01Yzc5ZWUxODRlODIiCiAgICAgIHN0RXZ0OndoZW49IjIwMTQtMDMtMTJUMTE6NTc6MDktMDQ6MDAiCiAgICAgIHN0RXZ0OnNvZnR3YXJlQWdlbnQ9IkFkb2JlIEFkb2JlIE1lZGlhIEVuY29kZXIgQ0MgKE1hY2ludG9zaCkiCiAgICAgIHN0RXZ0OmNoYW5nZWQ9Ii9tZXRhZGF0YSIvPgogICAgIDxyZGY6bGkKICAgICAgc3RFdnQ6YWN0aW9uPSJzYXZlZCIKICAgICAgc3RFdnQ6aW5zdGFuY2VJRD0ieG1wLmlpZDpjN2EzNTliYy1jMDY5LTRhMzgtOWY2ZC1kYzlkYTBkNWM0YzgiCiAgICAgIHN0RXZ0OndoZW49IjIwMTQtMDMtMTRUMjE6NDU6NTgtMDQ6MDAiCiAgICAgIHN0RXZ0OnNvZnR3YXJlQWdlbnQ9IkFkb2JlIEFkb2JlIE1lZGlhIEVuY29kZXIgQ0MgKE1hY2ludG9zaCkiCiAgICAgIHN0RXZ0OmNoYW5nZWQ9Ii8iLz4KICAgICA8cmRmOmxpCiAgICAgIHN0RXZ0OmFjdGlvbj0ic2F2ZWQiCiAgICAgIHN0RXZ0Omluc3RhbmNlSUQ9InhtcC5paWQ6MjdkZjI4OWItY2VhZi00OWIyLTkxMDYtODhhNjYyNTU4YzVjIgogICAgICBzdEV2dDp3aGVuPSIyMDE0LTAzLTE0VDIxOjQ1OjU4LTA0OjAwIgogICAgICBzdEV2dDpzb2Z0d2FyZUFnZW50PSJBZG9iZSBBZG9iZSBNZWRpYSBFbmNvZGVyIENDIChNYWNpbnRvc2gpIgogICAgICBzdEV2dDpjaGFuZ2VkPSIvbWV0YWRhdGEiLz4KICAgIDwvcmRmOlNlcT4KICAgPC94bXBNTTpIaXN0b3J5PgogICA8eG1wTU06RGVyaXZlZEZyb20KICAgIHN0UmVmOmluc3RhbmNlSUQ9InhtcC5paWQ6NzBiZDEyZGYtNjE0Yy00NjBjLTk5ZjItNWM3OWVlMTg0ZTgyIgogICAgc3RSZWY6ZG9jdW1lbnRJRD0iYmQ0N2FhOWMtMGNiZS05YWJmLTNjNTktNGVkYjAwMDAwMDQ5IgogICAgc3RSZWY6b3JpZ2luYWxEb2N1bWVudElEPSJ4bXAuZGlkOjA3YjE3YzU5LTA3N2UtNDIyNS1hMzMzLTg4NzNkMGRhMTNlNyIvPgogICA8eG1wRE06c3RhcnRUaW1lY29kZQogICAgeG1wRE06dGltZUZvcm1hdD0iMjk5N0Ryb3BUaW1lY29kZSIKICAgIHhtcERNOnRpbWVWYWx1ZT0iMDA7MDA7MDA7MDAiLz4KICAgPHhtcERNOmFsdFRpbWVjb2RlCiAgICB4bXBETTp0aW1lVmFsdWU9IjAwOzAwOzAwOzAwIgogICAgeG1wRE06dGltZUZvcm1hdD0iMjk5N0Ryb3BUaW1lY29kZSIvPgogICA8eG1wRE06ZHVyYXRpb24KICAgIHhtcERNOnZhbHVlPSI1IgogICAgeG1wRE06c2NhbGU9IjEwMDEvMzAwMDAiLz4KICA8L3JkZjpEZXNjcmlwdGlvbj4KIDwvcmRmOlJERj4KPC94OnhtcG1ldGE+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAKPD94cGFja2V0IGVuZD0idyI/PgBUSVQyAAAAGwAAAf/+RgBGAF8AMgBGAFgAMAA0ADUANQA4AAAAVEJQTQAAAA8AAAH//jkAMgAuADYAMQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA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+3BgowAD10vISelLYgAACXAAAAEQHNcnphnrSAAAJcAAAASUpQV0mocQRosxMWRClyczM2zTS4g/OYuLVr8a+vvdfn/W/W3zjMX3rXHzCGkxVpbN4IkgAABoJh2iXMMkQP////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////twYK+AA99Ex+sGeuIAAAlwAAABAWwNGIYYQCAAACXAAAAE///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////7cED2AAgQAEuAAAAIAAAJcAAAAQAAAS4AAAAgAAAlwAAABP//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////+3BA/4AIqABLgAAACAAACXAAAAEAAAEuAAAAIAAAJcAAAAT/////////////////////////////////////////////////////////AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//twQP+ACKgAS4AAAAgAAAlwAAABAAABLgAAACAAACXAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFRBRwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADIwMTQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" }, function (e, t, n) { }, function (e, t, n) { "use strict"; n.r(t); const i = 0, r = 1, s = 2, o = 0, a = 1, l = 2, c = 3; class A { addEventListener(e, t) { void 0 === this._listeners && (this._listeners = {}); const n = this._listeners; void 0 === n[e] && (n[e] = []), -1 === n[e].indexOf(t) && n[e].push(t) } hasEventListener(e, t) { if (void 0 === this._listeners) return !1; const n = this._listeners; return void 0 !== n[e] && -1 !== n[e].indexOf(t) } removeEventListener(e, t) { if (void 0 === this._listeners) return; const n = this._listeners[e]; if (void 0 !== n) { const e = n.indexOf(t); -1 !== e && n.splice(e, 1) } } dispatchEvent(e) { if (void 0 === this._listeners) return; const t = this._listeners[e.type]; if (void 0 !== t) { e.target = this; const n = t.slice(0); for (let t = 0, i = n.length; t < i; t++)n[t].call(this, e); e.target = null } } } const u = []; for (let e = 0; e < 256; e++)u[e] = (e < 16 ? "0" : "") + e.toString(16); let h = 1234567; const d = Math.PI / 180, p = 180 / Math.PI; function f() { const e = 4294967295 * Math.random() | 0, t = 4294967295 * Math.random() | 0, n = 4294967295 * Math.random() | 0, i = 4294967295 * Math.random() | 0; return (u[255 & e] + u[e >> 8 & 255] + u[e >> 16 & 255] + u[e >> 24 & 255] + "-" + u[255 & t] + u[t >> 8 & 255] + "-" + u[t >> 16 & 15 | 64] + u[t >> 24 & 255] + "-" + u[63 & n | 128] + u[n >> 8 & 255] + "-" + u[n >> 16 & 255] + u[n >> 24 & 255] + u[255 & i] + u[i >> 8 & 255] + u[i >> 16 & 255] + u[i >> 24 & 255]).toUpperCase() } function g(e, t, n) { return Math.max(t, Math.min(n, e)) } function m(e, t) { return (e % t + t) % t } function v(e, t, n) { return (1 - n) * e + n * t } function y(e) { return 0 == (e & e - 1) && 0 !== e } function w(e) { return Math.pow(2, Math.ceil(Math.log(e) / Math.LN2)) } function x(e) { return Math.pow(2, Math.floor(Math.log(e) / Math.LN2)) } var C = Object.freeze({ __proto__: null, DEG2RAD: d, RAD2DEG: p, generateUUID: f, clamp: g, euclideanModulo: m, mapLinear: function (e, t, n, i, r) { return i + (e - t) * (r - i) / (n - t) }, inverseLerp: function (e, t, n) { return e !== t ? (n - e) / (t - e) : 0 }, lerp: v, damp: function (e, t, n, i) { return v(e, t, 1 - Math.exp(-n * i)) }, pingpong: function (e, t = 1) { return t - Math.abs(m(e, 2 * t) - t) }, smoothstep: function (e, t, n) { return e <= t ? 0 : e >= n ? 1 : (e = (e - t) / (n - t)) * e * (3 - 2 * e) }, smootherstep: function (e, t, n) { return e <= t ? 0 : e >= n ? 1 : (e = (e - t) / (n - t)) * e * e * (e * (6 * e - 15) + 10) }, randInt: function (e, t) { return e + Math.floor(Math.random() * (t - e + 1)) }, randFloat: function (e, t) { return e + Math.random() * (t - e) }, randFloatSpread: function (e) { return e * (.5 - Math.random()) }, seededRandom: function (e) { return void 0 !== e && (h = e % 2147483647), h = 16807 * h % 2147483647, (h - 1) / 2147483646 }, degToRad: function (e) { return e * d }, radToDeg: function (e) { return e * p }, isPowerOfTwo: y, ceilPowerOfTwo: w, floorPowerOfTwo: x, setQuaternionFromProperEuler: function (e, t, n, i, r) { const s = Math.cos, o = Math.sin, a = s(n / 2), l = o(n / 2), c = s((t + i) / 2), A = o((t + i) / 2), u = s((t - i) / 2), h = o((t - i) / 2), d = s((i - t) / 2), p = o((i - t) / 2); switch (r) { case "XYX": e.set(a * A, l * u, l * h, a * c); break; case "YZY": e.set(l * h, a * A, l * u, a * c); break; case "ZXZ": e.set(l * u, l * h, a * A, a * c); break; case "XZX": e.set(a * A, l * p, l * d, a * c); break; case "YXY": e.set(l * d, a * A, l * p, a * c); break; case "ZYZ": e.set(l * p, l * d, a * A, a * c); break; default: console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + r) } } }); class b { constructor(e = 0, t = 0) { this.x = e, this.y = t } get width() { return this.x } set width(e) { this.x = e } get height() { return this.y } set height(e) { this.y = e } set(e, t) { return this.x = e, this.y = t, this } setScalar(e) { return this.x = e, this.y = e, this } setX(e) { return this.x = e, this } setY(e) { return this.y = e, this } setComponent(e, t) { switch (e) { case 0: this.x = t; break; case 1: this.y = t; break; default: throw new Error("index is out of range: " + e) }return this } getComponent(e) { switch (e) { case 0: return this.x; case 1: return this.y; default: throw new Error("index is out of range: " + e) } } clone() { return new this.constructor(this.x, this.y) } copy(e) { return this.x = e.x, this.y = e.y, this } add(e, t) { return void 0 !== t ? (console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(e, t)) : (this.x += e.x, this.y += e.y, this) } addScalar(e) { return this.x += e, this.y += e, this } addVectors(e, t) { return this.x = e.x + t.x, this.y = e.y + t.y, this } addScaledVector(e, t) { return this.x += e.x * t, this.y += e.y * t, this } sub(e, t) { return void 0 !== t ? (console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(e, t)) : (this.x -= e.x, this.y -= e.y, this) } subScalar(e) { return this.x -= e, this.y -= e, this } subVectors(e, t) { return this.x = e.x - t.x, this.y = e.y - t.y, this } multiply(e) { return this.x *= e.x, this.y *= e.y, this } multiplyScalar(e) { return this.x *= e, this.y *= e, this } divide(e) { return this.x /= e.x, this.y /= e.y, this } divideScalar(e) { return this.multiplyScalar(1 / e) } applyMatrix3(e) { const t = this.x, n = this.y, i = e.elements; return this.x = i[0] * t + i[3] * n + i[6], this.y = i[1] * t + i[4] * n + i[7], this } min(e) { return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this } max(e) { return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this } clamp(e, t) { return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this } clampScalar(e, t) { return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this } clampLength(e, t) { const n = this.length(); return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n))) } floor() { return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this } ceil() { return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this } round() { return this.x = Math.round(this.x), this.y = Math.round(this.y), this } roundToZero() { return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this } negate() { return this.x = -this.x, this.y = -this.y, this } dot(e) { return this.x * e.x + this.y * e.y } cross(e) { return this.x * e.y - this.y * e.x } lengthSq() { return this.x * this.x + this.y * this.y } length() { return Math.sqrt(this.x * this.x + this.y * this.y) } manhattanLength() { return Math.abs(this.x) + Math.abs(this.y) } normalize() { return this.divideScalar(this.length() || 1) } angle() { return Math.atan2(-this.y, -this.x) + Math.PI } distanceTo(e) { return Math.sqrt(this.distanceToSquared(e)) } distanceToSquared(e) { const t = this.x - e.x, n = this.y - e.y; return t * t + n * n } manhattanDistanceTo(e) { return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) } setLength(e) { return this.normalize().multiplyScalar(e) } lerp(e, t) { return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this } lerpVectors(e, t, n) { return this.x = e.x + (t.x - e.x) * n, this.y = e.y + (t.y - e.y) * n, this } equals(e) { return e.x === this.x && e.y === this.y } fromArray(e, t = 0) { return this.x = e[t], this.y = e[t + 1], this } toArray(e = [], t = 0) { return e[t] = this.x, e[t + 1] = this.y, e } fromBufferAttribute(e, t, n) { return void 0 !== n && console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."), this.x = e.getX(t), this.y = e.getY(t), this } rotateAround(e, t) { const n = Math.cos(t), i = Math.sin(t), r = this.x - e.x, s = this.y - e.y; return this.x = r * n - s * i + e.x, this.y = r * i + s * n + e.y, this } random() { return this.x = Math.random(), this.y = Math.random(), this } } b.prototype.isVector2 = !0; class M { constructor() { this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1], arguments.length > 0 && console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.") } set(e, t, n, i, r, s, o, a, l) { const c = this.elements; return c[0] = e, c[1] = i, c[2] = o, c[3] = t, c[4] = r, c[5] = a, c[6] = n, c[7] = s, c[8] = l, this } identity() { return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this } copy(e) { const t = this.elements, n = e.elements; return t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], t[4] = n[4], t[5] = n[5], t[6] = n[6], t[7] = n[7], t[8] = n[8], this } extractBasis(e, t, n) { return e.setFromMatrix3Column(this, 0), t.setFromMatrix3Column(this, 1), n.setFromMatrix3Column(this, 2), this } setFromMatrix4(e) { const t = e.elements; return this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]), this } multiply(e) { return this.multiplyMatrices(this, e) } premultiply(e) { return this.multiplyMatrices(e, this) } multiplyMatrices(e, t) { const n = e.elements, i = t.elements, r = this.elements, s = n[0], o = n[3], a = n[6], l = n[1], c = n[4], A = n[7], u = n[2], h = n[5], d = n[8], p = i[0], f = i[3], g = i[6], m = i[1], v = i[4], y = i[7], w = i[2], x = i[5], C = i[8]; return r[0] = s * p + o * m + a * w, r[3] = s * f + o * v + a * x, r[6] = s * g + o * y + a * C, r[1] = l * p + c * m + A * w, r[4] = l * f + c * v + A * x, r[7] = l * g + c * y + A * C, r[2] = u * p + h * m + d * w, r[5] = u * f + h * v + d * x, r[8] = u * g + h * y + d * C, this } multiplyScalar(e) { const t = this.elements; return t[0] *= e, t[3] *= e, t[6] *= e, t[1] *= e, t[4] *= e, t[7] *= e, t[2] *= e, t[5] *= e, t[8] *= e, this } determinant() { const e = this.elements, t = e[0], n = e[1], i = e[2], r = e[3], s = e[4], o = e[5], a = e[6], l = e[7], c = e[8]; return t * s * c - t * o * l - n * r * c + n * o * a + i * r * l - i * s * a } invert() { const e = this.elements, t = e[0], n = e[1], i = e[2], r = e[3], s = e[4], o = e[5], a = e[6], l = e[7], c = e[8], A = c * s - o * l, u = o * a - c * r, h = l * r - s * a, d = t * A + n * u + i * h; if (0 === d) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0); const p = 1 / d; return e[0] = A * p, e[1] = (i * l - c * n) * p, e[2] = (o * n - i * s) * p, e[3] = u * p, e[4] = (c * t - i * a) * p, e[5] = (i * r - o * t) * p, e[6] = h * p, e[7] = (n * a - l * t) * p, e[8] = (s * t - n * r) * p, this } transpose() { let e; const t = this.elements; return e = t[1], t[1] = t[3], t[3] = e, e = t[2], t[2] = t[6], t[6] = e, e = t[5], t[5] = t[7], t[7] = e, this } getNormalMatrix(e) { return this.setFromMatrix4(e).invert().transpose() } transposeIntoArray(e) { const t = this.elements; return e[0] = t[0], e[1] = t[3], e[2] = t[6], e[3] = t[1], e[4] = t[4], e[5] = t[7], e[6] = t[2], e[7] = t[5], e[8] = t[8], this } setUvTransform(e, t, n, i, r, s, o) { const a = Math.cos(r), l = Math.sin(r); return this.set(n * a, n * l, -n * (a * s + l * o) + s + e, -i * l, i * a, -i * (-l * s + a * o) + o + t, 0, 0, 1), this } scale(e, t) { const n = this.elements; return n[0] *= e, n[3] *= e, n[6] *= e, n[1] *= t, n[4] *= t, n[7] *= t, this } rotate(e) { const t = Math.cos(e), n = Math.sin(e), i = this.elements, r = i[0], s = i[3], o = i[6], a = i[1], l = i[4], c = i[7]; return i[0] = t * r + n * a, i[3] = t * s + n * l, i[6] = t * o + n * c, i[1] = -n * r + t * a, i[4] = -n * s + t * l, i[7] = -n * o + t * c, this } translate(e, t) { const n = this.elements; return n[0] += e * n[2], n[3] += e * n[5], n[6] += e * n[8], n[1] += t * n[2], n[4] += t * n[5], n[7] += t * n[8], this } equals(e) { const t = this.elements, n = e.elements; for (let e = 0; e < 9; e++)if (t[e] !== n[e]) return !1; return !0 } fromArray(e, t = 0) { for (let n = 0; n < 9; n++)this.elements[n] = e[n + t]; return this } toArray(e = [], t = 0) { const n = this.elements; return e[t] = n[0], e[t + 1] = n[1], e[t + 2] = n[2], e[t + 3] = n[3], e[t + 4] = n[4], e[t + 5] = n[5], e[t + 6] = n[6], e[t + 7] = n[7], e[t + 8] = n[8], e } clone() { return (new this.constructor).fromArray(this.elements) } } let I; M.prototype.isMatrix3 = !0; class E { static getDataURL(e) { if (/^data:/i.test(e.src)) return e.src; if ("undefined" == typeof HTMLCanvasElement) return e.src; let t; if (e instanceof HTMLCanvasElement) t = e; else { void 0 === I && (I = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")), I.width = e.width, I.height = e.height; const n = I.getContext("2d"); e instanceof ImageData ? n.putImageData(e, 0, 0) : n.drawImage(e, 0, 0, e.width, e.height), t = I } return t.width > 2048 || t.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", e), t.toDataURL("image/jpeg", .6)) : t.toDataURL("image/png") } } let T = 0; class P extends A { constructor(e = P.DEFAULT_IMAGE, t = P.DEFAULT_MAPPING, n = 1001, i = 1001, r = 1006, s = 1008, o = 1023, a = 1009, l = 1, c = 3e3) { super(), Object.defineProperty(this, "id", { value: T++ }), this.uuid = f(), this.name = "", this.image = e, this.mipmaps = [], this.mapping = t, this.wrapS = n, this.wrapT = i, this.magFilter = r, this.minFilter = s, this.anisotropy = l, this.format = o, this.internalFormat = null, this.type = a, this.offset = new b(0, 0), this.repeat = new b(1, 1), this.center = new b(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new M, this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.encoding = c, this.version = 0, this.onUpdate = null } updateMatrix() { this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y) } clone() { return (new this.constructor).copy(this) } copy(e) { return this.name = e.name, this.image = e.image, this.mipmaps = e.mipmaps.slice(0), this.mapping = e.mapping, this.wrapS = e.wrapS, this.wrapT = e.wrapT, this.magFilter = e.magFilter, this.minFilter = e.minFilter, this.anisotropy = e.anisotropy, this.format = e.format, this.internalFormat = e.internalFormat, this.type = e.type, this.offset.copy(e.offset), this.repeat.copy(e.repeat), this.center.copy(e.center), this.rotation = e.rotation, this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrix.copy(e.matrix), this.generateMipmaps = e.generateMipmaps, this.premultiplyAlpha = e.premultiplyAlpha, this.flipY = e.flipY, this.unpackAlignment = e.unpackAlignment, this.encoding = e.encoding, this } toJSON(e) { const t = void 0 === e || "string" == typeof e; if (!t && void 0 !== e.textures[this.uuid]) return e.textures[this.uuid]; const n = { metadata: { version: 4.5, type: "Texture", generator: "Texture.toJSON" }, uuid: this.uuid, name: this.name, mapping: this.mapping, repeat: [this.repeat.x, this.repeat.y], offset: [this.offset.x, this.offset.y], center: [this.center.x, this.center.y], rotation: this.rotation, wrap: [this.wrapS, this.wrapT], format: this.format, type: this.type, encoding: this.encoding, minFilter: this.minFilter, magFilter: this.magFilter, anisotropy: this.anisotropy, flipY: this.flipY, premultiplyAlpha: this.premultiplyAlpha, unpackAlignment: this.unpackAlignment }; if (void 0 !== this.image) { const i = this.image; if (void 0 === i.uuid && (i.uuid = f()), !t && void 0 === e.images[i.uuid]) { let t; if (Array.isArray(i)) { t = []; for (let e = 0, n = i.length; e < n; e++)i[e].isDataTexture ? t.push(S(i[e].image)) : t.push(S(i[e])) } else t = S(i); e.images[i.uuid] = { uuid: i.uuid, url: t } } n.image = i.uuid } return t || (e.textures[this.uuid] = n), n } dispose() { this.dispatchEvent({ type: "dispose" }) } transformUv(e) { if (300 !== this.mapping) return e; if (e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1) switch (this.wrapS) { case 1e3: e.x = e.x - Math.floor(e.x); break; case 1001: e.x = e.x < 0 ? 0 : 1; break; case 1002: 1 === Math.abs(Math.floor(e.x) % 2) ? e.x = Math.ceil(e.x) - e.x : e.x = e.x - Math.floor(e.x) }if (e.y < 0 || e.y > 1) switch (this.wrapT) { case 1e3: e.y = e.y - Math.floor(e.y); break; case 1001: e.y = e.y < 0 ? 0 : 1; break; case 1002: 1 === Math.abs(Math.floor(e.y) % 2) ? e.y = Math.ceil(e.y) - e.y : e.y = e.y - Math.floor(e.y) }return this.flipY && (e.y = 1 - e.y), e } set needsUpdate(e) { !0 === e && this.version++ } } function S(e) { return "undefined" != typeof HTMLImageElement && e instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && e instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && e instanceof ImageBitmap ? E.getDataURL(e) : e.data ? { data: Array.prototype.slice.call(e.data), width: e.width, height: e.height, type: e.data.constructor.name } : (console.warn("THREE.Texture: Unable to serialize Texture."), {}) } P.DEFAULT_IMAGE = void 0, P.DEFAULT_MAPPING = 300, P.prototype.isTexture = !0; class B { constructor(e = 0, t = 0, n = 0, i = 1) { this.x = e, this.y = t, this.z = n, this.w = i } get width() { return this.z } set width(e) { this.z = e } get height() { return this.w } set height(e) { this.w = e } set(e, t, n, i) { return this.x = e, this.y = t, this.z = n, this.w = i, this } setScalar(e) { return this.x = e, this.y = e, this.z = e, this.w = e, this } setX(e) { return this.x = e, this } setY(e) { return this.y = e, this } setZ(e) { return this.z = e, this } setW(e) { return this.w = e, this } setComponent(e, t) { switch (e) { case 0: this.x = t; break; case 1: this.y = t; break; case 2: this.z = t; break; case 3: this.w = t; break; default: throw new Error("index is out of range: " + e) }return this } getComponent(e) { switch (e) { case 0: return this.x; case 1: return this.y; case 2: return this.z; case 3: return this.w; default: throw new Error("index is out of range: " + e) } } clone() { return new this.constructor(this.x, this.y, this.z, this.w) } copy(e) { return this.x = e.x, this.y = e.y, this.z = e.z, this.w = void 0 !== e.w ? e.w : 1, this } add(e, t) { return void 0 !== t ? (console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(e, t)) : (this.x += e.x, this.y += e.y, this.z += e.z, this.w += e.w, this) } addScalar(e) { return this.x += e, this.y += e, this.z += e, this.w += e, this } addVectors(e, t) { return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this.w = e.w + t.w, this } addScaledVector(e, t) { return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this.w += e.w * t, this } sub(e, t) { return void 0 !== t ? (console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(e, t)) : (this.x -= e.x, this.y -= e.y, this.z -= e.z, this.w -= e.w, this) } subScalar(e) { return this.x -= e, this.y -= e, this.z -= e, this.w -= e, this } subVectors(e, t) { return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this.w = e.w - t.w, this } multiply(e) { return this.x *= e.x, this.y *= e.y, this.z *= e.z, this.w *= e.w, this } multiplyScalar(e) { return this.x *= e, this.y *= e, this.z *= e, this.w *= e, this } applyMatrix4(e) { const t = this.x, n = this.y, i = this.z, r = this.w, s = e.elements; return this.x = s[0] * t + s[4] * n + s[8] * i + s[12] * r, this.y = s[1] * t + s[5] * n + s[9] * i + s[13] * r, this.z = s[2] * t + s[6] * n + s[10] * i + s[14] * r, this.w = s[3] * t + s[7] * n + s[11] * i + s[15] * r, this } divideScalar(e) { return this.multiplyScalar(1 / e) } setAxisAngleFromQuaternion(e) { this.w = 2 * Math.acos(e.w); const t = Math.sqrt(1 - e.w * e.w); return t < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = e.x / t, this.y = e.y / t, this.z = e.z / t), this } setAxisAngleFromRotationMatrix(e) { let t, n, i, r; const s = e.elements, o = s[0], a = s[4], l = s[8], c = s[1], A = s[5], u = s[9], h = s[2], d = s[6], p = s[10]; if (Math.abs(a - c) < .01 && Math.abs(l - h) < .01 && Math.abs(u - d) < .01) { if (Math.abs(a + c) < .1 && Math.abs(l + h) < .1 && Math.abs(u + d) < .1 && Math.abs(o + A + p - 3) < .1) return this.set(1, 0, 0, 0), this; t = Math.PI; const e = (o + 1) / 2, s = (A + 1) / 2, f = (p + 1) / 2, g = (a + c) / 4, m = (l + h) / 4, v = (u + d) / 4; return e > s && e > f ? e < .01 ? (n = 0, i = .707106781, r = .707106781) : (n = Math.sqrt(e), i = g / n, r = m / n) : s > f ? s < .01 ? (n = .707106781, i = 0, r = .707106781) : (i = Math.sqrt(s), n = g / i, r = v / i) : f < .01 ? (n = .707106781, i = .707106781, r = 0) : (r = Math.sqrt(f), n = m / r, i = v / r), this.set(n, i, r, t), this } let f = Math.sqrt((d - u) * (d - u) + (l - h) * (l - h) + (c - a) * (c - a)); return Math.abs(f) < .001 && (f = 1), this.x = (d - u) / f, this.y = (l - h) / f, this.z = (c - a) / f, this.w = Math.acos((o + A + p - 1) / 2), this } min(e) { return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this.w = Math.min(this.w, e.w), this } max(e) { return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this.w = Math.max(this.w, e.w), this } clamp(e, t) { return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this.w = Math.max(e.w, Math.min(t.w, this.w)), this } clampScalar(e, t) { return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this.z = Math.max(e, Math.min(t, this.z)), this.w = Math.max(e, Math.min(t, this.w)), this } clampLength(e, t) { const n = this.length(); return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n))) } floor() { return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this } ceil() { return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this } round() { return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this } roundToZero() { return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w), this } negate() { return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this } dot(e) { return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w } lengthSq() { return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w } length() { return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w) } manhattanLength() { return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w) } normalize() { return this.divideScalar(this.length() || 1) } setLength(e) { return this.normalize().multiplyScalar(e) } lerp(e, t) { return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this.w += (e.w - this.w) * t, this } lerpVectors(e, t, n) { return this.x = e.x + (t.x - e.x) * n, this.y = e.y + (t.y - e.y) * n, this.z = e.z + (t.z - e.z) * n, this.w = e.w + (t.w - e.w) * n, this } equals(e) { return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w } fromArray(e, t = 0) { return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this.w = e[t + 3], this } toArray(e = [], t = 0) { return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e[t + 3] = this.w, e } fromBufferAttribute(e, t, n) { return void 0 !== n && console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."), this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this.w = e.getW(t), this } random() { return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this } } B.prototype.isVector4 = !0; class D extends A { constructor(e, t, n = {}) { super(), this.width = e, this.height = t, this.depth = 1, this.scissor = new B(0, 0, e, t), this.scissorTest = !1, this.viewport = new B(0, 0, e, t), this.texture = new P(void 0, n.mapping, n.wrapS, n.wrapT, n.magFilter, n.minFilter, n.format, n.type, n.anisotropy, n.encoding), this.texture.image = { width: e, height: t, depth: 1 }, this.texture.generateMipmaps = void 0 !== n.generateMipmaps && n.generateMipmaps, this.texture.minFilter = void 0 !== n.minFilter ? n.minFilter : 1006, this.depthBuffer = void 0 === n.depthBuffer || n.depthBuffer, this.stencilBuffer = void 0 !== n.stencilBuffer && n.stencilBuffer, this.depthTexture = void 0 !== n.depthTexture ? n.depthTexture : null } setTexture(e) { e.image = { width: this.width, height: this.height, depth: this.depth }, this.texture = e } setSize(e, t, n = 1) { this.width === e && this.height === t && this.depth === n || (this.width = e, this.height = t, this.depth = n, this.texture.image.width = e, this.texture.image.height = t, this.texture.image.depth = n, this.dispose()), this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t) } clone() { return (new this.constructor).copy(this) } copy(e) { return this.width = e.width, this.height = e.height, this.depth = e.depth, this.viewport.copy(e.viewport), this.texture = e.texture.clone(), this.texture.image = { ...this.texture.image }, this.depthBuffer = e.depthBuffer, this.stencilBuffer = e.stencilBuffer, this.depthTexture = e.depthTexture, this } dispose() { this.dispatchEvent({ type: "dispose" }) } } D.prototype.isWebGLRenderTarget = !0; (class extends D { constructor(e, t, n) { super(e, t); const i = this.texture; this.texture = []; for (let e = 0; e < n; e++)this.texture[e] = i.clone() } setSize(e, t, n = 1) { if (this.width !== e || this.height !== t || this.depth !== n) { this.width = e, this.height = t, this.depth = n; for (let i = 0, r = this.texture.length; i < r; i++)this.texture[i].image.width = e, this.texture[i].image.height = t, this.texture[i].image.depth = n; this.dispose() } return this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t), this } copy(e) { this.dispose(), this.width = e.width, this.height = e.height, this.depth = e.depth, this.viewport.set(0, 0, this.width, this.height), this.scissor.set(0, 0, this.width, this.height), this.depthBuffer = e.depthBuffer, this.stencilBuffer = e.stencilBuffer, this.depthTexture = e.depthTexture, this.texture.length = 0; for (let t = 0, n = e.texture.length; t < n; t++)this.texture[t] = e.texture[t].clone(); return this } }).prototype.isWebGLMultipleRenderTargets = !0; class R extends D { constructor(e, t, n) { super(e, t, n), this.samples = 4 } copy(e) { return super.copy.call(this, e), this.samples = e.samples, this } } R.prototype.isWebGLMultisampleRenderTarget = !0; class L { constructor(e = 0, t = 0, n = 0, i = 1) { this._x = e, this._y = t, this._z = n, this._w = i } static slerp(e, t, n, i) { return console.warn("THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead."), n.slerpQuaternions(e, t, i) } static slerpFlat(e, t, n, i, r, s, o) { let a = n[i + 0], l = n[i + 1], c = n[i + 2], A = n[i + 3]; const u = r[s + 0], h = r[s + 1], d = r[s + 2], p = r[s + 3]; if (0 === o) return e[t + 0] = a, e[t + 1] = l, e[t + 2] = c, void (e[t + 3] = A); if (1 === o) return e[t + 0] = u, e[t + 1] = h, e[t + 2] = d, void (e[t + 3] = p); if (A !== p || a !== u || l !== h || c !== d) { let e = 1 - o; const t = a * u + l * h + c * d + A * p, n = t >= 0 ? 1 : -1, i = 1 - t * t; if (i > Number.EPSILON) { const r = Math.sqrt(i), s = Math.atan2(r, t * n); e = Math.sin(e * s) / r, o = Math.sin(o * s) / r } const r = o * n; if (a = a * e + u * r, l = l * e + h * r, c = c * e + d * r, A = A * e + p * r, e === 1 - o) { const e = 1 / Math.sqrt(a * a + l * l + c * c + A * A); a *= e, l *= e, c *= e, A *= e } } e[t] = a, e[t + 1] = l, e[t + 2] = c, e[t + 3] = A } static multiplyQuaternionsFlat(e, t, n, i, r, s) { const o = n[i], a = n[i + 1], l = n[i + 2], c = n[i + 3], A = r[s], u = r[s + 1], h = r[s + 2], d = r[s + 3]; return e[t] = o * d + c * A + a * h - l * u, e[t + 1] = a * d + c * u + l * A - o * h, e[t + 2] = l * d + c * h + o * u - a * A, e[t + 3] = c * d - o * A - a * u - l * h, e } get x() { return this._x } set x(e) { this._x = e, this._onChangeCallback() } get y() { return this._y } set y(e) { this._y = e, this._onChangeCallback() } get z() { return this._z } set z(e) { this._z = e, this._onChangeCallback() } get w() { return this._w } set w(e) { this._w = e, this._onChangeCallback() } set(e, t, n, i) { return this._x = e, this._y = t, this._z = n, this._w = i, this._onChangeCallback(), this } clone() { return new this.constructor(this._x, this._y, this._z, this._w) } copy(e) { return this._x = e.x, this._y = e.y, this._z = e.z, this._w = e.w, this._onChangeCallback(), this } setFromEuler(e, t) { if (!e || !e.isEuler) throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order."); const n = e._x, i = e._y, r = e._z, s = e._order, o = Math.cos, a = Math.sin, l = o(n / 2), c = o(i / 2), A = o(r / 2), u = a(n / 2), h = a(i / 2), d = a(r / 2); switch (s) { case "XYZ": this._x = u * c * A + l * h * d, this._y = l * h * A - u * c * d, this._z = l * c * d + u * h * A, this._w = l * c * A - u * h * d; break; case "YXZ": this._x = u * c * A + l * h * d, this._y = l * h * A - u * c * d, this._z = l * c * d - u * h * A, this._w = l * c * A + u * h * d; break; case "ZXY": this._x = u * c * A - l * h * d, this._y = l * h * A + u * c * d, this._z = l * c * d + u * h * A, this._w = l * c * A - u * h * d; break; case "ZYX": this._x = u * c * A - l * h * d, this._y = l * h * A + u * c * d, this._z = l * c * d - u * h * A, this._w = l * c * A + u * h * d; break; case "YZX": this._x = u * c * A + l * h * d, this._y = l * h * A + u * c * d, this._z = l * c * d - u * h * A, this._w = l * c * A - u * h * d; break; case "XZY": this._x = u * c * A - l * h * d, this._y = l * h * A - u * c * d, this._z = l * c * d + u * h * A, this._w = l * c * A + u * h * d; break; default: console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + s) }return !1 !== t && this._onChangeCallback(), this } setFromAxisAngle(e, t) { const n = t / 2, i = Math.sin(n); return this._x = e.x * i, this._y = e.y * i, this._z = e.z * i, this._w = Math.cos(n), this._onChangeCallback(), this } setFromRotationMatrix(e) { const t = e.elements, n = t[0], i = t[4], r = t[8], s = t[1], o = t[5], a = t[9], l = t[2], c = t[6], A = t[10], u = n + o + A; if (u > 0) { const e = .5 / Math.sqrt(u + 1); this._w = .25 / e, this._x = (c - a) * e, this._y = (r - l) * e, this._z = (s - i) * e } else if (n > o && n > A) { const e = 2 * Math.sqrt(1 + n - o - A); this._w = (c - a) / e, this._x = .25 * e, this._y = (i + s) / e, this._z = (r + l) / e } else if (o > A) { const e = 2 * Math.sqrt(1 + o - n - A); this._w = (r - l) / e, this._x = (i + s) / e, this._y = .25 * e, this._z = (a + c) / e } else { const e = 2 * Math.sqrt(1 + A - n - o); this._w = (s - i) / e, this._x = (r + l) / e, this._y = (a + c) / e, this._z = .25 * e } return this._onChangeCallback(), this } setFromUnitVectors(e, t) { let n = e.dot(t) + 1; return n < Number.EPSILON ? (n = 0, Math.abs(e.x) > Math.abs(e.z) ? (this._x = -e.y, this._y = e.x, this._z = 0, this._w = n) : (this._x = 0, this._y = -e.z, this._z = e.y, this._w = n)) : (this._x = e.y * t.z - e.z * t.y, this._y = e.z * t.x - e.x * t.z, this._z = e.x * t.y - e.y * t.x, this._w = n), this.normalize() } angleTo(e) { return 2 * Math.acos(Math.abs(g(this.dot(e), -1, 1))) } rotateTowards(e, t) { const n = this.angleTo(e); if (0 === n) return this; const i = Math.min(1, t / n); return this.slerp(e, i), this } identity() { return this.set(0, 0, 0, 1) } invert() { return this.conjugate() } conjugate() { return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this } dot(e) { return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w } lengthSq() { return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w } length() { return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w) } normalize() { let e = this.length(); return 0 === e ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (e = 1 / e, this._x = this._x * e, this._y = this._y * e, this._z = this._z * e, this._w = this._w * e), this._onChangeCallback(), this } multiply(e, t) { return void 0 !== t ? (console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."), this.multiplyQuaternions(e, t)) : this.multiplyQuaternions(this, e) } premultiply(e) { return this.multiplyQuaternions(e, this) } multiplyQuaternions(e, t) { const n = e._x, i = e._y, r = e._z, s = e._w, o = t._x, a = t._y, l = t._z, c = t._w; return this._x = n * c + s * o + i * l - r * a, this._y = i * c + s * a + r * o - n * l, this._z = r * c + s * l + n * a - i * o, this._w = s * c - n * o - i * a - r * l, this._onChangeCallback(), this } slerp(e, t) { if (0 === t) return this; if (1 === t) return this.copy(e); const n = this._x, i = this._y, r = this._z, s = this._w; let o = s * e._w + n * e._x + i * e._y + r * e._z; if (o < 0 ? (this._w = -e._w, this._x = -e._x, this._y = -e._y, this._z = -e._z, o = -o) : this.copy(e), o >= 1) return this._w = s, this._x = n, this._y = i, this._z = r, this; const a = 1 - o * o; if (a <= Number.EPSILON) { const e = 1 - t; return this._w = e * s + t * this._w, this._x = e * n + t * this._x, this._y = e * i + t * this._y, this._z = e * r + t * this._z, this.normalize(), this._onChangeCallback(), this } const l = Math.sqrt(a), c = Math.atan2(l, o), A = Math.sin((1 - t) * c) / l, u = Math.sin(t * c) / l; return this._w = s * A + this._w * u, this._x = n * A + this._x * u, this._y = i * A + this._y * u, this._z = r * A + this._z * u, this._onChangeCallback(), this } slerpQuaternions(e, t, n) { this.copy(e).slerp(t, n) } equals(e) { return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w } fromArray(e, t = 0) { return this._x = e[t], this._y = e[t + 1], this._z = e[t + 2], this._w = e[t + 3], this._onChangeCallback(), this } toArray(e = [], t = 0) { return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._w, e } fromBufferAttribute(e, t) { return this._x = e.getX(t), this._y = e.getY(t), this._z = e.getZ(t), this._w = e.getW(t), this } _onChange(e) { return this._onChangeCallback = e, this } _onChangeCallback() { } } L.prototype.isQuaternion = !0; class O { constructor(e = 0, t = 0, n = 0) { this.x = e, this.y = t, this.z = n } set(e, t, n) { return void 0 === n && (n = this.z), this.x = e, this.y = t, this.z = n, this } setScalar(e) { return this.x = e, this.y = e, this.z = e, this } setX(e) { return this.x = e, this } setY(e) { return this.y = e, this } setZ(e) { return this.z = e, this } setComponent(e, t) { switch (e) { case 0: this.x = t; break; case 1: this.y = t; break; case 2: this.z = t; break; default: throw new Error("index is out of range: " + e) }return this } getComponent(e) { switch (e) { case 0: return this.x; case 1: return this.y; case 2: return this.z; default: throw new Error("index is out of range: " + e) } } clone() { return new this.constructor(this.x, this.y, this.z) } copy(e) { return this.x = e.x, this.y = e.y, this.z = e.z, this } add(e, t) { return void 0 !== t ? (console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(e, t)) : (this.x += e.x, this.y += e.y, this.z += e.z, this) } addScalar(e) { return this.x += e, this.y += e, this.z += e, this } addVectors(e, t) { return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this } addScaledVector(e, t) { return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this } sub(e, t) { return void 0 !== t ? (console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(e, t)) : (this.x -= e.x, this.y -= e.y, this.z -= e.z, this) } subScalar(e) { return this.x -= e, this.y -= e, this.z -= e, this } subVectors(e, t) { return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this } multiply(e, t) { return void 0 !== t ? (console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."), this.multiplyVectors(e, t)) : (this.x *= e.x, this.y *= e.y, this.z *= e.z, this) } multiplyScalar(e) { return this.x *= e, this.y *= e, this.z *= e, this } multiplyVectors(e, t) { return this.x = e.x * t.x, this.y = e.y * t.y, this.z = e.z * t.z, this } applyEuler(e) { return e && e.isEuler || console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."), this.applyQuaternion(k.setFromEuler(e)) } applyAxisAngle(e, t) { return this.applyQuaternion(k.setFromAxisAngle(e, t)) } applyMatrix3(e) { const t = this.x, n = this.y, i = this.z, r = e.elements; return this.x = r[0] * t + r[3] * n + r[6] * i, this.y = r[1] * t + r[4] * n + r[7] * i, this.z = r[2] * t + r[5] * n + r[8] * i, this } applyNormalMatrix(e) { return this.applyMatrix3(e).normalize() } applyMatrix4(e) { const t = this.x, n = this.y, i = this.z, r = e.elements, s = 1 / (r[3] * t + r[7] * n + r[11] * i + r[15]); return this.x = (r[0] * t + r[4] * n + r[8] * i + r[12]) * s, this.y = (r[1] * t + r[5] * n + r[9] * i + r[13]) * s, this.z = (r[2] * t + r[6] * n + r[10] * i + r[14]) * s, this } applyQuaternion(e) { const t = this.x, n = this.y, i = this.z, r = e.x, s = e.y, o = e.z, a = e.w, l = a * t + s * i - o * n, c = a * n + o * t - r * i, A = a * i + r * n - s * t, u = -r * t - s * n - o * i; return this.x = l * a + u * -r + c * -o - A * -s, this.y = c * a + u * -s + A * -r - l * -o, this.z = A * a + u * -o + l * -s - c * -r, this } project(e) { return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix) } unproject(e) { return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld) } transformDirection(e) { const t = this.x, n = this.y, i = this.z, r = e.elements; return this.x = r[0] * t + r[4] * n + r[8] * i, this.y = r[1] * t + r[5] * n + r[9] * i, this.z = r[2] * t + r[6] * n + r[10] * i, this.normalize() } divide(e) { return this.x /= e.x, this.y /= e.y, this.z /= e.z, this } divideScalar(e) { return this.multiplyScalar(1 / e) } min(e) { return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this } max(e) { return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this } clamp(e, t) { return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this } clampScalar(e, t) { return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this.z = Math.max(e, Math.min(t, this.z)), this } clampLength(e, t) { const n = this.length(); return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n))) } floor() { return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this } ceil() { return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this } round() { return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this } roundToZero() { return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this } negate() { return this.x = -this.x, this.y = -this.y, this.z = -this.z, this } dot(e) { return this.x * e.x + this.y * e.y + this.z * e.z } lengthSq() { return this.x * this.x + this.y * this.y + this.z * this.z } length() { return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z) } manhattanLength() { return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) } normalize() { return this.divideScalar(this.length() || 1) } setLength(e) { return this.normalize().multiplyScalar(e) } lerp(e, t) { return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this } lerpVectors(e, t, n) { return this.x = e.x + (t.x - e.x) * n, this.y = e.y + (t.y - e.y) * n, this.z = e.z + (t.z - e.z) * n, this } cross(e, t) { return void 0 !== t ? (console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."), this.crossVectors(e, t)) : this.crossVectors(this, e) } crossVectors(e, t) { const n = e.x, i = e.y, r = e.z, s = t.x, o = t.y, a = t.z; return this.x = i * a - r * o, this.y = r * s - n * a, this.z = n * o - i * s, this } projectOnVector(e) { const t = e.lengthSq(); if (0 === t) return this.set(0, 0, 0); const n = e.dot(this) / t; return this.copy(e).multiplyScalar(n) } projectOnPlane(e) { return N.copy(this).projectOnVector(e), this.sub(N) } reflect(e) { return this.sub(N.copy(e).multiplyScalar(2 * this.dot(e))) } angleTo(e) { const t = Math.sqrt(this.lengthSq() * e.lengthSq()); if (0 === t) return Math.PI / 2; const n = this.dot(e) / t; return Math.acos(g(n, -1, 1)) } distanceTo(e) { return Math.sqrt(this.distanceToSquared(e)) } distanceToSquared(e) { const t = this.x - e.x, n = this.y - e.y, i = this.z - e.z; return t * t + n * n + i * i } manhattanDistanceTo(e) { return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z) } setFromSpherical(e) { return this.setFromSphericalCoords(e.radius, e.phi, e.theta) } setFromSphericalCoords(e, t, n) { const i = Math.sin(t) * e; return this.x = i * Math.sin(n), this.y = Math.cos(t) * e, this.z = i * Math.cos(n), this } setFromCylindrical(e) { return this.setFromCylindricalCoords(e.radius, e.theta, e.y) } setFromCylindricalCoords(e, t, n) { return this.x = e * Math.sin(t), this.y = n, this.z = e * Math.cos(t), this } setFromMatrixPosition(e) { const t = e.elements; return this.x = t[12], this.y = t[13], this.z = t[14], this } setFromMatrixScale(e) { const t = this.setFromMatrixColumn(e, 0).length(), n = this.setFromMatrixColumn(e, 1).length(), i = this.setFromMatrixColumn(e, 2).length(); return this.x = t, this.y = n, this.z = i, this } setFromMatrixColumn(e, t) { return this.fromArray(e.elements, 4 * t) } setFromMatrix3Column(e, t) { return this.fromArray(e.elements, 3 * t) } equals(e) { return e.x === this.x && e.y === this.y && e.z === this.z } fromArray(e, t = 0) { return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this } toArray(e = [], t = 0) { return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e } fromBufferAttribute(e, t, n) { return void 0 !== n && console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."), this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this } random() { return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this } } O.prototype.isVector3 = !0; const N = new O, k = new L; class H { constructor(e = new O(1 / 0, 1 / 0, 1 / 0), t = new O(-1 / 0, -1 / 0, -1 / 0)) { this.min = e, this.max = t } set(e, t) { return this.min.copy(e), this.max.copy(t), this } setFromArray(e) { let t = 1 / 0, n = 1 / 0, i = 1 / 0, r = -1 / 0, s = -1 / 0, o = -1 / 0; for (let a = 0, l = e.length; a < l; a += 3) { const l = e[a], c = e[a + 1], A = e[a + 2]; l < t && (t = l), c < n && (n = c), A < i && (i = A), l > r && (r = l), c > s && (s = c), A > o && (o = A) } return this.min.set(t, n, i), this.max.set(r, s, o), this } setFromBufferAttribute(e) { let t = 1 / 0, n = 1 / 0, i = 1 / 0, r = -1 / 0, s = -1 / 0, o = -1 / 0; for (let a = 0, l = e.count; a < l; a++) { const l = e.getX(a), c = e.getY(a), A = e.getZ(a); l < t && (t = l), c < n && (n = c), A < i && (i = A), l > r && (r = l), c > s && (s = c), A > o && (o = A) } return this.min.set(t, n, i), this.max.set(r, s, o), this } setFromPoints(e) { this.makeEmpty(); for (let t = 0, n = e.length; t < n; t++)this.expandByPoint(e[t]); return this } setFromCenterAndSize(e, t) { const n = F.copy(t).multiplyScalar(.5); return this.min.copy(e).sub(n), this.max.copy(e).add(n), this } setFromObject(e) { return this.makeEmpty(), this.expandByObject(e) } clone() { return (new this.constructor).copy(this) } copy(e) { return this.min.copy(e.min), this.max.copy(e.max), this } makeEmpty() { return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this } isEmpty() { return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z } getCenter(e) { return this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5) } getSize(e) { return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min) } expandByPoint(e) { return this.min.min(e), this.max.max(e), this } expandByVector(e) { return this.min.sub(e), this.max.add(e), this } expandByScalar(e) { return this.min.addScalar(-e), this.max.addScalar(e), this } expandByObject(e) { e.updateWorldMatrix(!1, !1); const t = e.geometry; void 0 !== t && (null === t.boundingBox && t.computeBoundingBox(), Q.copy(t.boundingBox), Q.applyMatrix4(e.matrixWorld), this.union(Q)); const n = e.children; for (let e = 0, t = n.length; e < t; e++)this.expandByObject(n[e]); return this } containsPoint(e) { return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y || e.z < this.min.z || e.z > this.max.z) } containsBox(e) { return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z } getParameter(e, t) { return t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y), (e.z - this.min.z) / (this.max.z - this.min.z)) } intersectsBox(e) { return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y || e.max.z < this.min.z || e.min.z > this.max.z) } intersectsSphere(e) { return this.clampPoint(e.center, F), F.distanceToSquared(e.center) <= e.radius * e.radius } intersectsPlane(e) { let t, n; return e.normal.x > 0 ? (t = e.normal.x * this.min.x, n = e.normal.x * this.max.x) : (t = e.normal.x * this.max.x, n = e.normal.x * this.min.x), e.normal.y > 0 ? (t += e.normal.y * this.min.y, n += e.normal.y * this.max.y) : (t += e.normal.y * this.max.y, n += e.normal.y * this.min.y), e.normal.z > 0 ? (t += e.normal.z * this.min.z, n += e.normal.z * this.max.z) : (t += e.normal.z * this.max.z, n += e.normal.z * this.min.z), t <= -e.constant && n >= -e.constant } intersectsTriangle(e) { if (this.isEmpty()) return !1; this.getCenter(X), J.subVectors(this.max, X), G.subVectors(e.a, X), j.subVectors(e.b, X), U.subVectors(e.c, X), V.subVectors(j, G), Y.subVectors(U, j), W.subVectors(G, U); let t = [0, -V.z, V.y, 0, -Y.z, Y.y, 0, -W.z, W.y, V.z, 0, -V.x, Y.z, 0, -Y.x, W.z, 0, -W.x, -V.y, V.x, 0, -Y.y, Y.x, 0, -W.y, W.x, 0]; return !!q(t, G, j, U, J) && (t = [1, 0, 0, 0, 1, 0, 0, 0, 1], !!q(t, G, j, U, J) && (K.crossVectors(V, Y), t = [K.x, K.y, K.z], q(t, G, j, U, J))) } clampPoint(e, t) { return t.copy(e).clamp(this.min, this.max) } distanceToPoint(e) { return F.copy(e).clamp(this.min, this.max).sub(e).length() } getBoundingSphere(e) { return this.getCenter(e.center), e.radius = .5 * this.getSize(F).length(), e } intersect(e) { return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this } union(e) { return this.min.min(e.min), this.max.max(e.max), this } applyMatrix4(e) { return this.isEmpty() || (z[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e), z[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e), z[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e), z[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e), z[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e), z[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e), z[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e), z[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e), this.setFromPoints(z)), this } translate(e) { return this.min.add(e), this.max.add(e), this } equals(e) { return e.min.equals(this.min) && e.max.equals(this.max) } } H.prototype.isBox3 = !0; const z = [new O, new O, new O, new O, new O, new O, new O, new O], F = new O, Q = new H, G = new O, j = new O, U = new O, V = new O, Y = new O, W = new O, X = new O, J = new O, K = new O, Z = new O; function q(e, t, n, i, r) { for (let s = 0, o = e.length - 3; s <= o; s += 3) { Z.fromArray(e, s); const o = r.x * Math.abs(Z.x) + r.y * Math.abs(Z.y) + r.z * Math.abs(Z.z), a = t.dot(Z), l = n.dot(Z), c = i.dot(Z); if (Math.max(-Math.max(a, l, c), Math.min(a, l, c)) > o) return !1 } return !0 } const _ = new H, $ = new O, ee = new O, te = new O; class ne { constructor(e = new O, t = -1) { this.center = e, this.radius = t } set(e, t) { return this.center.copy(e), this.radius = t, this } setFromPoints(e, t) { const n = this.center; void 0 !== t ? n.copy(t) : _.setFromPoints(e).getCenter(n); let i = 0; for (let t = 0, r = e.length; t < r; t++)i = Math.max(i, n.distanceToSquared(e[t])); return this.radius = Math.sqrt(i), this } copy(e) { return this.center.copy(e.center), this.radius = e.radius, this } isEmpty() { return this.radius < 0 } makeEmpty() { return this.center.set(0, 0, 0), this.radius = -1, this } containsPoint(e) { return e.distanceToSquared(this.center) <= this.radius * this.radius } distanceToPoint(e) { return e.distanceTo(this.center) - this.radius } intersectsSphere(e) { const t = this.radius + e.radius; return e.center.distanceToSquared(this.center) <= t * t } intersectsBox(e) { return e.intersectsSphere(this) } intersectsPlane(e) { return Math.abs(e.distanceToPoint(this.center)) <= this.radius } clampPoint(e, t) { const n = this.center.distanceToSquared(e); return t.copy(e), n > this.radius * this.radius && (t.sub(this.center).normalize(), t.multiplyScalar(this.radius).add(this.center)), t } getBoundingBox(e) { return this.isEmpty() ? (e.makeEmpty(), e) : (e.set(this.center, this.center), e.expandByScalar(this.radius), e) } applyMatrix4(e) { return this.center.applyMatrix4(e), this.radius = this.radius * e.getMaxScaleOnAxis(), this } translate(e) { return this.center.add(e), this } expandByPoint(e) { te.subVectors(e, this.center); const t = te.lengthSq(); if (t > this.radius * this.radius) { const e = Math.sqrt(t), n = .5 * (e - this.radius); this.center.add(te.multiplyScalar(n / e)), this.radius += n } return this } union(e) { return ee.subVectors(e.center, this.center).normalize().multiplyScalar(e.radius), this.expandByPoint($.copy(e.center).add(ee)), this.expandByPoint($.copy(e.center).sub(ee)), this } equals(e) { return e.center.equals(this.center) && e.radius === this.radius } clone() { return (new this.constructor).copy(this) } } const ie = new O, re = new O, se = new O, oe = new O, ae = new O, le = new O, ce = new O; class Ae { constructor(e = new O, t = new O(0, 0, -1)) { this.origin = e, this.direction = t } set(e, t) { return this.origin.copy(e), this.direction.copy(t), this } copy(e) { return this.origin.copy(e.origin), this.direction.copy(e.direction), this } at(e, t) { return t.copy(this.direction).multiplyScalar(e).add(this.origin) } lookAt(e) { return this.direction.copy(e).sub(this.origin).normalize(), this } recast(e) { return this.origin.copy(this.at(e, ie)), this } closestPointToPoint(e, t) { t.subVectors(e, this.origin); const n = t.dot(this.direction); return n < 0 ? t.copy(this.origin) : t.copy(this.direction).multiplyScalar(n).add(this.origin) } distanceToPoint(e) { return Math.sqrt(this.distanceSqToPoint(e)) } distanceSqToPoint(e) { const t = ie.subVectors(e, this.origin).dot(this.direction); return t < 0 ? this.origin.distanceToSquared(e) : (ie.copy(this.direction).multiplyScalar(t).add(this.origin), ie.distanceToSquared(e)) } distanceSqToSegment(e, t, n, i) { re.copy(e).add(t).multiplyScalar(.5), se.copy(t).sub(e).normalize(), oe.copy(this.origin).sub(re); const r = .5 * e.distanceTo(t), s = -this.direction.dot(se), o = oe.dot(this.direction), a = -oe.dot(se), l = oe.lengthSq(), c = Math.abs(1 - s * s); let A, u, h, d; if (c > 0) if (A = s * a - o, u = s * o - a, d = r * c, A >= 0) if (u >= -d) if (u <= d) { const e = 1 / c; A *= e, u *= e, h = A * (A + s * u + 2 * o) + u * (s * A + u + 2 * a) + l } else u = r, A = Math.max(0, -(s * u + o)), h = -A * A + u * (u + 2 * a) + l; else u = -r, A = Math.max(0, -(s * u + o)), h = -A * A + u * (u + 2 * a) + l; else u <= -d ? (A = Math.max(0, -(-s * r + o)), u = A > 0 ? -r : Math.min(Math.max(-r, -a), r), h = -A * A + u * (u + 2 * a) + l) : u <= d ? (A = 0, u = Math.min(Math.max(-r, -a), r), h = u * (u + 2 * a) + l) : (A = Math.max(0, -(s * r + o)), u = A > 0 ? r : Math.min(Math.max(-r, -a), r), h = -A * A + u * (u + 2 * a) + l); else u = s > 0 ? -r : r, A = Math.max(0, -(s * u + o)), h = -A * A + u * (u + 2 * a) + l; return n && n.copy(this.direction).multiplyScalar(A).add(this.origin), i && i.copy(se).multiplyScalar(u).add(re), h } intersectSphere(e, t) { ie.subVectors(e.center, this.origin); const n = ie.dot(this.direction), i = ie.dot(ie) - n * n, r = e.radius * e.radius; if (i > r) return null; const s = Math.sqrt(r - i), o = n - s, a = n + s; return o < 0 && a < 0 ? null : o < 0 ? this.at(a, t) : this.at(o, t) } intersectsSphere(e) { return this.distanceSqToPoint(e.center) <= e.radius * e.radius } distanceToPlane(e) { const t = e.normal.dot(this.direction); if (0 === t) return 0 === e.distanceToPoint(this.origin) ? 0 : null; const n = -(this.origin.dot(e.normal) + e.constant) / t; return n >= 0 ? n : null } intersectPlane(e, t) { const n = this.distanceToPlane(e); return null === n ? null : this.at(n, t) } intersectsPlane(e) { const t = e.distanceToPoint(this.origin); if (0 === t) return !0; return e.normal.dot(this.direction) * t < 0 } intersectBox(e, t) { let n, i, r, s, o, a; const l = 1 / this.direction.x, c = 1 / this.direction.y, A = 1 / this.direction.z, u = this.origin; return l >= 0 ? (n = (e.min.x - u.x) * l, i = (e.max.x - u.x) * l) : (n = (e.max.x - u.x) * l, i = (e.min.x - u.x) * l), c >= 0 ? (r = (e.min.y - u.y) * c, s = (e.max.y - u.y) * c) : (r = (e.max.y - u.y) * c, s = (e.min.y - u.y) * c), n > s || r > i ? null : ((r > n || n != n) && (n = r), (s < i || i != i) && (i = s), A >= 0 ? (o = (e.min.z - u.z) * A, a = (e.max.z - u.z) * A) : (o = (e.max.z - u.z) * A, a = (e.min.z - u.z) * A), n > a || o > i ? null : ((o > n || n != n) && (n = o), (a < i || i != i) && (i = a), i < 0 ? null : this.at(n >= 0 ? n : i, t))) } intersectsBox(e) { return null !== this.intersectBox(e, ie) } intersectTriangle(e, t, n, i, r) { ae.subVectors(t, e), le.subVectors(n, e), ce.crossVectors(ae, le); let s, o = this.direction.dot(ce); if (o > 0) { if (i) return null; s = 1 } else { if (!(o < 0)) return null; s = -1, o = -o } oe.subVectors(this.origin, e); const a = s * this.direction.dot(le.crossVectors(oe, le)); if (a < 0) return null; const l = s * this.direction.dot(ae.cross(oe)); if (l < 0) return null; if (a + l > o) return null; const c = -s * oe.dot(ce); return c < 0 ? null : this.at(c / o, r) } applyMatrix4(e) { return this.origin.applyMatrix4(e), this.direction.transformDirection(e), this } equals(e) { return e.origin.equals(this.origin) && e.direction.equals(this.direction) } clone() { return (new this.constructor).copy(this) } } class ue { constructor() { this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], arguments.length > 0 && console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.") } set(e, t, n, i, r, s, o, a, l, c, A, u, h, d, p, f) { const g = this.elements; return g[0] = e, g[4] = t, g[8] = n, g[12] = i, g[1] = r, g[5] = s, g[9] = o, g[13] = a, g[2] = l, g[6] = c, g[10] = A, g[14] = u, g[3] = h, g[7] = d, g[11] = p, g[15] = f, this } identity() { return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this } clone() { return (new ue).fromArray(this.elements) } copy(e) { const t = this.elements, n = e.elements; return t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], t[4] = n[4], t[5] = n[5], t[6] = n[6], t[7] = n[7], t[8] = n[8], t[9] = n[9], t[10] = n[10], t[11] = n[11], t[12] = n[12], t[13] = n[13], t[14] = n[14], t[15] = n[15], this } copyPosition(e) { const t = this.elements, n = e.elements; return t[12] = n[12], t[13] = n[13], t[14] = n[14], this } setFromMatrix3(e) { const t = e.elements; return this.set(t[0], t[3], t[6], 0, t[1], t[4], t[7], 0, t[2], t[5], t[8], 0, 0, 0, 0, 1), this } extractBasis(e, t, n) { return e.setFromMatrixColumn(this, 0), t.setFromMatrixColumn(this, 1), n.setFromMatrixColumn(this, 2), this } makeBasis(e, t, n) { return this.set(e.x, t.x, n.x, 0, e.y, t.y, n.y, 0, e.z, t.z, n.z, 0, 0, 0, 0, 1), this } extractRotation(e) { const t = this.elements, n = e.elements, i = 1 / he.setFromMatrixColumn(e, 0).length(), r = 1 / he.setFromMatrixColumn(e, 1).length(), s = 1 / he.setFromMatrixColumn(e, 2).length(); return t[0] = n[0] * i, t[1] = n[1] * i, t[2] = n[2] * i, t[3] = 0, t[4] = n[4] * r, t[5] = n[5] * r, t[6] = n[6] * r, t[7] = 0, t[8] = n[8] * s, t[9] = n[9] * s, t[10] = n[10] * s, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this } makeRotationFromEuler(e) { e && e.isEuler || console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order."); const t = this.elements, n = e.x, i = e.y, r = e.z, s = Math.cos(n), o = Math.sin(n), a = Math.cos(i), l = Math.sin(i), c = Math.cos(r), A = Math.sin(r); if ("XYZ" === e.order) { const e = s * c, n = s * A, i = o * c, r = o * A; t[0] = a * c, t[4] = -a * A, t[8] = l, t[1] = n + i * l, t[5] = e - r * l, t[9] = -o * a, t[2] = r - e * l, t[6] = i + n * l, t[10] = s * a } else if ("YXZ" === e.order) { const e = a * c, n = a * A, i = l * c, r = l * A; t[0] = e + r * o, t[4] = i * o - n, t[8] = s * l, t[1] = s * A, t[5] = s * c, t[9] = -o, t[2] = n * o - i, t[6] = r + e * o, t[10] = s * a } else if ("ZXY" === e.order) { const e = a * c, n = a * A, i = l * c, r = l * A; t[0] = e - r * o, t[4] = -s * A, t[8] = i + n * o, t[1] = n + i * o, t[5] = s * c, t[9] = r - e * o, t[2] = -s * l, t[6] = o, t[10] = s * a } else if ("ZYX" === e.order) { const e = s * c, n = s * A, i = o * c, r = o * A; t[0] = a * c, t[4] = i * l - n, t[8] = e * l + r, t[1] = a * A, t[5] = r * l + e, t[9] = n * l - i, t[2] = -l, t[6] = o * a, t[10] = s * a } else if ("YZX" === e.order) { const e = s * a, n = s * l, i = o * a, r = o * l; t[0] = a * c, t[4] = r - e * A, t[8] = i * A + n, t[1] = A, t[5] = s * c, t[9] = -o * c, t[2] = -l * c, t[6] = n * A + i, t[10] = e - r * A } else if ("XZY" === e.order) { const e = s * a, n = s * l, i = o * a, r = o * l; t[0] = a * c, t[4] = -A, t[8] = l * c, t[1] = e * A + r, t[5] = s * c, t[9] = n * A - i, t[2] = i * A - n, t[6] = o * c, t[10] = r * A + e } return t[3] = 0, t[7] = 0, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this } makeRotationFromQuaternion(e) { return this.compose(pe, e, fe) } lookAt(e, t, n) { const i = this.elements; return ve.subVectors(e, t), 0 === ve.lengthSq() && (ve.z = 1), ve.normalize(), ge.crossVectors(n, ve), 0 === ge.lengthSq() && (1 === Math.abs(n.z) ? ve.x += 1e-4 : ve.z += 1e-4, ve.normalize(), ge.crossVectors(n, ve)), ge.normalize(), me.crossVectors(ve, ge), i[0] = ge.x, i[4] = me.x, i[8] = ve.x, i[1] = ge.y, i[5] = me.y, i[9] = ve.y, i[2] = ge.z, i[6] = me.z, i[10] = ve.z, this } multiply(e, t) { return void 0 !== t ? (console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."), this.multiplyMatrices(e, t)) : this.multiplyMatrices(this, e) } premultiply(e) { return this.multiplyMatrices(e, this) } multiplyMatrices(e, t) { const n = e.elements, i = t.elements, r = this.elements, s = n[0], o = n[4], a = n[8], l = n[12], c = n[1], A = n[5], u = n[9], h = n[13], d = n[2], p = n[6], f = n[10], g = n[14], m = n[3], v = n[7], y = n[11], w = n[15], x = i[0], C = i[4], b = i[8], M = i[12], I = i[1], E = i[5], T = i[9], P = i[13], S = i[2], B = i[6], D = i[10], R = i[14], L = i[3], O = i[7], N = i[11], k = i[15]; return r[0] = s * x + o * I + a * S + l * L, r[4] = s * C + o * E + a * B + l * O, r[8] = s * b + o * T + a * D + l * N, r[12] = s * M + o * P + a * R + l * k, r[1] = c * x + A * I + u * S + h * L, r[5] = c * C + A * E + u * B + h * O, r[9] = c * b + A * T + u * D + h * N, r[13] = c * M + A * P + u * R + h * k, r[2] = d * x + p * I + f * S + g * L, r[6] = d * C + p * E + f * B + g * O, r[10] = d * b + p * T + f * D + g * N, r[14] = d * M + p * P + f * R + g * k, r[3] = m * x + v * I + y * S + w * L, r[7] = m * C + v * E + y * B + w * O, r[11] = m * b + v * T + y * D + w * N, r[15] = m * M + v * P + y * R + w * k, this } multiplyScalar(e) { const t = this.elements; return t[0] *= e, t[4] *= e, t[8] *= e, t[12] *= e, t[1] *= e, t[5] *= e, t[9] *= e, t[13] *= e, t[2] *= e, t[6] *= e, t[10] *= e, t[14] *= e, t[3] *= e, t[7] *= e, t[11] *= e, t[15] *= e, this } determinant() { const e = this.elements, t = e[0], n = e[4], i = e[8], r = e[12], s = e[1], o = e[5], a = e[9], l = e[13], c = e[2], A = e[6], u = e[10], h = e[14]; return e[3] * (+r * a * A - i * l * A - r * o * u + n * l * u + i * o * h - n * a * h) + e[7] * (+t * a * h - t * l * u + r * s * u - i * s * h + i * l * c - r * a * c) + e[11] * (+t * l * A - t * o * h - r * s * A + n * s * h + r * o * c - n * l * c) + e[15] * (-i * o * c - t * a * A + t * o * u + i * s * A - n * s * u + n * a * c) } transpose() { const e = this.elements; let t; return t = e[1], e[1] = e[4], e[4] = t, t = e[2], e[2] = e[8], e[8] = t, t = e[6], e[6] = e[9], e[9] = t, t = e[3], e[3] = e[12], e[12] = t, t = e[7], e[7] = e[13], e[13] = t, t = e[11], e[11] = e[14], e[14] = t, this } setPosition(e, t, n) { const i = this.elements; return e.isVector3 ? (i[12] = e.x, i[13] = e.y, i[14] = e.z) : (i[12] = e, i[13] = t, i[14] = n), this } invert() { const e = this.elements, t = e[0], n = e[1], i = e[2], r = e[3], s = e[4], o = e[5], a = e[6], l = e[7], c = e[8], A = e[9], u = e[10], h = e[11], d = e[12], p = e[13], f = e[14], g = e[15], m = A * f * l - p * u * l + p * a * h - o * f * h - A * a * g + o * u * g, v = d * u * l - c * f * l - d * a * h + s * f * h + c * a * g - s * u * g, y = c * p * l - d * A * l + d * o * h - s * p * h - c * o * g + s * A * g, w = d * A * a - c * p * a - d * o * u + s * p * u + c * o * f - s * A * f, x = t * m + n * v + i * y + r * w; if (0 === x) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0); const C = 1 / x; return e[0] = m * C, e[1] = (p * u * r - A * f * r - p * i * h + n * f * h + A * i * g - n * u * g) * C, e[2] = (o * f * r - p * a * r + p * i * l - n * f * l - o * i * g + n * a * g) * C, e[3] = (A * a * r - o * u * r - A * i * l + n * u * l + o * i * h - n * a * h) * C, e[4] = v * C, e[5] = (c * f * r - d * u * r + d * i * h - t * f * h - c * i * g + t * u * g) * C, e[6] = (d * a * r - s * f * r - d * i * l + t * f * l + s * i * g - t * a * g) * C, e[7] = (s * u * r - c * a * r + c * i * l - t * u * l - s * i * h + t * a * h) * C, e[8] = y * C, e[9] = (d * A * r - c * p * r - d * n * h + t * p * h + c * n * g - t * A * g) * C, e[10] = (s * p * r - d * o * r + d * n * l - t * p * l - s * n * g + t * o * g) * C, e[11] = (c * o * r - s * A * r - c * n * l + t * A * l + s * n * h - t * o * h) * C, e[12] = w * C, e[13] = (c * p * i - d * A * i + d * n * u - t * p * u - c * n * f + t * A * f) * C, e[14] = (d * o * i - s * p * i - d * n * a + t * p * a + s * n * f - t * o * f) * C, e[15] = (s * A * i - c * o * i + c * n * a - t * A * a - s * n * u + t * o * u) * C, this } scale(e) { const t = this.elements, n = e.x, i = e.y, r = e.z; return t[0] *= n, t[4] *= i, t[8] *= r, t[1] *= n, t[5] *= i, t[9] *= r, t[2] *= n, t[6] *= i, t[10] *= r, t[3] *= n, t[7] *= i, t[11] *= r, this } getMaxScaleOnAxis() { const e = this.elements, t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2], n = e[4] * e[4] + e[5] * e[5] + e[6] * e[6], i = e[8] * e[8] + e[9] * e[9] + e[10] * e[10]; return Math.sqrt(Math.max(t, n, i)) } makeTranslation(e, t, n) { return this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, n, 0, 0, 0, 1), this } makeRotationX(e) { const t = Math.cos(e), n = Math.sin(e); return this.set(1, 0, 0, 0, 0, t, -n, 0, 0, n, t, 0, 0, 0, 0, 1), this } makeRotationY(e) { const t = Math.cos(e), n = Math.sin(e); return this.set(t, 0, n, 0, 0, 1, 0, 0, -n, 0, t, 0, 0, 0, 0, 1), this } makeRotationZ(e) { const t = Math.cos(e), n = Math.sin(e); return this.set(t, -n, 0, 0, n, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this } makeRotationAxis(e, t) { const n = Math.cos(t), i = Math.sin(t), r = 1 - n, s = e.x, o = e.y, a = e.z, l = r * s, c = r * o; return this.set(l * s + n, l * o - i * a, l * a + i * o, 0, l * o + i * a, c * o + n, c * a - i * s, 0, l * a - i * o, c * a + i * s, r * a * a + n, 0, 0, 0, 0, 1), this } makeScale(e, t, n) { return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this } makeShear(e, t, n, i, r, s) { return this.set(1, n, r, 0, e, 1, s, 0, t, i, 1, 0, 0, 0, 0, 1), this } compose(e, t, n) { const i = this.elements, r = t._x, s = t._y, o = t._z, a = t._w, l = r + r, c = s + s, A = o + o, u = r * l, h = r * c, d = r * A, p = s * c, f = s * A, g = o * A, m = a * l, v = a * c, y = a * A, w = n.x, x = n.y, C = n.z; return i[0] = (1 - (p + g)) * w, i[1] = (h + y) * w, i[2] = (d - v) * w, i[3] = 0, i[4] = (h - y) * x, i[5] = (1 - (u + g)) * x, i[6] = (f + m) * x, i[7] = 0, i[8] = (d + v) * C, i[9] = (f - m) * C, i[10] = (1 - (u + p)) * C, i[11] = 0, i[12] = e.x, i[13] = e.y, i[14] = e.z, i[15] = 1, this } decompose(e, t, n) { const i = this.elements; let r = he.set(i[0], i[1], i[2]).length(); const s = he.set(i[4], i[5], i[6]).length(), o = he.set(i[8], i[9], i[10]).length(); this.determinant() < 0 && (r = -r), e.x = i[12], e.y = i[13], e.z = i[14], de.copy(this); const a = 1 / r, l = 1 / s, c = 1 / o; return de.elements[0] *= a, de.elements[1] *= a, de.elements[2] *= a, de.elements[4] *= l, de.elements[5] *= l, de.elements[6] *= l, de.elements[8] *= c, de.elements[9] *= c, de.elements[10] *= c, t.setFromRotationMatrix(de), n.x = r, n.y = s, n.z = o, this } makePerspective(e, t, n, i, r, s) { void 0 === s && console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs."); const o = this.elements, a = 2 * r / (t - e), l = 2 * r / (n - i), c = (t + e) / (t - e), A = (n + i) / (n - i), u = -(s + r) / (s - r), h = -2 * s * r / (s - r); return o[0] = a, o[4] = 0, o[8] = c, o[12] = 0, o[1] = 0, o[5] = l, o[9] = A, o[13] = 0, o[2] = 0, o[6] = 0, o[10] = u, o[14] = h, o[3] = 0, o[7] = 0, o[11] = -1, o[15] = 0, this } makeOrthographic(e, t, n, i, r, s) { const o = this.elements, a = 1 / (t - e), l = 1 / (n - i), c = 1 / (s - r), A = (t + e) * a, u = (n + i) * l, h = (s + r) * c; return o[0] = 2 * a, o[4] = 0, o[8] = 0, o[12] = -A, o[1] = 0, o[5] = 2 * l, o[9] = 0, o[13] = -u, o[2] = 0, o[6] = 0, o[10] = -2 * c, o[14] = -h, o[3] = 0, o[7] = 0, o[11] = 0, o[15] = 1, this } equals(e) { const t = this.elements, n = e.elements; for (let e = 0; e < 16; e++)if (t[e] !== n[e]) return !1; return !0 } fromArray(e, t = 0) { for (let n = 0; n < 16; n++)this.elements[n] = e[n + t]; return this } toArray(e = [], t = 0) { const n = this.elements; return e[t] = n[0], e[t + 1] = n[1], e[t + 2] = n[2], e[t + 3] = n[3], e[t + 4] = n[4], e[t + 5] = n[5], e[t + 6] = n[6], e[t + 7] = n[7], e[t + 8] = n[8], e[t + 9] = n[9], e[t + 10] = n[10], e[t + 11] = n[11], e[t + 12] = n[12], e[t + 13] = n[13], e[t + 14] = n[14], e[t + 15] = n[15], e } } ue.prototype.isMatrix4 = !0; const he = new O, de = new ue, pe = new O(0, 0, 0), fe = new O(1, 1, 1), ge = new O, me = new O, ve = new O, ye = new ue, we = new L; class xe { constructor(e = 0, t = 0, n = 0, i = xe.DefaultOrder) { this._x = e, this._y = t, this._z = n, this._order = i } get x() { return this._x } set x(e) { this._x = e, this._onChangeCallback() } get y() { return this._y } set y(e) { this._y = e, this._onChangeCallback() } get z() { return this._z } set z(e) { this._z = e, this._onChangeCallback() } get order() { return this._order } set order(e) { this._order = e, this._onChangeCallback() } set(e, t, n, i = this._order) { return this._x = e, this._y = t, this._z = n, this._order = i, this._onChangeCallback(), this } clone() { return new this.constructor(this._x, this._y, this._z, this._order) } copy(e) { return this._x = e._x, this._y = e._y, this._z = e._z, this._order = e._order, this._onChangeCallback(), this } setFromRotationMatrix(e, t = this._order, n = !0) { const i = e.elements, r = i[0], s = i[4], o = i[8], a = i[1], l = i[5], c = i[9], A = i[2], u = i[6], h = i[10]; switch (t) { case "XYZ": this._y = Math.asin(g(o, -1, 1)), Math.abs(o) < .9999999 ? (this._x = Math.atan2(-c, h), this._z = Math.atan2(-s, r)) : (this._x = Math.atan2(u, l), this._z = 0); break; case "YXZ": this._x = Math.asin(-g(c, -1, 1)), Math.abs(c) < .9999999 ? (this._y = Math.atan2(o, h), this._z = Math.atan2(a, l)) : (this._y = Math.atan2(-A, r), this._z = 0); break; case "ZXY": this._x = Math.asin(g(u, -1, 1)), Math.abs(u) < .9999999 ? (this._y = Math.atan2(-A, h), this._z = Math.atan2(-s, l)) : (this._y = 0, this._z = Math.atan2(a, r)); break; case "ZYX": this._y = Math.asin(-g(A, -1, 1)), Math.abs(A) < .9999999 ? (this._x = Math.atan2(u, h), this._z = Math.atan2(a, r)) : (this._x = 0, this._z = Math.atan2(-s, l)); break; case "YZX": this._z = Math.asin(g(a, -1, 1)), Math.abs(a) < .9999999 ? (this._x = Math.atan2(-c, l), this._y = Math.atan2(-A, r)) : (this._x = 0, this._y = Math.atan2(o, h)); break; case "XZY": this._z = Math.asin(-g(s, -1, 1)), Math.abs(s) < .9999999 ? (this._x = Math.atan2(u, l), this._y = Math.atan2(o, r)) : (this._x = Math.atan2(-c, h), this._y = 0); break; default: console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + t) }return this._order = t, !0 === n && this._onChangeCallback(), this } setFromQuaternion(e, t, n) { return ye.makeRotationFromQuaternion(e), this.setFromRotationMatrix(ye, t, n) } setFromVector3(e, t = this._order) { return this.set(e.x, e.y, e.z, t) } reorder(e) { return we.setFromEuler(this), this.setFromQuaternion(we, e) } equals(e) { return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order } fromArray(e) { return this._x = e[0], this._y = e[1], this._z = e[2], void 0 !== e[3] && (this._order = e[3]), this._onChangeCallback(), this } toArray(e = [], t = 0) { return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._order, e } toVector3(e) { return e ? e.set(this._x, this._y, this._z) : new O(this._x, this._y, this._z) } _onChange(e) { return this._onChangeCallback = e, this } _onChangeCallback() { } } xe.prototype.isEuler = !0, xe.DefaultOrder = "XYZ", xe.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"]; class Ce { constructor() { this.mask = 1 } set(e) { this.mask = 1 << e | 0 } enable(e) { this.mask |= 1 << e | 0 } enableAll() { this.mask = -1 } toggle(e) { this.mask ^= 1 << e | 0 } disable(e) { this.mask &= ~(1 << e | 0) } disableAll() { this.mask = 0 } test(e) { return 0 != (this.mask & e.mask) } } let be = 0; const Me = new O, Ie = new L, Ee = new ue, Te = new O, Pe = new O, Se = new O, Be = new L, De = new O(1, 0, 0), Re = new O(0, 1, 0), Le = new O(0, 0, 1), Oe = { type: "added" }, Ne = { type: "removed" }; class ke extends A { constructor() { super(), Object.defineProperty(this, "id", { value: be++ }), this.uuid = f(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = ke.DefaultUp.clone(); const e = new O, t = new xe, n = new L, i = new O(1, 1, 1); t._onChange((function () { n.setFromEuler(t, !1) })), n._onChange((function () { t.setFromQuaternion(n, void 0, !1) })), Object.defineProperties(this, { position: { configurable: !0, enumerable: !0, value: e }, rotation: { configurable: !0, enumerable: !0, value: t }, quaternion: { configurable: !0, enumerable: !0, value: n }, scale: { configurable: !0, enumerable: !0, value: i }, modelViewMatrix: { value: new ue }, normalMatrix: { value: new M } }), this.matrix = new ue, this.matrixWorld = new ue, this.matrixAutoUpdate = ke.DefaultMatrixAutoUpdate, this.matrixWorldNeedsUpdate = !1, this.layers = new Ce, this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.animations = [], this.userData = {} } onBeforeRender() { } onAfterRender() { } applyMatrix4(e) { this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(e), this.matrix.decompose(this.position, this.quaternion, this.scale) } applyQuaternion(e) { return this.quaternion.premultiply(e), this } setRotationFromAxisAngle(e, t) { this.quaternion.setFromAxisAngle(e, t) } setRotationFromEuler(e) { this.quaternion.setFromEuler(e, !0) } setRotationFromMatrix(e) { this.quaternion.setFromRotationMatrix(e) } setRotationFromQuaternion(e) { this.quaternion.copy(e) } rotateOnAxis(e, t) { return Ie.setFromAxisAngle(e, t), this.quaternion.multiply(Ie), this } rotateOnWorldAxis(e, t) { return Ie.setFromAxisAngle(e, t), this.quaternion.premultiply(Ie), this } rotateX(e) { return this.rotateOnAxis(De, e) } rotateY(e) { return this.rotateOnAxis(Re, e) } rotateZ(e) { return this.rotateOnAxis(Le, e) } translateOnAxis(e, t) { return Me.copy(e).applyQuaternion(this.quaternion), this.position.add(Me.multiplyScalar(t)), this } translateX(e) { return this.translateOnAxis(De, e) } translateY(e) { return this.translateOnAxis(Re, e) } translateZ(e) { return this.translateOnAxis(Le, e) } localToWorld(e) { return e.applyMatrix4(this.matrixWorld) } worldToLocal(e) { return e.applyMatrix4(Ee.copy(this.matrixWorld).invert()) } lookAt(e, t, n) { e.isVector3 ? Te.copy(e) : Te.set(e, t, n); const i = this.parent; this.updateWorldMatrix(!0, !1), Pe.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? Ee.lookAt(Pe, Te, this.up) : Ee.lookAt(Te, Pe, this.up), this.quaternion.setFromRotationMatrix(Ee), i && (Ee.extractRotation(i.matrixWorld), Ie.setFromRotationMatrix(Ee), this.quaternion.premultiply(Ie.invert())) } add(e) { if (arguments.length > 1) { for (let e = 0; e < arguments.length; e++)this.add(arguments[e]); return this } return e === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", e), this) : (e && e.isObject3D ? (null !== e.parent && e.parent.remove(e), e.parent = this, this.children.push(e), e.dispatchEvent(Oe)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e), this) } remove(e) { if (arguments.length > 1) { for (let e = 0; e < arguments.length; e++)this.remove(arguments[e]); return this } const t = this.children.indexOf(e); return -1 !== t && (e.parent = null, this.children.splice(t, 1), e.dispatchEvent(Ne)), this } removeFromParent() { const e = this.parent; return null !== e && e.remove(this), this } clear() { for (let e = 0; e < this.children.length; e++) { const t = this.children[e]; t.parent = null, t.dispatchEvent(Ne) } return this.children.length = 0, this } attach(e) { return this.updateWorldMatrix(!0, !1), Ee.copy(this.matrixWorld).invert(), null !== e.parent && (e.parent.updateWorldMatrix(!0, !1), Ee.multiply(e.parent.matrixWorld)), e.applyMatrix4(Ee), this.add(e), e.updateWorldMatrix(!1, !0), this } getObjectById(e) { return this.getObjectByProperty("id", e) } getObjectByName(e) { return this.getObjectByProperty("name", e) } getObjectByProperty(e, t) { if (this[e] === t) return this; for (let n = 0, i = this.children.length; n < i; n++) { const i = this.children[n].getObjectByProperty(e, t); if (void 0 !== i) return i } } getWorldPosition(e) { return this.updateWorldMatrix(!0, !1), e.setFromMatrixPosition(this.matrixWorld) } getWorldQuaternion(e) { return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(Pe, e, Se), e } getWorldScale(e) { return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(Pe, Be, e), e } getWorldDirection(e) { this.updateWorldMatrix(!0, !1); const t = this.matrixWorld.elements; return e.set(t[8], t[9], t[10]).normalize() } raycast() { } traverse(e) { e(this); const t = this.children; for (let n = 0, i = t.length; n < i; n++)t[n].traverse(e) } traverseVisible(e) { if (!1 === this.visible) return; e(this); const t = this.children; for (let n = 0, i = t.length; n < i; n++)t[n].traverseVisible(e) } traverseAncestors(e) { const t = this.parent; null !== t && (e(t), t.traverseAncestors(e)) } updateMatrix() { this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0 } updateMatrixWorld(e) { this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || e) && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, e = !0); const t = this.children; for (let n = 0, i = t.length; n < i; n++)t[n].updateMatrixWorld(e) } updateWorldMatrix(e, t) { const n = this.parent; if (!0 === e && null !== n && n.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), !0 === t) { const e = this.children; for (let t = 0, n = e.length; t < n; t++)e[t].updateWorldMatrix(!1, !0) } } toJSON(e) { const t = void 0 === e || "string" == typeof e, n = {}; t && (e = { geometries: {}, materials: {}, textures: {}, images: {}, shapes: {}, skeletons: {}, animations: {} }, n.metadata = { version: 4.5, type: "Object", generator: "Object3D.toJSON" }); const i = {}; function r(t, n) { return void 0 === t[n.uuid] && (t[n.uuid] = n.toJSON(e)), n.uuid } if (i.uuid = this.uuid, i.type = this.type, "" !== this.name && (i.name = this.name), !0 === this.castShadow && (i.castShadow = !0), !0 === this.receiveShadow && (i.receiveShadow = !0), !1 === this.visible && (i.visible = !1), !1 === this.frustumCulled && (i.frustumCulled = !1), 0 !== this.renderOrder && (i.renderOrder = this.renderOrder), "{}" !== JSON.stringify(this.userData) && (i.userData = this.userData), i.layers = this.layers.mask, i.matrix = this.matrix.toArray(), !1 === this.matrixAutoUpdate && (i.matrixAutoUpdate = !1), this.isInstancedMesh && (i.type = "InstancedMesh", i.count = this.count, i.instanceMatrix = this.instanceMatrix.toJSON(), null !== this.instanceColor && (i.instanceColor = this.instanceColor.toJSON())), this.isScene) this.background && (this.background.isColor ? i.background = this.background.toJSON() : this.background.isTexture && (i.background = this.background.toJSON(e).uuid)), this.environment && this.environment.isTexture && (i.environment = this.environment.toJSON(e).uuid); else if (this.isMesh || this.isLine || this.isPoints) { i.geometry = r(e.geometries, this.geometry); const t = this.geometry.parameters; if (void 0 !== t && void 0 !== t.shapes) { const n = t.shapes; if (Array.isArray(n)) for (let t = 0, i = n.length; t < i; t++) { const i = n[t]; r(e.shapes, i) } else r(e.shapes, n) } } if (this.isSkinnedMesh && (i.bindMode = this.bindMode, i.bindMatrix = this.bindMatrix.toArray(), void 0 !== this.skeleton && (r(e.skeletons, this.skeleton), i.skeleton = this.skeleton.uuid)), void 0 !== this.material) if (Array.isArray(this.material)) { const t = []; for (let n = 0, i = this.material.length; n < i; n++)t.push(r(e.materials, this.material[n])); i.material = t } else i.material = r(e.materials, this.material); if (this.children.length > 0) { i.children = []; for (let t = 0; t < this.children.length; t++)i.children.push(this.children[t].toJSON(e).object) } if (this.animations.length > 0) { i.animations = []; for (let t = 0; t < this.animations.length; t++) { const n = this.animations[t]; i.animations.push(r(e.animations, n)) } } if (t) { const t = s(e.geometries), i = s(e.materials), r = s(e.textures), o = s(e.images), a = s(e.shapes), l = s(e.skeletons), c = s(e.animations); t.length > 0 && (n.geometries = t), i.length > 0 && (n.materials = i), r.length > 0 && (n.textures = r), o.length > 0 && (n.images = o), a.length > 0 && (n.shapes = a), l.length > 0 && (n.skeletons = l), c.length > 0 && (n.animations = c) } return n.object = i, n; function s(e) { const t = []; for (const n in e) { const i = e[n]; delete i.metadata, t.push(i) } return t } } clone(e) { return (new this.constructor).copy(this, e) } copy(e, t = !0) { if (this.name = e.name, this.up.copy(e.up), this.position.copy(e.position), this.rotation.order = e.rotation.order, this.quaternion.copy(e.quaternion), this.scale.copy(e.scale), this.matrix.copy(e.matrix), this.matrixWorld.copy(e.matrixWorld), this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate, this.layers.mask = e.layers.mask, this.visible = e.visible, this.castShadow = e.castShadow, this.receiveShadow = e.receiveShadow, this.frustumCulled = e.frustumCulled, this.renderOrder = e.renderOrder, this.userData = JSON.parse(JSON.stringify(e.userData)), !0 === t) for (let t = 0; t < e.children.length; t++) { const n = e.children[t]; this.add(n.clone()) } return this } } ke.DefaultUp = new O(0, 1, 0), ke.DefaultMatrixAutoUpdate = !0, ke.prototype.isObject3D = !0; const He = new O, ze = new O, Fe = new O, Qe = new O, Ge = new O, je = new O, Ue = new O, Ve = new O, Ye = new O, We = new O; class Xe { constructor(e = new O, t = new O, n = new O) { this.a = e, this.b = t, this.c = n } static getNormal(e, t, n, i) { i.subVectors(n, t), He.subVectors(e, t), i.cross(He); const r = i.lengthSq(); return r > 0 ? i.multiplyScalar(1 / Math.sqrt(r)) : i.set(0, 0, 0) } static getBarycoord(e, t, n, i, r) { He.subVectors(i, t), ze.subVectors(n, t), Fe.subVectors(e, t); const s = He.dot(He), o = He.dot(ze), a = He.dot(Fe), l = ze.dot(ze), c = ze.dot(Fe), A = s * l - o * o; if (0 === A) return r.set(-2, -1, -1); const u = 1 / A, h = (l * a - o * c) * u, d = (s * c - o * a) * u; return r.set(1 - h - d, d, h) } static containsPoint(e, t, n, i) { return this.getBarycoord(e, t, n, i, Qe), Qe.x >= 0 && Qe.y >= 0 && Qe.x + Qe.y <= 1 } static getUV(e, t, n, i, r, s, o, a) { return this.getBarycoord(e, t, n, i, Qe), a.set(0, 0), a.addScaledVector(r, Qe.x), a.addScaledVector(s, Qe.y), a.addScaledVector(o, Qe.z), a } static isFrontFacing(e, t, n, i) { return He.subVectors(n, t), ze.subVectors(e, t), He.cross(ze).dot(i) < 0 } set(e, t, n) { return this.a.copy(e), this.b.copy(t), this.c.copy(n), this } setFromPointsAndIndices(e, t, n, i) { return this.a.copy(e[t]), this.b.copy(e[n]), this.c.copy(e[i]), this } clone() { return (new this.constructor).copy(this) } copy(e) { return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this } getArea() { return He.subVectors(this.c, this.b), ze.subVectors(this.a, this.b), .5 * He.cross(ze).length() } getMidpoint(e) { return e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3) } getNormal(e) { return Xe.getNormal(this.a, this.b, this.c, e) } getPlane(e) { return e.setFromCoplanarPoints(this.a, this.b, this.c) } getBarycoord(e, t) { return Xe.getBarycoord(e, this.a, this.b, this.c, t) } getUV(e, t, n, i, r) { return Xe.getUV(e, this.a, this.b, this.c, t, n, i, r) } containsPoint(e) { return Xe.containsPoint(e, this.a, this.b, this.c) } isFrontFacing(e) { return Xe.isFrontFacing(this.a, this.b, this.c, e) } intersectsBox(e) { return e.intersectsTriangle(this) } closestPointToPoint(e, t) { const n = this.a, i = this.b, r = this.c; let s, o; Ge.subVectors(i, n), je.subVectors(r, n), Ve.subVectors(e, n); const a = Ge.dot(Ve), l = je.dot(Ve); if (a <= 0 && l <= 0) return t.copy(n); Ye.subVectors(e, i); const c = Ge.dot(Ye), A = je.dot(Ye); if (c >= 0 && A <= c) return t.copy(i); const u = a * A - c * l; if (u <= 0 && a >= 0 && c <= 0) return s = a / (a - c), t.copy(n).addScaledVector(Ge, s); We.subVectors(e, r); const h = Ge.dot(We), d = je.dot(We); if (d >= 0 && h <= d) return t.copy(r); const p = h * l - a * d; if (p <= 0 && l >= 0 && d <= 0) return o = l / (l - d), t.copy(n).addScaledVector(je, o); const f = c * d - h * A; if (f <= 0 && A - c >= 0 && h - d >= 0) return Ue.subVectors(r, i), o = (A - c) / (A - c + (h - d)), t.copy(i).addScaledVector(Ue, o); const g = 1 / (f + p + u); return s = p * g, o = u * g, t.copy(n).addScaledVector(Ge, s).addScaledVector(je, o) } equals(e) { return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c) } } let Je = 0; class Ke extends A { constructor() { super(), Object.defineProperty(this, "id", { value: Je++ }), this.uuid = f(), this.name = "", this.type = "Material", this.fog = !0, this.blending = 1, this.side = 0, this.vertexColors = !1, this.opacity = 1, this.transparent = !1, this.blendSrc = 204, this.blendDst = 205, this.blendEquation = 100, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.depthFunc = 3, this.depthTest = !0, this.depthWrite = !0, this.stencilWriteMask = 255, this.stencilFunc = 519, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = 7680, this.stencilZFail = 7680, this.stencilZPass = 7680, this.stencilWrite = !1, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaTest = 0, this.alphaToCoverage = !1, this.premultipliedAlpha = !1, this.visible = !0, this.toneMapped = !0, this.userData = {}, this.version = 0 } onBuild() { } onBeforeCompile() { } customProgramCacheKey() { return this.onBeforeCompile.toString() } setValues(e) { if (void 0 !== e) for (const t in e) { const n = e[t]; if (void 0 === n) { console.warn("THREE.Material: '" + t + "' parameter is undefined."); continue } if ("shading" === t) { console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = 1 === n; continue } const i = this[t]; void 0 !== i ? i && i.isColor ? i.set(n) : i && i.isVector3 && n && n.isVector3 ? i.copy(n) : this[t] = n : console.warn("THREE." + this.type + ": '" + t + "' is not a property of this material.") } } toJSON(e) { const t = void 0 === e || "string" == typeof e; t && (e = { textures: {}, images: {} }); const n = { metadata: { version: 4.5, type: "Material", generator: "Material.toJSON" } }; function i(e) { const t = []; for (const n in e) { const i = e[n]; delete i.metadata, t.push(i) } return t } if (n.uuid = this.uuid, n.type = this.type, "" !== this.name && (n.name = this.name), this.color && this.color.isColor && (n.color = this.color.getHex()), void 0 !== this.roughness && (n.roughness = this.roughness), void 0 !== this.metalness && (n.metalness = this.metalness), this.sheen && this.sheen.isColor && (n.sheen = this.sheen.getHex()), this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()), this.emissiveIntensity && 1 !== this.emissiveIntensity && (n.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (n.specular = this.specular.getHex()), void 0 !== this.shininess && (n.shininess = this.shininess), void 0 !== this.clearcoat && (n.clearcoat = this.clearcoat), void 0 !== this.clearcoatRoughness && (n.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (n.clearcoatMap = this.clearcoatMap.toJSON(e).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (n.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid, n.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.map && this.map.isTexture && (n.map = this.map.toJSON(e).uuid), this.matcap && this.matcap.isTexture && (n.matcap = this.matcap.toJSON(e).uuid), this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(e).uuid), this.lightMap && this.lightMap.isTexture && (n.lightMap = this.lightMap.toJSON(e).uuid, n.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (n.aoMap = this.aoMap.toJSON(e).uuid, n.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (n.bumpMap = this.bumpMap.toJSON(e).uuid, n.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (n.normalMap = this.normalMap.toJSON(e).uuid, n.normalMapType = this.normalMapType, n.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (n.displacementMap = this.displacementMap.toJSON(e).uuid, n.displacementScale = this.displacementScale, n.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (n.roughnessMap = this.roughnessMap.toJSON(e).uuid), this.metalnessMap && this.metalnessMap.isTexture && (n.metalnessMap = this.metalnessMap.toJSON(e).uuid), this.emissiveMap && this.emissiveMap.isTexture && (n.emissiveMap = this.emissiveMap.toJSON(e).uuid), this.specularMap && this.specularMap.isTexture && (n.specularMap = this.specularMap.toJSON(e).uuid), this.envMap && this.envMap.isTexture && (n.envMap = this.envMap.toJSON(e).uuid, void 0 !== this.combine && (n.combine = this.combine)), void 0 !== this.envMapIntensity && (n.envMapIntensity = this.envMapIntensity), void 0 !== this.reflectivity && (n.reflectivity = this.reflectivity), void 0 !== this.refractionRatio && (n.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (n.gradientMap = this.gradientMap.toJSON(e).uuid), void 0 !== this.transmission && (n.transmission = this.transmission), this.transmissionMap && this.transmissionMap.isTexture && (n.transmissionMap = this.transmissionMap.toJSON(e).uuid), void 0 !== this.thickness && (n.thickness = this.thickness), this.thicknessMap && this.thicknessMap.isTexture && (n.thicknessMap = this.thicknessMap.toJSON(e).uuid), void 0 !== this.attenuationDistance && (n.attenuationDistance = this.attenuationDistance), void 0 !== this.attenuationColor && (n.attenuationColor = this.attenuationColor.getHex()), void 0 !== this.size && (n.size = this.size), null !== this.shadowSide && (n.shadowSide = this.shadowSide), void 0 !== this.sizeAttenuation && (n.sizeAttenuation = this.sizeAttenuation), 1 !== this.blending && (n.blending = this.blending), 0 !== this.side && (n.side = this.side), this.vertexColors && (n.vertexColors = !0), this.opacity < 1 && (n.opacity = this.opacity), !0 === this.transparent && (n.transparent = this.transparent), n.depthFunc = this.depthFunc, n.depthTest = this.depthTest, n.depthWrite = this.depthWrite, n.colorWrite = this.colorWrite, n.stencilWrite = this.stencilWrite, n.stencilWriteMask = this.stencilWriteMask, n.stencilFunc = this.stencilFunc, n.stencilRef = this.stencilRef, n.stencilFuncMask = this.stencilFuncMask, n.stencilFail = this.stencilFail, n.stencilZFail = this.stencilZFail, n.stencilZPass = this.stencilZPass, this.rotation && 0 !== this.rotation && (n.rotation = this.rotation), !0 === this.polygonOffset && (n.polygonOffset = !0), 0 !== this.polygonOffsetFactor && (n.polygonOffsetFactor = this.polygonOffsetFactor), 0 !== this.polygonOffsetUnits && (n.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth && 1 !== this.linewidth && (n.linewidth = this.linewidth), void 0 !== this.dashSize && (n.dashSize = this.dashSize), void 0 !== this.gapSize && (n.gapSize = this.gapSize), void 0 !== this.scale && (n.scale = this.scale), !0 === this.dithering && (n.dithering = !0), this.alphaTest > 0 && (n.alphaTest = this.alphaTest), !0 === this.alphaToCoverage && (n.alphaToCoverage = this.alphaToCoverage), !0 === this.premultipliedAlpha && (n.premultipliedAlpha = this.premultipliedAlpha), !0 === this.wireframe && (n.wireframe = this.wireframe), this.wireframeLinewidth > 1 && (n.wireframeLinewidth = this.wireframeLinewidth), "round" !== this.wireframeLinecap && (n.wireframeLinecap = this.wireframeLinecap), "round" !== this.wireframeLinejoin && (n.wireframeLinejoin = this.wireframeLinejoin), !0 === this.morphTargets && (n.morphTargets = !0), !0 === this.morphNormals && (n.morphNormals = !0), !0 === this.flatShading && (n.flatShading = this.flatShading), !1 === this.visible && (n.visible = !1), !1 === this.toneMapped && (n.toneMapped = !1), "{}" !== JSON.stringify(this.userData) && (n.userData = this.userData), t) { const t = i(e.textures), r = i(e.images); t.length > 0 && (n.textures = t), r.length > 0 && (n.images = r) } return n } clone() { return (new this.constructor).copy(this) } copy(e) { this.name = e.name, this.fog = e.fog, this.blending = e.blending, this.side = e.side, this.vertexColors = e.vertexColors, this.opacity = e.opacity, this.transparent = e.transparent, this.blendSrc = e.blendSrc, this.blendDst = e.blendDst, this.blendEquation = e.blendEquation, this.blendSrcAlpha = e.blendSrcAlpha, this.blendDstAlpha = e.blendDstAlpha, this.blendEquationAlpha = e.blendEquationAlpha, this.depthFunc = e.depthFunc, this.depthTest = e.depthTest, this.depthWrite = e.depthWrite, this.stencilWriteMask = e.stencilWriteMask, this.stencilFunc = e.stencilFunc, this.stencilRef = e.stencilRef, this.stencilFuncMask = e.stencilFuncMask, this.stencilFail = e.stencilFail, this.stencilZFail = e.stencilZFail, this.stencilZPass = e.stencilZPass, this.stencilWrite = e.stencilWrite; const t = e.clippingPlanes; let n = null; if (null !== t) { const e = t.length; n = new Array(e); for (let i = 0; i !== e; ++i)n[i] = t[i].clone() } return this.clippingPlanes = n, this.clipIntersection = e.clipIntersection, this.clipShadows = e.clipShadows, this.shadowSide = e.shadowSide, this.colorWrite = e.colorWrite, this.precision = e.precision, this.polygonOffset = e.polygonOffset, this.polygonOffsetFactor = e.polygonOffsetFactor, this.polygonOffsetUnits = e.polygonOffsetUnits, this.dithering = e.dithering, this.alphaTest = e.alphaTest, this.alphaToCoverage = e.alphaToCoverage, this.premultipliedAlpha = e.premultipliedAlpha, this.visible = e.visible, this.toneMapped = e.toneMapped, this.userData = JSON.parse(JSON.stringify(e.userData)), this } dispose() { this.dispatchEvent({ type: "dispose" }) } set needsUpdate(e) { !0 === e && this.version++ } } Ke.prototype.isMaterial = !0; const Ze = { aliceblue: 15792383, antiquewhite: 16444375, aqua: 65535, aquamarine: 8388564, azure: 15794175, beige: 16119260, bisque: 16770244, black: 0, blanchedalmond: 16772045, blue: 255, blueviolet: 9055202, brown: 10824234, burlywood: 14596231, cadetblue: 6266528, chartreuse: 8388352, chocolate: 13789470, coral: 16744272, cornflowerblue: 6591981, cornsilk: 16775388, crimson: 14423100, cyan: 65535, darkblue: 139, darkcyan: 35723, darkgoldenrod: 12092939, darkgray: 11119017, darkgreen: 25600, darkgrey: 11119017, darkkhaki: 12433259, darkmagenta: 9109643, darkolivegreen: 5597999, darkorange: 16747520, darkorchid: 10040012, darkred: 9109504, darksalmon: 15308410, darkseagreen: 9419919, darkslateblue: 4734347, darkslategray: 3100495, darkslategrey: 3100495, darkturquoise: 52945, darkviolet: 9699539, deeppink: 16716947, deepskyblue: 49151, dimgray: 6908265, dimgrey: 6908265, dodgerblue: 2003199, firebrick: 11674146, floralwhite: 16775920, forestgreen: 2263842, fuchsia: 16711935, gainsboro: 14474460, ghostwhite: 16316671, gold: 16766720, goldenrod: 14329120, gray: 8421504, green: 32768, greenyellow: 11403055, grey: 8421504, honeydew: 15794160, hotpink: 16738740, indianred: 13458524, indigo: 4915330, ivory: 16777200, khaki: 15787660, lavender: 15132410, lavenderblush: 16773365, lawngreen: 8190976, lemonchiffon: 16775885, lightblue: 11393254, lightcoral: 15761536, lightcyan: 14745599, lightgoldenrodyellow: 16448210, lightgray: 13882323, lightgreen: 9498256, lightgrey: 13882323, lightpink: 16758465, lightsalmon: 16752762, lightseagreen: 2142890, lightskyblue: 8900346, lightslategray: 7833753, lightslategrey: 7833753, lightsteelblue: 11584734, lightyellow: 16777184, lime: 65280, limegreen: 3329330, linen: 16445670, magenta: 16711935, maroon: 8388608, mediumaquamarine: 6737322, mediumblue: 205, mediumorchid: 12211667, mediumpurple: 9662683, mediumseagreen: 3978097, mediumslateblue: 8087790, mediumspringgreen: 64154, mediumturquoise: 4772300, mediumvioletred: 13047173, midnightblue: 1644912, mintcream: 16121850, mistyrose: 16770273, moccasin: 16770229, navajowhite: 16768685, navy: 128, oldlace: 16643558, olive: 8421376, olivedrab: 7048739, orange: 16753920, orangered: 16729344, orchid: 14315734, palegoldenrod: 15657130, palegreen: 10025880, paleturquoise: 11529966, palevioletred: 14381203, papayawhip: 16773077, peachpuff: 16767673, peru: 13468991, pink: 16761035, plum: 14524637, powderblue: 11591910, purple: 8388736, rebeccapurple: 6697881, red: 16711680, rosybrown: 12357519, royalblue: 4286945, saddlebrown: 9127187, salmon: 16416882, sandybrown: 16032864, seagreen: 3050327, seashell: 16774638, sienna: 10506797, silver: 12632256, skyblue: 8900331, slateblue: 6970061, slategray: 7372944, slategrey: 7372944, snow: 16775930, springgreen: 65407, steelblue: 4620980, tan: 13808780, teal: 32896, thistle: 14204888, tomato: 16737095, turquoise: 4251856, violet: 15631086, wheat: 16113331, white: 16777215, whitesmoke: 16119285, yellow: 16776960, yellowgreen: 10145074 }, qe = { h: 0, s: 0, l: 0 }, _e = { h: 0, s: 0, l: 0 }; function $e(e, t, n) { return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? e + 6 * (t - e) * n : n < .5 ? t : n < 2 / 3 ? e + 6 * (t - e) * (2 / 3 - n) : e } function et(e) { return e < .04045 ? .0773993808 * e : Math.pow(.9478672986 * e + .0521327014, 2.4) } function tt(e) { return e < .0031308 ? 12.92 * e : 1.055 * Math.pow(e, .41666) - .055 } class nt { constructor(e, t, n) { return void 0 === t && void 0 === n ? this.set(e) : this.setRGB(e, t, n) } set(e) { return e && e.isColor ? this.copy(e) : "number" == typeof e ? this.setHex(e) : "string" == typeof e && this.setStyle(e), this } setScalar(e) { return this.r = e, this.g = e, this.b = e, this } setHex(e) { return e = Math.floor(e), this.r = (e >> 16 & 255) / 255, this.g = (e >> 8 & 255) / 255, this.b = (255 & e) / 255, this } setRGB(e, t, n) { return this.r = e, this.g = t, this.b = n, this } setHSL(e, t, n) { if (e = m(e, 1), t = g(t, 0, 1), n = g(n, 0, 1), 0 === t) this.r = this.g = this.b = n; else { const i = n <= .5 ? n * (1 + t) : n + t - n * t, r = 2 * n - i; this.r = $e(r, i, e + 1 / 3), this.g = $e(r, i, e), this.b = $e(r, i, e - 1 / 3) } return this } setStyle(e) { function t(t) { void 0 !== t && parseFloat(t) < 1 && console.warn("THREE.Color: Alpha component of " + e + " will be ignored.") } let n; if (n = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(e)) { let e; const i = n[1], r = n[2]; switch (i) { case "rgb": case "rgba": if (e = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(r)) return this.r = Math.min(255, parseInt(e[1], 10)) / 255, this.g = Math.min(255, parseInt(e[2], 10)) / 255, this.b = Math.min(255, parseInt(e[3], 10)) / 255, t(e[4]), this; if (e = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(r)) return this.r = Math.min(100, parseInt(e[1], 10)) / 100, this.g = Math.min(100, parseInt(e[2], 10)) / 100, this.b = Math.min(100, parseInt(e[3], 10)) / 100, t(e[4]), this; break; case "hsl": case "hsla": if (e = /^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(r)) { const n = parseFloat(e[1]) / 360, i = parseInt(e[2], 10) / 100, r = parseInt(e[3], 10) / 100; return t(e[4]), this.setHSL(n, i, r) } } } else if (n = /^\#([A-Fa-f\d]+)$/.exec(e)) { const e = n[1], t = e.length; if (3 === t) return this.r = parseInt(e.charAt(0) + e.charAt(0), 16) / 255, this.g = parseInt(e.charAt(1) + e.charAt(1), 16) / 255, this.b = parseInt(e.charAt(2) + e.charAt(2), 16) / 255, this; if (6 === t) return this.r = parseInt(e.charAt(0) + e.charAt(1), 16) / 255, this.g = parseInt(e.charAt(2) + e.charAt(3), 16) / 255, this.b = parseInt(e.charAt(4) + e.charAt(5), 16) / 255, this } return e && e.length > 0 ? this.setColorName(e) : this } setColorName(e) { const t = Ze[e.toLowerCase()]; return void 0 !== t ? this.setHex(t) : console.warn("THREE.Color: Unknown color " + e), this } clone() { return new this.constructor(this.r, this.g, this.b) } copy(e) { return this.r = e.r, this.g = e.g, this.b = e.b, this } copyGammaToLinear(e, t = 2) { return this.r = Math.pow(e.r, t), this.g = Math.pow(e.g, t), this.b = Math.pow(e.b, t), this } copyLinearToGamma(e, t = 2) { const n = t > 0 ? 1 / t : 1; return this.r = Math.pow(e.r, n), this.g = Math.pow(e.g, n), this.b = Math.pow(e.b, n), this } convertGammaToLinear(e) { return this.copyGammaToLinear(this, e), this } convertLinearToGamma(e) { return this.copyLinearToGamma(this, e), this } copySRGBToLinear(e) { return this.r = et(e.r), this.g = et(e.g), this.b = et(e.b), this } copyLinearToSRGB(e) { return this.r = tt(e.r), this.g = tt(e.g), this.b = tt(e.b), this } convertSRGBToLinear() { return this.copySRGBToLinear(this), this } convertLinearToSRGB() { return this.copyLinearToSRGB(this), this } getHex() { return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b << 0 } getHexString() { return ("000000" + this.getHex().toString(16)).slice(-6) } getHSL(e) { const t = this.r, n = this.g, i = this.b, r = Math.max(t, n, i), s = Math.min(t, n, i); let o, a; const l = (s + r) / 2; if (s === r) o = 0, a = 0; else { const e = r - s; switch (a = l <= .5 ? e / (r + s) : e / (2 - r - s), r) { case t: o = (n - i) / e + (n < i ? 6 : 0); break; case n: o = (i - t) / e + 2; break; case i: o = (t - n) / e + 4 }o /= 6 } return e.h = o, e.s = a, e.l = l, e } getStyle() { return "rgb(" + (255 * this.r | 0) + "," + (255 * this.g | 0) + "," + (255 * this.b | 0) + ")" } offsetHSL(e, t, n) { return this.getHSL(qe), qe.h += e, qe.s += t, qe.l += n, this.setHSL(qe.h, qe.s, qe.l), this } add(e) { return this.r += e.r, this.g += e.g, this.b += e.b, this } addColors(e, t) { return this.r = e.r + t.r, this.g = e.g + t.g, this.b = e.b + t.b, this } addScalar(e) { return this.r += e, this.g += e, this.b += e, this } sub(e) { return this.r = Math.max(0, this.r - e.r), this.g = Math.max(0, this.g - e.g), this.b = Math.max(0, this.b - e.b), this } multiply(e) { return this.r *= e.r, this.g *= e.g, this.b *= e.b, this } multiplyScalar(e) { return this.r *= e, this.g *= e, this.b *= e, this } lerp(e, t) { return this.r += (e.r - this.r) * t, this.g += (e.g - this.g) * t, this.b += (e.b - this.b) * t, this } lerpColors(e, t, n) { return this.r = e.r + (t.r - e.r) * n, this.g = e.g + (t.g - e.g) * n, this.b = e.b + (t.b - e.b) * n, this } lerpHSL(e, t) { this.getHSL(qe), e.getHSL(_e); const n = v(qe.h, _e.h, t), i = v(qe.s, _e.s, t), r = v(qe.l, _e.l, t); return this.setHSL(n, i, r), this } equals(e) { return e.r === this.r && e.g === this.g && e.b === this.b } fromArray(e, t = 0) { return this.r = e[t], this.g = e[t + 1], this.b = e[t + 2], this } toArray(e = [], t = 0) { return e[t] = this.r, e[t + 1] = this.g, e[t + 2] = this.b, e } fromBufferAttribute(e, t) { return this.r = e.getX(t), this.g = e.getY(t), this.b = e.getZ(t), !0 === e.normalized && (this.r /= 255, this.g /= 255, this.b /= 255), this } toJSON() { return this.getHex() } } nt.NAMES = Ze, nt.prototype.isColor = !0, nt.prototype.r = 1, nt.prototype.g = 1, nt.prototype.b = 1; class it extends Ke { constructor(e) { super(), this.type = "MeshBasicMaterial", this.color = new nt(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.morphTargets = !1, this.setValues(e) } copy(e) { return super.copy(e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.morphTargets = e.morphTargets, this } } it.prototype.isMeshBasicMaterial = !0; const rt = new O, st = new b; class ot { constructor(e, t, n) { if (Array.isArray(e)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array."); this.name = "", this.array = e, this.itemSize = t, this.count = void 0 !== e ? e.length / t : 0, this.normalized = !0 === n, this.usage = 35044, this.updateRange = { offset: 0, count: -1 }, this.version = 0 } onUploadCallback() { } set needsUpdate(e) { !0 === e && this.version++ } setUsage(e) { return this.usage = e, this } copy(e) { return this.name = e.name, this.array = new e.array.constructor(e.array), this.itemSize = e.itemSize, this.count = e.count, this.normalized = e.normalized, this.usage = e.usage, this } copyAt(e, t, n) { e *= this.itemSize, n *= t.itemSize; for (let i = 0, r = this.itemSize; i < r; i++)this.array[e + i] = t.array[n + i]; return this } copyArray(e) { return this.array.set(e), this } copyColorsArray(e) { const t = this.array; let n = 0; for (let i = 0, r = e.length; i < r; i++) { let r = e[i]; void 0 === r && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", i), r = new nt), t[n++] = r.r, t[n++] = r.g, t[n++] = r.b } return this } copyVector2sArray(e) { const t = this.array; let n = 0; for (let i = 0, r = e.length; i < r; i++) { let r = e[i]; void 0 === r && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", i), r = new b), t[n++] = r.x, t[n++] = r.y } return this } copyVector3sArray(e) { const t = this.array; let n = 0; for (let i = 0, r = e.length; i < r; i++) { let r = e[i]; void 0 === r && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", i), r = new O), t[n++] = r.x, t[n++] = r.y, t[n++] = r.z } return this } copyVector4sArray(e) { const t = this.array; let n = 0; for (let i = 0, r = e.length; i < r; i++) { let r = e[i]; void 0 === r && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", i), r = new B), t[n++] = r.x, t[n++] = r.y, t[n++] = r.z, t[n++] = r.w } return this } applyMatrix3(e) { if (2 === this.itemSize) for (let t = 0, n = this.count; t < n; t++)st.fromBufferAttribute(this, t), st.applyMatrix3(e), this.setXY(t, st.x, st.y); else if (3 === this.itemSize) for (let t = 0, n = this.count; t < n; t++)rt.fromBufferAttribute(this, t), rt.applyMatrix3(e), this.setXYZ(t, rt.x, rt.y, rt.z); return this } applyMatrix4(e) { for (let t = 0, n = this.count; t < n; t++)rt.x = this.getX(t), rt.y = this.getY(t), rt.z = this.getZ(t), rt.applyMatrix4(e), this.setXYZ(t, rt.x, rt.y, rt.z); return this } applyNormalMatrix(e) { for (let t = 0, n = this.count; t < n; t++)rt.x = this.getX(t), rt.y = this.getY(t), rt.z = this.getZ(t), rt.applyNormalMatrix(e), this.setXYZ(t, rt.x, rt.y, rt.z); return this } transformDirection(e) { for (let t = 0, n = this.count; t < n; t++)rt.x = this.getX(t), rt.y = this.getY(t), rt.z = this.getZ(t), rt.transformDirection(e), this.setXYZ(t, rt.x, rt.y, rt.z); return this } set(e, t = 0) { return this.array.set(e, t), this } getX(e) { return this.array[e * this.itemSize] } setX(e, t) { return this.array[e * this.itemSize] = t, this } getY(e) { return this.array[e * this.itemSize + 1] } setY(e, t) { return this.array[e * this.itemSize + 1] = t, this } getZ(e) { return this.array[e * this.itemSize + 2] } setZ(e, t) { return this.array[e * this.itemSize + 2] = t, this } getW(e) { return this.array[e * this.itemSize + 3] } setW(e, t) { return this.array[e * this.itemSize + 3] = t, this } setXY(e, t, n) { return e *= this.itemSize, this.array[e + 0] = t, this.array[e + 1] = n, this } setXYZ(e, t, n, i) { return e *= this.itemSize, this.array[e + 0] = t, this.array[e + 1] = n, this.array[e + 2] = i, this } setXYZW(e, t, n, i, r) { return e *= this.itemSize, this.array[e + 0] = t, this.array[e + 1] = n, this.array[e + 2] = i, this.array[e + 3] = r, this } onUpload(e) { return this.onUploadCallback = e, this } clone() { return new this.constructor(this.array, this.itemSize).copy(this) } toJSON() { const e = { itemSize: this.itemSize, type: this.array.constructor.name, array: Array.prototype.slice.call(this.array), normalized: this.normalized }; return "" !== this.name && (e.name = this.name), 35044 !== this.usage && (e.usage = this.usage), 0 === this.updateRange.offset && -1 === this.updateRange.count || (e.updateRange = this.updateRange), e } } ot.prototype.isBufferAttribute = !0; class at extends ot { constructor(e, t, n) { super(new Uint16Array(e), t, n) } } class lt extends ot { constructor(e, t, n) { super(new Uint32Array(e), t, n) } } (class extends ot { constructor(e, t, n) { super(new Uint16Array(e), t, n) } }).prototype.isFloat16BufferAttribute = !0; class ct extends ot { constructor(e, t, n) { super(new Float32Array(e), t, n) } } function At(e) { if (0 === e.length) return -1 / 0; let t = e[0]; for (let n = 1, i = e.length; n < i; ++n)e[n] > t && (t = e[n]); return t } Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array; let ut = 0; const ht = new ue, dt = new ke, pt = new O, ft = new H, gt = new H, mt = new O; class vt extends A { constructor() { super(), Object.defineProperty(this, "id", { value: ut++ }), this.uuid = f(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = { start: 0, count: 1 / 0 }, this.userData = {} } getIndex() { return this.index } setIndex(e) { return Array.isArray(e) ? this.index = new (At(e) > 65535 ? lt : at)(e, 1) : this.index = e, this } getAttribute(e) { return this.attributes[e] } setAttribute(e, t) { return this.attributes[e] = t, this } deleteAttribute(e) { return delete this.attributes[e], this } hasAttribute(e) { return void 0 !== this.attributes[e] } addGroup(e, t, n = 0) { this.groups.push({ start: e, count: t, materialIndex: n }) } clearGroups() { this.groups = [] } setDrawRange(e, t) { this.drawRange.start = e, this.drawRange.count = t } applyMatrix4(e) { const t = this.attributes.position; void 0 !== t && (t.applyMatrix4(e), t.needsUpdate = !0); const n = this.attributes.normal; if (void 0 !== n) { const t = (new M).getNormalMatrix(e); n.applyNormalMatrix(t), n.needsUpdate = !0 } const i = this.attributes.tangent; return void 0 !== i && (i.transformDirection(e), i.needsUpdate = !0), null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this } applyQuaternion(e) { return ht.makeRotationFromQuaternion(e), this.applyMatrix4(ht), this } rotateX(e) { return ht.makeRotationX(e), this.applyMatrix4(ht), this } rotateY(e) { return ht.makeRotationY(e), this.applyMatrix4(ht), this } rotateZ(e) { return ht.makeRotationZ(e), this.applyMatrix4(ht), this } translate(e, t, n) { return ht.makeTranslation(e, t, n), this.applyMatrix4(ht), this } scale(e, t, n) { return ht.makeScale(e, t, n), this.applyMatrix4(ht), this } lookAt(e) { return dt.lookAt(e), dt.updateMatrix(), this.applyMatrix4(dt.matrix), this } center() { return this.computeBoundingBox(), this.boundingBox.getCenter(pt).negate(), this.translate(pt.x, pt.y, pt.z), this } setFromPoints(e) { const t = []; for (let n = 0, i = e.length; n < i; n++) { const i = e[n]; t.push(i.x, i.y, i.z || 0) } return this.setAttribute("position", new ct(t, 3)), this } computeBoundingBox() { null === this.boundingBox && (this.boundingBox = new H); const e = this.attributes.position, t = this.morphAttributes.position; if (e && e.isGLBufferAttribute) return console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this), void this.boundingBox.set(new O(-1 / 0, -1 / 0, -1 / 0), new O(1 / 0, 1 / 0, 1 / 0)); if (void 0 !== e) { if (this.boundingBox.setFromBufferAttribute(e), t) for (let e = 0, n = t.length; e < n; e++) { const n = t[e]; ft.setFromBufferAttribute(n), this.morphTargetsRelative ? (mt.addVectors(this.boundingBox.min, ft.min), this.boundingBox.expandByPoint(mt), mt.addVectors(this.boundingBox.max, ft.max), this.boundingBox.expandByPoint(mt)) : (this.boundingBox.expandByPoint(ft.min), this.boundingBox.expandByPoint(ft.max)) } } else this.boundingBox.makeEmpty(); (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this) } computeBoundingSphere() { null === this.boundingSphere && (this.boundingSphere = new ne); const e = this.attributes.position, t = this.morphAttributes.position; if (e && e.isGLBufferAttribute) return console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this), void this.boundingSphere.set(new O, 1 / 0); if (e) { const n = this.boundingSphere.center; if (ft.setFromBufferAttribute(e), t) for (let e = 0, n = t.length; e < n; e++) { const n = t[e]; gt.setFromBufferAttribute(n), this.morphTargetsRelative ? (mt.addVectors(ft.min, gt.min), ft.expandByPoint(mt), mt.addVectors(ft.max, gt.max), ft.expandByPoint(mt)) : (ft.expandByPoint(gt.min), ft.expandByPoint(gt.max)) } ft.getCenter(n); let i = 0; for (let t = 0, r = e.count; t < r; t++)mt.fromBufferAttribute(e, t), i = Math.max(i, n.distanceToSquared(mt)); if (t) for (let r = 0, s = t.length; r < s; r++) { const s = t[r], o = this.morphTargetsRelative; for (let t = 0, r = s.count; t < r; t++)mt.fromBufferAttribute(s, t), o && (pt.fromBufferAttribute(e, t), mt.add(pt)), i = Math.max(i, n.distanceToSquared(mt)) } this.boundingSphere.radius = Math.sqrt(i), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this) } } computeFaceNormals() { } computeTangents() { const e = this.index, t = this.attributes; if (null === e || void 0 === t.position || void 0 === t.normal || void 0 === t.uv) return void console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)"); const n = e.array, i = t.position.array, r = t.normal.array, s = t.uv.array, o = i.length / 3; void 0 === t.tangent && this.setAttribute("tangent", new ot(new Float32Array(4 * o), 4)); const a = t.tangent.array, l = [], c = []; for (let e = 0; e < o; e++)l[e] = new O, c[e] = new O; const A = new O, u = new O, h = new O, d = new b, p = new b, f = new b, g = new O, m = new O; function v(e, t, n) { A.fromArray(i, 3 * e), u.fromArray(i, 3 * t), h.fromArray(i, 3 * n), d.fromArray(s, 2 * e), p.fromArray(s, 2 * t), f.fromArray(s, 2 * n), u.sub(A), h.sub(A), p.sub(d), f.sub(d); const r = 1 / (p.x * f.y - f.x * p.y); isFinite(r) && (g.copy(u).multiplyScalar(f.y).addScaledVector(h, -p.y).multiplyScalar(r), m.copy(h).multiplyScalar(p.x).addScaledVector(u, -f.x).multiplyScalar(r), l[e].add(g), l[t].add(g), l[n].add(g), c[e].add(m), c[t].add(m), c[n].add(m)) } let y = this.groups; 0 === y.length && (y = [{ start: 0, count: n.length }]); for (let e = 0, t = y.length; e < t; ++e) { const t = y[e], i = t.start; for (let e = i, r = i + t.count; e < r; e += 3)v(n[e + 0], n[e + 1], n[e + 2]) } const w = new O, x = new O, C = new O, M = new O; function I(e) { C.fromArray(r, 3 * e), M.copy(C); const t = l[e]; w.copy(t), w.sub(C.multiplyScalar(C.dot(t))).normalize(), x.crossVectors(M, t); const n = x.dot(c[e]) < 0 ? -1 : 1; a[4 * e] = w.x, a[4 * e + 1] = w.y, a[4 * e + 2] = w.z, a[4 * e + 3] = n } for (let e = 0, t = y.length; e < t; ++e) { const t = y[e], i = t.start; for (let e = i, r = i + t.count; e < r; e += 3)I(n[e + 0]), I(n[e + 1]), I(n[e + 2]) } } computeVertexNormals() { const e = this.index, t = this.getAttribute("position"); if (void 0 !== t) { let n = this.getAttribute("normal"); if (void 0 === n) n = new ot(new Float32Array(3 * t.count), 3), this.setAttribute("normal", n); else for (let e = 0, t = n.count; e < t; e++)n.setXYZ(e, 0, 0, 0); const i = new O, r = new O, s = new O, o = new O, a = new O, l = new O, c = new O, A = new O; if (e) for (let u = 0, h = e.count; u < h; u += 3) { const h = e.getX(u + 0), d = e.getX(u + 1), p = e.getX(u + 2); i.fromBufferAttribute(t, h), r.fromBufferAttribute(t, d), s.fromBufferAttribute(t, p), c.subVectors(s, r), A.subVectors(i, r), c.cross(A), o.fromBufferAttribute(n, h), a.fromBufferAttribute(n, d), l.fromBufferAttribute(n, p), o.add(c), a.add(c), l.add(c), n.setXYZ(h, o.x, o.y, o.z), n.setXYZ(d, a.x, a.y, a.z), n.setXYZ(p, l.x, l.y, l.z) } else for (let e = 0, o = t.count; e < o; e += 3)i.fromBufferAttribute(t, e + 0), r.fromBufferAttribute(t, e + 1), s.fromBufferAttribute(t, e + 2), c.subVectors(s, r), A.subVectors(i, r), c.cross(A), n.setXYZ(e + 0, c.x, c.y, c.z), n.setXYZ(e + 1, c.x, c.y, c.z), n.setXYZ(e + 2, c.x, c.y, c.z); this.normalizeNormals(), n.needsUpdate = !0 } } merge(e, t) { if (!e || !e.isBufferGeometry) return void console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", e); void 0 === t && (t = 0, console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge.")); const n = this.attributes; for (const i in n) { if (void 0 === e.attributes[i]) continue; const r = n[i].array, s = e.attributes[i], o = s.array, a = s.itemSize * t, l = Math.min(o.length, r.length - a); for (let e = 0, t = a; e < l; e++, t++)r[t] = o[e] } return this } normalizeNormals() { const e = this.attributes.normal; for (let t = 0, n = e.count; t < n; t++)mt.fromBufferAttribute(e, t), mt.normalize(), e.setXYZ(t, mt.x, mt.y, mt.z) } toNonIndexed() { function e(e, t) { const n = e.array, i = e.itemSize, r = e.normalized, s = new n.constructor(t.length * i); let o = 0, a = 0; for (let r = 0, l = t.length; r < l; r++) { o = e.isInterleavedBufferAttribute ? t[r] * e.data.stride + e.offset : t[r] * i; for (let e = 0; e < i; e++)s[a++] = n[o++] } return new ot(s, i, r) } if (null === this.index) return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this; const t = new vt, n = this.index.array, i = this.attributes; for (const r in i) { const s = e(i[r], n); t.setAttribute(r, s) } const r = this.morphAttributes; for (const i in r) { const s = [], o = r[i]; for (let t = 0, i = o.length; t < i; t++) { const i = e(o[t], n); s.push(i) } t.morphAttributes[i] = s } t.morphTargetsRelative = this.morphTargetsRelative; const s = this.groups; for (let e = 0, n = s.length; e < n; e++) { const n = s[e]; t.addGroup(n.start, n.count, n.materialIndex) } return t } toJSON() { const e = { metadata: { version: 4.5, type: "BufferGeometry", generator: "BufferGeometry.toJSON" } }; if (e.uuid = this.uuid, e.type = this.type, "" !== this.name && (e.name = this.name), Object.keys(this.userData).length > 0 && (e.userData = this.userData), void 0 !== this.parameters) { const t = this.parameters; for (const n in t) void 0 !== t[n] && (e[n] = t[n]); return e } e.data = { attributes: {} }; const t = this.index; null !== t && (e.data.index = { type: t.array.constructor.name, array: Array.prototype.slice.call(t.array) }); const n = this.attributes; for (const t in n) { const i = n[t]; e.data.attributes[t] = i.toJSON(e.data) } const i = {}; let r = !1; for (const t in this.morphAttributes) { const n = this.morphAttributes[t], s = []; for (let t = 0, i = n.length; t < i; t++) { const i = n[t]; s.push(i.toJSON(e.data)) } s.length > 0 && (i[t] = s, r = !0) } r && (e.data.morphAttributes = i, e.data.morphTargetsRelative = this.morphTargetsRelative); const s = this.groups; s.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(s))); const o = this.boundingSphere; return null !== o && (e.data.boundingSphere = { center: o.center.toArray(), radius: o.radius }), e } clone() { return (new vt).copy(this) } copy(e) { this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null; const t = {}; this.name = e.name; const n = e.index; null !== n && this.setIndex(n.clone(t)); const i = e.attributes; for (const e in i) { const n = i[e]; this.setAttribute(e, n.clone(t)) } const r = e.morphAttributes; for (const e in r) { const n = [], i = r[e]; for (let e = 0, r = i.length; e < r; e++)n.push(i[e].clone(t)); this.morphAttributes[e] = n } this.morphTargetsRelative = e.morphTargetsRelative; const s = e.groups; for (let e = 0, t = s.length; e < t; e++) { const t = s[e]; this.addGroup(t.start, t.count, t.materialIndex) } const o = e.boundingBox; null !== o && (this.boundingBox = o.clone()); const a = e.boundingSphere; return null !== a && (this.boundingSphere = a.clone()), this.drawRange.start = e.drawRange.start, this.drawRange.count = e.drawRange.count, this.userData = e.userData, this } dispose() { this.dispatchEvent({ type: "dispose" }) } } vt.prototype.isBufferGeometry = !0; const yt = new ue, wt = new Ae, xt = new ne, Ct = new O, bt = new O, Mt = new O, It = new O, Et = new O, Tt = new O, Pt = new O, St = new O, Bt = new O, Dt = new b, Rt = new b, Lt = new b, Ot = new O, Nt = new O; class kt extends ke { constructor(e = new vt, t = new it) { super(), this.type = "Mesh", this.geometry = e, this.material = t, this.updateMorphTargets() } copy(e) { return super.copy(e), void 0 !== e.morphTargetInfluences && (this.morphTargetInfluences = e.morphTargetInfluences.slice()), void 0 !== e.morphTargetDictionary && (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)), this.material = e.material, this.geometry = e.geometry, this } updateMorphTargets() { const e = this.geometry; if (e.isBufferGeometry) { const t = e.morphAttributes, n = Object.keys(t); if (n.length > 0) { const e = t[n[0]]; if (void 0 !== e) { this.morphTargetInfluences = [], this.morphTargetDictionary = {}; for (let t = 0, n = e.length; t < n; t++) { const n = e[t].name || String(t); this.morphTargetInfluences.push(0), this.morphTargetDictionary[n] = t } } } } else { const t = e.morphTargets; void 0 !== t && t.length > 0 && console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.") } } raycast(e, t) { const n = this.geometry, i = this.material, r = this.matrixWorld; if (void 0 === i) return; if (null === n.boundingSphere && n.computeBoundingSphere(), xt.copy(n.boundingSphere), xt.applyMatrix4(r), !1 === e.ray.intersectsSphere(xt)) return; if (yt.copy(r).invert(), wt.copy(e.ray).applyMatrix4(yt), null !== n.boundingBox && !1 === wt.intersectsBox(n.boundingBox)) return; let s; if (n.isBufferGeometry) { const r = n.index, o = n.attributes.position, a = n.morphAttributes.position, l = n.morphTargetsRelative, c = n.attributes.uv, A = n.attributes.uv2, u = n.groups, h = n.drawRange; if (null !== r) if (Array.isArray(i)) for (let n = 0, d = u.length; n < d; n++) { const d = u[n], p = i[d.materialIndex]; for (let n = Math.max(d.start, h.start), i = Math.min(d.start + d.count, h.start + h.count); n < i; n += 3) { const i = r.getX(n), u = r.getX(n + 1), h = r.getX(n + 2); s = Ht(this, p, e, wt, o, a, l, c, A, i, u, h), s && (s.faceIndex = Math.floor(n / 3), s.face.materialIndex = d.materialIndex, t.push(s)) } } else { for (let n = Math.max(0, h.start), u = Math.min(r.count, h.start + h.count); n < u; n += 3) { const u = r.getX(n), h = r.getX(n + 1), d = r.getX(n + 2); s = Ht(this, i, e, wt, o, a, l, c, A, u, h, d), s && (s.faceIndex = Math.floor(n / 3), t.push(s)) } } else if (void 0 !== o) if (Array.isArray(i)) for (let n = 0, r = u.length; n < r; n++) { const r = u[n], d = i[r.materialIndex]; for (let n = Math.max(r.start, h.start), i = Math.min(r.start + r.count, h.start + h.count); n < i; n += 3) { s = Ht(this, d, e, wt, o, a, l, c, A, n, n + 1, n + 2), s && (s.faceIndex = Math.floor(n / 3), s.face.materialIndex = r.materialIndex, t.push(s)) } } else { for (let n = Math.max(0, h.start), r = Math.min(o.count, h.start + h.count); n < r; n += 3) { s = Ht(this, i, e, wt, o, a, l, c, A, n, n + 1, n + 2), s && (s.faceIndex = Math.floor(n / 3), t.push(s)) } } } else n.isGeometry && console.error("THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.") } } function Ht(e, t, n, i, r, s, o, a, l, c, A, u) { Ct.fromBufferAttribute(r, c), bt.fromBufferAttribute(r, A), Mt.fromBufferAttribute(r, u); const h = e.morphTargetInfluences; if (t.morphTargets && s && h) { Pt.set(0, 0, 0), St.set(0, 0, 0), Bt.set(0, 0, 0); for (let e = 0, t = s.length; e < t; e++) { const t = h[e], n = s[e]; 0 !== t && (It.fromBufferAttribute(n, c), Et.fromBufferAttribute(n, A), Tt.fromBufferAttribute(n, u), o ? (Pt.addScaledVector(It, t), St.addScaledVector(Et, t), Bt.addScaledVector(Tt, t)) : (Pt.addScaledVector(It.sub(Ct), t), St.addScaledVector(Et.sub(bt), t), Bt.addScaledVector(Tt.sub(Mt), t))) } Ct.add(Pt), bt.add(St), Mt.add(Bt) } e.isSkinnedMesh && (e.boneTransform(c, Ct), e.boneTransform(A, bt), e.boneTransform(u, Mt)); const d = function (e, t, n, i, r, s, o, a) { let l; if (l = 1 === t.side ? i.intersectTriangle(o, s, r, !0, a) : i.intersectTriangle(r, s, o, 2 !== t.side, a), null === l) return null; Nt.copy(a), Nt.applyMatrix4(e.matrixWorld); const c = n.ray.origin.distanceTo(Nt); return c < n.near || c > n.far ? null : { distance: c, point: Nt.clone(), object: e } }(e, t, n, i, Ct, bt, Mt, Ot); if (d) { a && (Dt.fromBufferAttribute(a, c), Rt.fromBufferAttribute(a, A), Lt.fromBufferAttribute(a, u), d.uv = Xe.getUV(Ot, Ct, bt, Mt, Dt, Rt, Lt, new b)), l && (Dt.fromBufferAttribute(l, c), Rt.fromBufferAttribute(l, A), Lt.fromBufferAttribute(l, u), d.uv2 = Xe.getUV(Ot, Ct, bt, Mt, Dt, Rt, Lt, new b)); const e = { a: c, b: A, c: u, normal: new O, materialIndex: 0 }; Xe.getNormal(Ct, bt, Mt, e.normal), d.face = e } return d } kt.prototype.isMesh = !0; class zt extends vt { constructor(e = 1, t = 1, n = 1, i = 1, r = 1, s = 1) { super(), this.type = "BoxGeometry", this.parameters = { width: e, height: t, depth: n, widthSegments: i, heightSegments: r, depthSegments: s }; const o = this; i = Math.floor(i), r = Math.floor(r), s = Math.floor(s); const a = [], l = [], c = [], A = []; let u = 0, h = 0; function d(e, t, n, i, r, s, d, p, f, g, m) { const v = s / f, y = d / g, w = s / 2, x = d / 2, C = p / 2, b = f + 1, M = g + 1; let I = 0, E = 0; const T = new O; for (let s = 0; s < M; s++) { const o = s * y - x; for (let a = 0; a < b; a++) { const u = a * v - w; T[e] = u * i, T[t] = o * r, T[n] = C, l.push(T.x, T.y, T.z), T[e] = 0, T[t] = 0, T[n] = p > 0 ? 1 : -1, c.push(T.x, T.y, T.z), A.push(a / f), A.push(1 - s / g), I += 1 } } for (let e = 0; e < g; e++)for (let t = 0; t < f; t++) { const n = u + t + b * e, i = u + t + b * (e + 1), r = u + (t + 1) + b * (e + 1), s = u + (t + 1) + b * e; a.push(n, i, s), a.push(i, r, s), E += 6 } o.addGroup(h, E, m), h += E, u += I } d("z", "y", "x", -1, -1, n, t, e, s, r, 0), d("z", "y", "x", 1, -1, n, t, -e, s, r, 1), d("x", "z", "y", 1, 1, e, n, t, i, s, 2), d("x", "z", "y", 1, -1, e, n, -t, i, s, 3), d("x", "y", "z", 1, -1, e, t, n, i, r, 4), d("x", "y", "z", -1, -1, e, t, -n, i, r, 5), this.setIndex(a), this.setAttribute("position", new ct(l, 3)), this.setAttribute("normal", new ct(c, 3)), this.setAttribute("uv", new ct(A, 2)) } static fromJSON(e) { return new zt(e.width, e.height, e.depth, e.widthSegments, e.heightSegments, e.depthSegments) } } function Ft(e) { const t = {}; for (const n in e) { t[n] = {}; for (const i in e[n]) { const r = e[n][i]; r && (r.isColor || r.isMatrix3 || r.isMatrix4 || r.isVector2 || r.isVector3 || r.isVector4 || r.isTexture || r.isQuaternion) ? t[n][i] = r.clone() : Array.isArray(r) ? t[n][i] = r.slice() : t[n][i] = r } } return t } function Qt(e) { const t = {}; for (let n = 0; n < e.length; n++) { const i = Ft(e[n]); for (const e in i) t[e] = i[e] } return t } const Gt = { clone: Ft, merge: Qt }; class jt extends Ke { constructor(e) { super(), this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.vertexShader = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", this.fragmentShader = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}", this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.morphTargets = !1, this.morphNormals = !1, this.extensions = { derivatives: !1, fragDepth: !1, drawBuffers: !1, shaderTextureLOD: !1 }, this.defaultAttributeValues = { color: [1, 1, 1], uv: [0, 0], uv2: [0, 0] }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, this.glslVersion = null, void 0 !== e && (void 0 !== e.attributes && console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."), this.setValues(e)) } copy(e) { return super.copy(e), this.fragmentShader = e.fragmentShader, this.vertexShader = e.vertexShader, this.uniforms = Ft(e.uniforms), this.defines = Object.assign({}, e.defines), this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.lights = e.lights, this.clipping = e.clipping, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this.extensions = Object.assign({}, e.extensions), this.glslVersion = e.glslVersion, this } toJSON(e) { const t = super.toJSON(e); t.glslVersion = this.glslVersion, t.uniforms = {}; for (const n in this.uniforms) { const i = this.uniforms[n].value; i && i.isTexture ? t.uniforms[n] = { type: "t", value: i.toJSON(e).uuid } : i && i.isColor ? t.uniforms[n] = { type: "c", value: i.getHex() } : i && i.isVector2 ? t.uniforms[n] = { type: "v2", value: i.toArray() } : i && i.isVector3 ? t.uniforms[n] = { type: "v3", value: i.toArray() } : i && i.isVector4 ? t.uniforms[n] = { type: "v4", value: i.toArray() } : i && i.isMatrix3 ? t.uniforms[n] = { type: "m3", value: i.toArray() } : i && i.isMatrix4 ? t.uniforms[n] = { type: "m4", value: i.toArray() } : t.uniforms[n] = { value: i } } Object.keys(this.defines).length > 0 && (t.defines = this.defines), t.vertexShader = this.vertexShader, t.fragmentShader = this.fragmentShader; const n = {}; for (const e in this.extensions) !0 === this.extensions[e] && (n[e] = !0); return Object.keys(n).length > 0 && (t.extensions = n), t } } jt.prototype.isShaderMaterial = !0; class Ut extends ke { constructor() { super(), this.type = "Camera", this.matrixWorldInverse = new ue, this.projectionMatrix = new ue, this.projectionMatrixInverse = new ue } copy(e, t) { return super.copy(e, t), this.matrixWorldInverse.copy(e.matrixWorldInverse), this.projectionMatrix.copy(e.projectionMatrix), this.projectionMatrixInverse.copy(e.projectionMatrixInverse), this } getWorldDirection(e) { this.updateWorldMatrix(!0, !1); const t = this.matrixWorld.elements; return e.set(-t[8], -t[9], -t[10]).normalize() } updateMatrixWorld(e) { super.updateMatrixWorld(e), this.matrixWorldInverse.copy(this.matrixWorld).invert() } updateWorldMatrix(e, t) { super.updateWorldMatrix(e, t), this.matrixWorldInverse.copy(this.matrixWorld).invert() } clone() { return (new this.constructor).copy(this) } } Ut.prototype.isCamera = !0; class Vt extends Ut { constructor(e = 50, t = 1, n = .1, i = 2e3) { super(), this.type = "PerspectiveCamera", this.fov = e, this.zoom = 1, this.near = n, this.far = i, this.focus = 10, this.aspect = t, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix() } copy(e, t) { return super.copy(e, t), this.fov = e.fov, this.zoom = e.zoom, this.near = e.near, this.far = e.far, this.focus = e.focus, this.aspect = e.aspect, this.view = null === e.view ? null : Object.assign({}, e.view), this.filmGauge = e.filmGauge, this.filmOffset = e.filmOffset, this } setFocalLength(e) { const t = .5 * this.getFilmHeight() / e; this.fov = 2 * p * Math.atan(t), this.updateProjectionMatrix() } getFocalLength() { const e = Math.tan(.5 * d * this.fov); return .5 * this.getFilmHeight() / e } getEffectiveFOV() { return 2 * p * Math.atan(Math.tan(.5 * d * this.fov) / this.zoom) } getFilmWidth() { return this.filmGauge * Math.min(this.aspect, 1) } getFilmHeight() { return this.filmGauge / Math.max(this.aspect, 1) } setViewOffset(e, t, n, i, r, s) { this.aspect = e / t, null === this.view && (this.view = { enabled: !0, fullWidth: 1, fullHeight: 1, offsetX: 0, offsetY: 0, width: 1, height: 1 }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = n, this.view.offsetY = i, this.view.width = r, this.view.height = s, this.updateProjectionMatrix() } clearViewOffset() { null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix() } updateProjectionMatrix() { const e = this.near; let t = e * Math.tan(.5 * d * this.fov) / this.zoom, n = 2 * t, i = this.aspect * n, r = -.5 * i; const s = this.view; if (null !== this.view && this.view.enabled) { const e = s.fullWidth, o = s.fullHeight; r += s.offsetX * i / e, t -= s.offsetY * n / o, i *= s.width / e, n *= s.height / o } const o = this.filmOffset; 0 !== o && (r += e * o / this.getFilmWidth()), this.projectionMatrix.makePerspective(r, r + i, t, t - n, e, this.far), this.projectionMatrixInverse.copy(this.projectionMatrix).invert() } toJSON(e) { const t = super.toJSON(e); return t.object.fov = this.fov, t.object.zoom = this.zoom, t.object.near = this.near, t.object.far = this.far, t.object.focus = this.focus, t.object.aspect = this.aspect, null !== this.view && (t.object.view = Object.assign({}, this.view)), t.object.filmGauge = this.filmGauge, t.object.filmOffset = this.filmOffset, t } } Vt.prototype.isPerspectiveCamera = !0; class Yt extends ke { constructor(e, t, n) { if (super(), this.type = "CubeCamera", !0 !== n.isWebGLCubeRenderTarget) return void console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter."); this.renderTarget = n; const i = new Vt(90, 1, e, t); i.layers = this.layers, i.up.set(0, -1, 0), i.lookAt(new O(1, 0, 0)), this.add(i); const r = new Vt(90, 1, e, t); r.layers = this.layers, r.up.set(0, -1, 0), r.lookAt(new O(-1, 0, 0)), this.add(r); const s = new Vt(90, 1, e, t); s.layers = this.layers, s.up.set(0, 0, 1), s.lookAt(new O(0, 1, 0)), this.add(s); const o = new Vt(90, 1, e, t); o.layers = this.layers, o.up.set(0, 0, -1), o.lookAt(new O(0, -1, 0)), this.add(o); const a = new Vt(90, 1, e, t); a.layers = this.layers, a.up.set(0, -1, 0), a.lookAt(new O(0, 0, 1)), this.add(a); const l = new Vt(90, 1, e, t); l.layers = this.layers, l.up.set(0, -1, 0), l.lookAt(new O(0, 0, -1)), this.add(l) } update(e, t) { null === this.parent && this.updateMatrixWorld(); const n = this.renderTarget, [i, r, s, o, a, l] = this.children, c = e.xr.enabled, A = e.getRenderTarget(); e.xr.enabled = !1; const u = n.texture.generateMipmaps; n.texture.generateMipmaps = !1, e.setRenderTarget(n, 0), e.render(t, i), e.setRenderTarget(n, 1), e.render(t, r), e.setRenderTarget(n, 2), e.render(t, s), e.setRenderTarget(n, 3), e.render(t, o), e.setRenderTarget(n, 4), e.render(t, a), n.texture.generateMipmaps = u, e.setRenderTarget(n, 5), e.render(t, l), e.setRenderTarget(A), e.xr.enabled = c } } class Wt extends P { constructor(e, t, n, i, r, s, o, a, l, c) { super(e = void 0 !== e ? e : [], t = void 0 !== t ? t : 301, n, i, r, s, o = void 0 !== o ? o : 1022, a, l, c), this._needsFlipEnvMap = !0, this.flipY = !1 } get images() { return this.image } set images(e) { this.image = e } } Wt.prototype.isCubeTexture = !0; class Xt extends D { constructor(e, t, n) { Number.isInteger(t) && (console.warn("THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )"), t = n), super(e, e, t), t = t || {}, this.texture = new Wt(void 0, t.mapping, t.wrapS, t.wrapT, t.magFilter, t.minFilter, t.format, t.type, t.anisotropy, t.encoding), this.texture.generateMipmaps = void 0 !== t.generateMipmaps && t.generateMipmaps, this.texture.minFilter = void 0 !== t.minFilter ? t.minFilter : 1006, this.texture._needsFlipEnvMap = !1 } fromEquirectangularTexture(e, t) { this.texture.type = t.type, this.texture.format = 1023, this.texture.encoding = t.encoding, this.texture.generateMipmaps = t.generateMipmaps, this.texture.minFilter = t.minFilter, this.texture.magFilter = t.magFilter; const n = { uniforms: { tEquirect: { value: null } }, vertexShader: "\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t", fragmentShader: "\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t" }, i = new zt(5, 5, 5), r = new jt({ name: "CubemapFromEquirect", uniforms: Ft(n.uniforms), vertexShader: n.vertexShader, fragmentShader: n.fragmentShader, side: 1, blending: 0 }); r.uniforms.tEquirect.value = t; const s = new kt(i, r), o = t.minFilter; 1008 === t.minFilter && (t.minFilter = 1006); return new Yt(1, 10, this).update(e, s), t.minFilter = o, s.geometry.dispose(), s.material.dispose(), this } clear(e, t, n, i) { const r = e.getRenderTarget(); for (let r = 0; r < 6; r++)e.setRenderTarget(this, r), e.clear(t, n, i); e.setRenderTarget(r) } } Xt.prototype.isWebGLCubeRenderTarget = !0; const Jt = new O, Kt = new O, Zt = new M; class qt { constructor(e = new O(1, 0, 0), t = 0) { this.normal = e, this.constant = t } set(e, t) { return this.normal.copy(e), this.constant = t, this } setComponents(e, t, n, i) { return this.normal.set(e, t, n), this.constant = i, this } setFromNormalAndCoplanarPoint(e, t) { return this.normal.copy(e), this.constant = -t.dot(this.normal), this } setFromCoplanarPoints(e, t, n) { const i = Jt.subVectors(n, t).cross(Kt.subVectors(e, t)).normalize(); return this.setFromNormalAndCoplanarPoint(i, e), this } copy(e) { return this.normal.copy(e.normal), this.constant = e.constant, this } normalize() { const e = 1 / this.normal.length(); return this.normal.multiplyScalar(e), this.constant *= e, this } negate() { return this.constant *= -1, this.normal.negate(), this } distanceToPoint(e) { return this.normal.dot(e) + this.constant } distanceToSphere(e) { return this.distanceToPoint(e.center) - e.radius } projectPoint(e, t) { return t.copy(this.normal).multiplyScalar(-this.distanceToPoint(e)).add(e) } intersectLine(e, t) { const n = e.delta(Jt), i = this.normal.dot(n); if (0 === i) return 0 === this.distanceToPoint(e.start) ? t.copy(e.start) : null; const r = -(e.start.dot(this.normal) + this.constant) / i; return r < 0 || r > 1 ? null : t.copy(n).multiplyScalar(r).add(e.start) } intersectsLine(e) { const t = this.distanceToPoint(e.start), n = this.distanceToPoint(e.end); return t < 0 && n > 0 || n < 0 && t > 0 } intersectsBox(e) { return e.intersectsPlane(this) } intersectsSphere(e) { return e.intersectsPlane(this) } coplanarPoint(e) { return e.copy(this.normal).multiplyScalar(-this.constant) } applyMatrix4(e, t) { const n = t || Zt.getNormalMatrix(e), i = this.coplanarPoint(Jt).applyMatrix4(e), r = this.normal.applyMatrix3(n).normalize(); return this.constant = -i.dot(r), this } translate(e) { return this.constant -= e.dot(this.normal), this } equals(e) { return e.normal.equals(this.normal) && e.constant === this.constant } clone() { return (new this.constructor).copy(this) } } qt.prototype.isPlane = !0; const _t = new ne, $t = new O; class en { constructor(e = new qt, t = new qt, n = new qt, i = new qt, r = new qt, s = new qt) { this.planes = [e, t, n, i, r, s] } set(e, t, n, i, r, s) { const o = this.planes; return o[0].copy(e), o[1].copy(t), o[2].copy(n), o[3].copy(i), o[4].copy(r), o[5].copy(s), this } copy(e) { const t = this.planes; for (let n = 0; n < 6; n++)t[n].copy(e.planes[n]); return this } setFromProjectionMatrix(e) { const t = this.planes, n = e.elements, i = n[0], r = n[1], s = n[2], o = n[3], a = n[4], l = n[5], c = n[6], A = n[7], u = n[8], h = n[9], d = n[10], p = n[11], f = n[12], g = n[13], m = n[14], v = n[15]; return t[0].setComponents(o - i, A - a, p - u, v - f).normalize(), t[1].setComponents(o + i, A + a, p + u, v + f).normalize(), t[2].setComponents(o + r, A + l, p + h, v + g).normalize(), t[3].setComponents(o - r, A - l, p - h, v - g).normalize(), t[4].setComponents(o - s, A - c, p - d, v - m).normalize(), t[5].setComponents(o + s, A + c, p + d, v + m).normalize(), this } intersectsObject(e) { const t = e.geometry; return null === t.boundingSphere && t.computeBoundingSphere(), _t.copy(t.boundingSphere).applyMatrix4(e.matrixWorld), this.intersectsSphere(_t) } intersectsSprite(e) { return _t.center.set(0, 0, 0), _t.radius = .7071067811865476, _t.applyMatrix4(e.matrixWorld), this.intersectsSphere(_t) } intersectsSphere(e) { const t = this.planes, n = e.center, i = -e.radius; for (let e = 0; e < 6; e++) { if (t[e].distanceToPoint(n) < i) return !1 } return !0 } intersectsBox(e) { const t = this.planes; for (let n = 0; n < 6; n++) { const i = t[n]; if ($t.x = i.normal.x > 0 ? e.max.x : e.min.x, $t.y = i.normal.y > 0 ? e.max.y : e.min.y, $t.z = i.normal.z > 0 ? e.max.z : e.min.z, i.distanceToPoint($t) < 0) return !1 } return !0 } containsPoint(e) { const t = this.planes; for (let n = 0; n < 6; n++)if (t[n].distanceToPoint(e) < 0) return !1; return !0 } clone() { return (new this.constructor).copy(this) } } function tn() { let e = null, t = !1, n = null, i = null; function r(t, s) { n(t, s), i = e.requestAnimationFrame(r) } return { start: function () { !0 !== t && null !== n && (i = e.requestAnimationFrame(r), t = !0) }, stop: function () { e.cancelAnimationFrame(i), t = !1 }, setAnimationLoop: function (e) { n = e }, setContext: function (t) { e = t } } } function nn(e, t) { const n = t.isWebGL2, i = new WeakMap; return { get: function (e) { return e.isInterleavedBufferAttribute && (e = e.data), i.get(e) }, remove: function (t) { t.isInterleavedBufferAttribute && (t = t.data); const n = i.get(t); n && (e.deleteBuffer(n.buffer), i.delete(t)) }, update: function (t, r) { if (t.isGLBufferAttribute) { const e = i.get(t); return void ((!e || e.version < t.version) && i.set(t, { buffer: t.buffer, type: t.type, bytesPerElement: t.elementSize, version: t.version })) } t.isInterleavedBufferAttribute && (t = t.data); const s = i.get(t); void 0 === s ? i.set(t, function (t, i) { const r = t.array, s = t.usage, o = e.createBuffer(); e.bindBuffer(i, o), e.bufferData(i, r, s), t.onUploadCallback(); let a = 5126; return r instanceof Float32Array ? a = 5126 : r instanceof Float64Array ? console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.") : r instanceof Uint16Array ? t.isFloat16BufferAttribute ? n ? a = 5131 : console.warn("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.") : a = 5123 : r instanceof Int16Array ? a = 5122 : r instanceof Uint32Array ? a = 5125 : r instanceof Int32Array ? a = 5124 : r instanceof Int8Array ? a = 5120 : (r instanceof Uint8Array || r instanceof Uint8ClampedArray) && (a = 5121), { buffer: o, type: a, bytesPerElement: r.BYTES_PER_ELEMENT, version: t.version } }(t, r)) : s.version < t.version && (!function (t, i, r) { const s = i.array, o = i.updateRange; e.bindBuffer(r, t), -1 === o.count ? e.bufferSubData(r, 0, s) : (n ? e.bufferSubData(r, o.offset * s.BYTES_PER_ELEMENT, s, o.offset, o.count) : e.bufferSubData(r, o.offset * s.BYTES_PER_ELEMENT, s.subarray(o.offset, o.offset + o.count)), o.count = -1) }(s.buffer, t, r), s.version = t.version) } } } class rn extends vt { constructor(e = 1, t = 1, n = 1, i = 1) { super(), this.type = "PlaneGeometry", this.parameters = { width: e, height: t, widthSegments: n, heightSegments: i }; const r = e / 2, s = t / 2, o = Math.floor(n), a = Math.floor(i), l = o + 1, c = a + 1, A = e / o, u = t / a, h = [], d = [], p = [], f = []; for (let e = 0; e < c; e++) { const t = e * u - s; for (let n = 0; n < l; n++) { const i = n * A - r; d.push(i, -t, 0), p.push(0, 0, 1), f.push(n / o), f.push(1 - e / a) } } for (let e = 0; e < a; e++)for (let t = 0; t < o; t++) { const n = t + l * e, i = t + l * (e + 1), r = t + 1 + l * (e + 1), s = t + 1 + l * e; h.push(n, i, s), h.push(i, r, s) } this.setIndex(h), this.setAttribute("position", new ct(d, 3)), this.setAttribute("normal", new ct(p, 3)), this.setAttribute("uv", new ct(f, 2)) } static fromJSON(e) { return new rn(e.width, e.height, e.widthSegments, e.heightSegments) } } const sn = { alphamap_fragment: "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif", alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif", alphatest_fragment: "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif", aomap_fragment: "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif", aomap_pars_fragment: "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif", begin_vertex: "vec3 transformed = vec3( position );", beginnormal_vertex: "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif", bsdfs: "vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\treturn vec2( -1.04, 1.04 ) * a004 + r.zw;\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n#else\n\tif( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t}\n\treturn 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotVH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nvec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );\n\tvec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;\n\treturn Fr * fresnel + F0;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + viewDir );\n\tfloat dotNL = saturate( dot( normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\treturn specularColor * brdf.x + brdf.y;\n}\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tvec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\tvec3 FssEss = F * brdf.x + brdf.y;\n\tfloat Ess = brdf.x + brdf.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie(float roughness, float NoH) {\n\tfloat invAlpha = 1.0 / roughness;\n\tfloat cos2h = NoH * NoH;\n\tfloat sin2h = max(1.0 - cos2h, 0.0078125);\treturn (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);\n}\nfloat V_Neubelt(float NoV, float NoL) {\n\treturn saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));\n}\nvec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {\n\tvec3 N = geometry.normal;\n\tvec3 V = geometry.viewDir;\n\tvec3 H = normalize( V + L );\n\tfloat dotNH = saturate( dot( N, H ) );\n\treturn specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );\n}\n#endif", bumpmap_pars_fragment: "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif", clipping_planes_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif", clipping_planes_pars_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif", clipping_planes_pars_vertex: "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif", clipping_planes_vertex: "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif", color_fragment: "#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif", color_pars_fragment: "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif", color_pars_vertex: "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif", color_vertex: "#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif", common: "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}", cube_uv_reflection_fragment: "#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_maxMipLevel 8.0\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_maxTileSize 256.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\tfloat texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );\n\t\tvec2 uv = getUV( direction, face ) * ( faceSize - 1.0 );\n\t\tvec2 f = fract( uv );\n\t\tuv += 0.5 - f;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tif ( mipInt < cubeUV_maxMipLevel ) {\n\t\t\tuv.y += 2.0 * cubeUV_maxTileSize;\n\t\t}\n\t\tuv.y += filterInt * 2.0 * cubeUV_minTileSize;\n\t\tuv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );\n\t\tuv *= texelSize;\n\t\tvec3 tl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x += texelSize;\n\t\tvec3 tr = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.y += texelSize;\n\t\tvec3 br = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x -= texelSize;\n\t\tvec3 bl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tvec3 tm = mix( tl, tr, f.x );\n\t\tvec3 bm = mix( bl, br, f.x );\n\t\treturn mix( tm, bm, f.y );\n\t}\n\t#define r0 1.0\n\t#define v0 0.339\n\t#define m0 - 2.0\n\t#define r1 0.8\n\t#define v1 0.276\n\t#define m1 - 1.0\n\t#define r4 0.4\n\t#define v4 0.046\n\t#define m4 2.0\n\t#define r5 0.305\n\t#define v5 0.016\n\t#define m5 3.0\n\t#define r6 0.21\n\t#define v6 0.0038\n\t#define m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= r1 ) {\n\t\t\tmip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n\t\t} else if ( roughness >= r4 ) {\n\t\t\tmip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n\t\t} else if ( roughness >= r5 ) {\n\t\t\tmip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n\t\t} else if ( roughness >= r6 ) {\n\t\t\tmip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif", defaultnormal_vertex: "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif", displacementmap_pars_vertex: "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif", displacementmap_vertex: "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif", emissivemap_fragment: "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif", emissivemap_pars_fragment: "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif", encodings_fragment: "gl_FragColor = linearToOutputTexel( gl_FragColor );", encodings_pars_fragment: "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = clamp( floor( D ) / 255.0, 0.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value ) {\n\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}", envmap_fragment: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifndef ENVMAP_TYPE_CUBE_UV\n\t\tenvColor = envMapTexelToLinear( envColor );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif", envmap_common_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif", envmap_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif", envmap_pars_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif", envmap_physical_pars_fragment: "#if defined( USE_ENVMAP )\n\t#ifdef ENVMAP_MODE_REFRACTION\n\t\tuniform float refractionRatio;\n\t#endif\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat sigma = PI * roughness * roughness / ( 1.0 + roughness );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + log2( sigma );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -viewDir, normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif", envmap_vertex: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif", fog_vertex: "#ifdef USE_FOG\n\tfogDepth = - mvPosition.z;\n#endif", fog_pars_vertex: "#ifdef USE_FOG\n\tvarying float fogDepth;\n#endif", fog_fragment: "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif", fog_pars_fragment: "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif", gradientmap_pars_fragment: "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn texture2D( gradientMap, coord ).rgb;\n\t#else\n\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t#endif\n}", lightmap_fragment: "#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\treflectedLight.indirectDiffuse += PI * lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n#endif", lightmap_pars_fragment: "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif", lights_lambert_vertex: "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry );\n#ifdef DOUBLE_SIDED\n\tvIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n\tvIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry );\n#endif\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif", lights_pars_begin: "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\n\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif", lights_toon_fragment: "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;", lights_toon_pars_fragment: "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )\t(0)", lights_phong_fragment: "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;", lights_phong_pars_fragment: "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)", lights_physical_fragment: "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.specularRoughness = max( roughnessFactor, 0.0525 );material.specularRoughness += geometryRoughness;\nmaterial.specularRoughness = min( material.specularRoughness, 1.0 );\n#ifdef REFLECTIVITY\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#endif\n#ifdef CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheen;\n#endif", lights_physical_pars_fragment: "struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat specularRoughness;\n\tvec3 specularColor;\n#ifdef CLEARCOAT\n\tfloat clearcoat;\n\tfloat clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tvec3 sheenColor;\n#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearcoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = ccDotNL * directLight.color;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tccIrradiance *= PI;\n\t\t#endif\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t\treflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(\n\t\t\tmaterial.specularRoughness,\n\t\t\tdirectLight.direction,\n\t\t\tgeometry,\n\t\t\tmaterial.sheenColor\n\t\t);\n\t#else\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularRoughness);\n\t#endif\n\treflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t\tfloat ccDotNL = ccDotNV;\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\tfloat clearcoatInv = 1.0 - clearcoatDHR;\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\tBRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\treflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}", lights_fragment_begin: "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif", lights_fragment_maps: "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );\n\t#ifdef CLEARCOAT\n\t\tclearcoatRadiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );\n\t#endif\n#endif", lights_fragment_end: "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif", logdepthbuf_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif", logdepthbuf_pars_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif", logdepthbuf_pars_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif", logdepthbuf_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif", map_fragment: "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif", map_pars_fragment: "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif", map_particle_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif", map_particle_pars_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif", metalnessmap_fragment: "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif", metalnessmap_pars_fragment: "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif", morphnormal_vertex: "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n#endif", morphtarget_pars_vertex: "#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifndef USE_MORPHNORMALS\n\t\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\t\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif", morphtarget_vertex: "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t#endif\n#endif", normal_fragment_begin: "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * faceDirection;\n\t\t\tbitangent = bitangent * faceDirection;\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;", normal_fragment_maps: "#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( -vViewPosition, normal, mapN, faceDirection );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif", normalmap_pars_fragment: "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n\t\treturn normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n\t}\n#endif", clearcoat_normal_fragment_begin: "#ifdef CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif", clearcoat_normal_fragment_maps: "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\n\t#endif\n#endif", clearcoat_pars_fragment: "#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif", packing: "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ));\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}", premultiplied_alpha_fragment: "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif", project_vertex: "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;", dithering_fragment: "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif", dithering_pars_fragment: "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif", roughnessmap_fragment: "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif", roughnessmap_pars_fragment: "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif", shadowmap_pars_fragment: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif", shadowmap_pars_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif", shadowmap_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n\t\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\tvec4 shadowWorldPosition;\n\t#endif\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n#endif", shadowmask_pars_fragment: "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}", skinbase_vertex: "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif", skinning_pars_vertex: "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform highp sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif", skinning_vertex: "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif", skinnormal_vertex: "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif", specularmap_fragment: "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif", specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif", tonemapping_fragment: "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif", tonemapping_pars_fragment: "#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }", transmission_fragment: "#ifdef USE_TRANSMISSION\n\tfloat transmissionFactor = transmission;\n\tfloat thicknessFactor = thickness;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\ttransmissionFactor *= texture2D( transmissionMap, vUv ).r;\n\t#endif\n\t#ifdef USE_THICKNESSNMAP\n\t\tthicknessFactor *= texture2D( thicknessMap, vUv ).g;\n\t#endif\n\tvec3 pos = vWorldPosition.xyz / vWorldPosition.w;\n\tvec3 v = normalize( cameraPosition - pos );\n\tfloat ior = ( 1.0 + 0.4 * reflectivity ) / ( 1.0 - 0.4 * reflectivity );\n\tvec3 transmission = transmissionFactor * getIBLVolumeRefraction(\n\t\tnormal, v, roughnessFactor, material.diffuseColor, totalSpecular,\n\t\tpos, modelMatrix, viewMatrix, projectionMatrix, ior, thicknessFactor,\n\t\tattenuationColor, attenuationDistance );\n\ttotalDiffuse = mix( totalDiffuse, transmission, transmissionFactor );\n#endif", transmission_pars_fragment: "#ifdef USE_TRANSMISSION\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tuniform sampler2D transmissionMap;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tuniform sampler2D thicknessMap;\n\t#endif\n\tuniform vec2 transmissionSamplerSize;\n\tuniform sampler2D transmissionSamplerMap;\n\tuniform mat4 modelMatrix;\n\tuniform mat4 projectionMatrix;\n\tvarying vec4 vWorldPosition;\n\tvec3 getVolumeTransmissionRay(vec3 n, vec3 v, float thickness, float ior, mat4 modelMatrix) {\n\t\tvec3 refractionVector = refract(-v, normalize(n), 1.0 / ior);\n\t\tvec3 modelScale;\n\t\tmodelScale.x = length(vec3(modelMatrix[0].xyz));\n\t\tmodelScale.y = length(vec3(modelMatrix[1].xyz));\n\t\tmodelScale.z = length(vec3(modelMatrix[2].xyz));\n\t\treturn normalize(refractionVector) * thickness * modelScale;\n\t}\n\tfloat applyIorToRoughness(float roughness, float ior) {\n\t\treturn roughness * clamp(ior * 2.0 - 2.0, 0.0, 1.0);\n\t}\n\tvec3 getTransmissionSample(vec2 fragCoord, float roughness, float ior) {\n\t\tfloat framebufferLod = log2(transmissionSamplerSize.x) * applyIorToRoughness(roughness, ior);\n\t\treturn texture2DLodEXT(transmissionSamplerMap, fragCoord.xy, framebufferLod).rgb;\n\t}\n\tvec3 applyVolumeAttenuation(vec3 radiance, float transmissionDistance, vec3 attenuationColor, float attenuationDistance) {\n\t\tif (attenuationDistance == 0.0) {\n\t\t\treturn radiance;\n\t\t} else {\n\t\t\tvec3 attenuationCoefficient = -log(attenuationColor) / attenuationDistance;\n\t\t\tvec3 transmittance = exp(-attenuationCoefficient * transmissionDistance);\t\t\treturn transmittance * radiance;\n\t\t}\n\t}\n\tvec3 getIBLVolumeRefraction(vec3 n, vec3 v, float perceptualRoughness, vec3 baseColor, vec3 specularColor,\n\t\tvec3 position, mat4 modelMatrix, mat4 viewMatrix, mat4 projMatrix, float ior, float thickness,\n\t\tvec3 attenuationColor, float attenuationDistance) {\n\t\tvec3 transmissionRay = getVolumeTransmissionRay(n, v, thickness, ior, modelMatrix);\n\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4(refractedRayExit, 1.0);\n\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\trefractionCoords += 1.0;\n\t\trefractionCoords /= 2.0;\n\t\tvec3 transmittedLight = getTransmissionSample(refractionCoords, perceptualRoughness, ior);\n\t\tvec3 attenuatedColor = applyVolumeAttenuation(transmittedLight, length(transmissionRay), attenuationColor, attenuationDistance);\n\t\treturn (1.0 - specularColor) * attenuatedColor * baseColor;\n\t}\n#endif", uv_pars_fragment: "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif", uv_pars_vertex: "#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif", uv_vertex: "#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif", uv2_pars_fragment: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif", uv2_pars_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif", uv2_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif", worldpos_vertex: "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif", background_frag: "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}", background_vert: "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}", cube_frag: "#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\tvec3 vReflect = vWorldDirection;\n\t#include <envmap_fragment>\n\tgl_FragColor = envColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}", cube_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}", depth_frag: "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}", depth_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}", distanceRGBA_frag: "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}", distanceRGBA_vert: "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}", equirect_frag: "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}", equirect_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}", linedashed_frag: "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}", linedashed_vert: "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}", meshbasic_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}", meshbasic_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}", meshlambert_frag: "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}", meshlambert_vert: "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}", meshmatcap_frag: "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\t#else\n\t\tvec4 matcapColor = vec4( 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}", meshmatcap_vert: "#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#ifndef FLAT_SHADED\n\t\tvNormal = normalize( transformedNormal );\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}", meshtoon_frag: "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}", meshtoon_vert: "#define TOON\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}", meshphong_frag: "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}", meshphong_vert: "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}", meshphysical_frag: "#define STANDARD\n#ifdef PHYSICAL\n\t#define REFLECTIVITY\n\t#define CLEARCOAT\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef USE_TRANSMISSION\n\tuniform float transmission;\n\tuniform float thickness;\n\tuniform vec3 attenuationColor;\n\tuniform float attenuationDistance;\n#endif\n#ifdef REFLECTIVITY\n\tuniform float reflectivity;\n#endif\n#ifdef CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheen;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <transmission_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\t#include <transmission_fragment>\n\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}", meshphysical_vert: "#define STANDARD\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#ifdef USE_TRANSMISSION\n\tvarying vec4 vWorldPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n\tvWorldPosition = worldPosition;\n#endif\n}", normal_frag: "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}", normal_vert: "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}", points_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}", points_vert: "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}", shadow_frag: "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}", shadow_vert: "#include <common>\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}", sprite_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}", sprite_vert: "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}" }, on = { common: { diffuse: { value: new nt(16777215) }, opacity: { value: 1 }, map: { value: null }, uvTransform: { value: new M }, uv2Transform: { value: new M }, alphaMap: { value: null } }, specularmap: { specularMap: { value: null } }, envmap: { envMap: { value: null }, flipEnvMap: { value: -1 }, reflectivity: { value: 1 }, refractionRatio: { value: .98 }, maxMipLevel: { value: 0 } }, aomap: { aoMap: { value: null }, aoMapIntensity: { value: 1 } }, lightmap: { lightMap: { value: null }, lightMapIntensity: { value: 1 } }, emissivemap: { emissiveMap: { value: null } }, bumpmap: { bumpMap: { value: null }, bumpScale: { value: 1 } }, normalmap: { normalMap: { value: null }, normalScale: { value: new b(1, 1) } }, displacementmap: { displacementMap: { value: null }, displacementScale: { value: 1 }, displacementBias: { value: 0 } }, roughnessmap: { roughnessMap: { value: null } }, metalnessmap: { metalnessMap: { value: null } }, gradientmap: { gradientMap: { value: null } }, fog: { fogDensity: { value: 25e-5 }, fogNear: { value: 1 }, fogFar: { value: 2e3 }, fogColor: { value: new nt(16777215) } }, lights: { ambientLightColor: { value: [] }, lightProbe: { value: [] }, directionalLights: { value: [], properties: { direction: {}, color: {} } }, directionalLightShadows: { value: [], properties: { shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {} } }, directionalShadowMap: { value: [] }, directionalShadowMatrix: { value: [] }, spotLights: { value: [], properties: { color: {}, position: {}, direction: {}, distance: {}, coneCos: {}, penumbraCos: {}, decay: {} } }, spotLightShadows: { value: [], properties: { shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {} } }, spotShadowMap: { value: [] }, spotShadowMatrix: { value: [] }, pointLights: { value: [], properties: { color: {}, position: {}, decay: {}, distance: {} } }, pointLightShadows: { value: [], properties: { shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {}, shadowCameraNear: {}, shadowCameraFar: {} } }, pointShadowMap: { value: [] }, pointShadowMatrix: { value: [] }, hemisphereLights: { value: [], properties: { direction: {}, skyColor: {}, groundColor: {} } }, rectAreaLights: { value: [], properties: { color: {}, position: {}, width: {}, height: {} } }, ltc_1: { value: null }, ltc_2: { value: null } }, points: { diffuse: { value: new nt(16777215) }, opacity: { value: 1 }, size: { value: 1 }, scale: { value: 1 }, map: { value: null }, alphaMap: { value: null }, uvTransform: { value: new M } }, sprite: { diffuse: { value: new nt(16777215) }, opacity: { value: 1 }, center: { value: new b(.5, .5) }, rotation: { value: 0 }, map: { value: null }, alphaMap: { value: null }, uvTransform: { value: new M } } }, an = { basic: { uniforms: Qt([on.common, on.specularmap, on.envmap, on.aomap, on.lightmap, on.fog]), vertexShader: sn.meshbasic_vert, fragmentShader: sn.meshbasic_frag }, lambert: { uniforms: Qt([on.common, on.specularmap, on.envmap, on.aomap, on.lightmap, on.emissivemap, on.fog, on.lights, { emissive: { value: new nt(0) } }]), vertexShader: sn.meshlambert_vert, fragmentShader: sn.meshlambert_frag }, phong: { uniforms: Qt([on.common, on.specularmap, on.envmap, on.aomap, on.lightmap, on.emissivemap, on.bumpmap, on.normalmap, on.displacementmap, on.fog, on.lights, { emissive: { value: new nt(0) }, specular: { value: new nt(1118481) }, shininess: { value: 30 } }]), vertexShader: sn.meshphong_vert, fragmentShader: sn.meshphong_frag }, standard: { uniforms: Qt([on.common, on.envmap, on.aomap, on.lightmap, on.emissivemap, on.bumpmap, on.normalmap, on.displacementmap, on.roughnessmap, on.metalnessmap, on.fog, on.lights, { emissive: { value: new nt(0) }, roughness: { value: 1 }, metalness: { value: 0 }, envMapIntensity: { value: 1 } }]), vertexShader: sn.meshphysical_vert, fragmentShader: sn.meshphysical_frag }, toon: { uniforms: Qt([on.common, on.aomap, on.lightmap, on.emissivemap, on.bumpmap, on.normalmap, on.displacementmap, on.gradientmap, on.fog, on.lights, { emissive: { value: new nt(0) } }]), vertexShader: sn.meshtoon_vert, fragmentShader: sn.meshtoon_frag }, matcap: { uniforms: Qt([on.common, on.bumpmap, on.normalmap, on.displacementmap, on.fog, { matcap: { value: null } }]), vertexShader: sn.meshmatcap_vert, fragmentShader: sn.meshmatcap_frag }, points: { uniforms: Qt([on.points, on.fog]), vertexShader: sn.points_vert, fragmentShader: sn.points_frag }, dashed: { uniforms: Qt([on.common, on.fog, { scale: { value: 1 }, dashSize: { value: 1 }, totalSize: { value: 2 } }]), vertexShader: sn.linedashed_vert, fragmentShader: sn.linedashed_frag }, depth: { uniforms: Qt([on.common, on.displacementmap]), vertexShader: sn.depth_vert, fragmentShader: sn.depth_frag }, normal: { uniforms: Qt([on.common, on.bumpmap, on.normalmap, on.displacementmap, { opacity: { value: 1 } }]), vertexShader: sn.normal_vert, fragmentShader: sn.normal_frag }, sprite: { uniforms: Qt([on.sprite, on.fog]), vertexShader: sn.sprite_vert, fragmentShader: sn.sprite_frag }, background: { uniforms: { uvTransform: { value: new M }, t2D: { value: null } }, vertexShader: sn.background_vert, fragmentShader: sn.background_frag }, cube: { uniforms: Qt([on.envmap, { opacity: { value: 1 } }]), vertexShader: sn.cube_vert, fragmentShader: sn.cube_frag }, equirect: { uniforms: { tEquirect: { value: null } }, vertexShader: sn.equirect_vert, fragmentShader: sn.equirect_frag }, distanceRGBA: { uniforms: Qt([on.common, on.displacementmap, { referencePosition: { value: new O }, nearDistance: { value: 1 }, farDistance: { value: 1e3 } }]), vertexShader: sn.distanceRGBA_vert, fragmentShader: sn.distanceRGBA_frag }, shadow: { uniforms: Qt([on.lights, on.fog, { color: { value: new nt(0) }, opacity: { value: 1 } }]), vertexShader: sn.shadow_vert, fragmentShader: sn.shadow_frag } }; function ln(e, t, n, i, r) { const s = new nt(0); let o, a, l = 0, c = null, A = 0, u = null; function h(e, t) { n.buffers.color.setClear(e.r, e.g, e.b, t, r) } return { getClearColor: function () { return s }, setClearColor: function (e, t = 1) { s.set(e), l = t, h(s, l) }, getClearAlpha: function () { return l }, setClearAlpha: function (e) { l = e, h(s, l) }, render: function (n, r) { let d = !1, p = !0 === r.isScene ? r.background : null; p && p.isTexture && (p = t.get(p)); const f = e.xr, g = f.getSession && f.getSession(); g && "additive" === g.environmentBlendMode && (p = null), null === p ? h(s, l) : p && p.isColor && (h(p, 1), d = !0), (e.autoClear || d) && e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil), p && (p.isCubeTexture || 306 === p.mapping) ? (void 0 === a && (a = new kt(new zt(1, 1, 1), new jt({ name: "BackgroundCubeMaterial", uniforms: Ft(an.cube.uniforms), vertexShader: an.cube.vertexShader, fragmentShader: an.cube.fragmentShader, side: 1, depthTest: !1, depthWrite: !1, fog: !1 })), a.geometry.deleteAttribute("normal"), a.geometry.deleteAttribute("uv"), a.onBeforeRender = function (e, t, n) { this.matrixWorld.copyPosition(n.matrixWorld) }, Object.defineProperty(a.material, "envMap", { get: function () { return this.uniforms.envMap.value } }), i.update(a)), a.material.uniforms.envMap.value = p, a.material.uniforms.flipEnvMap.value = p.isCubeTexture && p._needsFlipEnvMap ? -1 : 1, c === p && A === p.version && u === e.toneMapping || (a.material.needsUpdate = !0, c = p, A = p.version, u = e.toneMapping), n.unshift(a, a.geometry, a.material, 0, 0, null)) : p && p.isTexture && (void 0 === o && (o = new kt(new rn(2, 2), new jt({ name: "BackgroundMaterial", uniforms: Ft(an.background.uniforms), vertexShader: an.background.vertexShader, fragmentShader: an.background.fragmentShader, side: 0, depthTest: !1, depthWrite: !1, fog: !1 })), o.geometry.deleteAttribute("normal"), Object.defineProperty(o.material, "map", { get: function () { return this.uniforms.t2D.value } }), i.update(o)), o.material.uniforms.t2D.value = p, !0 === p.matrixAutoUpdate && p.updateMatrix(), o.material.uniforms.uvTransform.value.copy(p.matrix), c === p && A === p.version && u === e.toneMapping || (o.material.needsUpdate = !0, c = p, A = p.version, u = e.toneMapping), n.unshift(o, o.geometry, o.material, 0, 0, null)) } } } function cn(e, t, n, i) { const r = e.getParameter(34921), s = i.isWebGL2 ? null : t.get("OES_vertex_array_object"), o = i.isWebGL2 || null !== s, a = {}, l = h(null); let c = l; function A(t) { return i.isWebGL2 ? e.bindVertexArray(t) : s.bindVertexArrayOES(t) } function u(t) { return i.isWebGL2 ? e.deleteVertexArray(t) : s.deleteVertexArrayOES(t) } function h(e) { const t = [], n = [], i = []; for (let e = 0; e < r; e++)t[e] = 0, n[e] = 0, i[e] = 0; return { geometry: null, program: null, wireframe: !1, newAttributes: t, enabledAttributes: n, attributeDivisors: i, object: e, attributes: {}, index: null } } function d() { const e = c.newAttributes; for (let t = 0, n = e.length; t < n; t++)e[t] = 0 } function p(e) { f(e, 0) } function f(n, r) { const s = c.newAttributes, o = c.enabledAttributes, a = c.attributeDivisors; if (s[n] = 1, 0 === o[n] && (e.enableVertexAttribArray(n), o[n] = 1), a[n] !== r) { (i.isWebGL2 ? e : t.get("ANGLE_instanced_arrays"))[i.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](n, r), a[n] = r } } function g() { const t = c.newAttributes, n = c.enabledAttributes; for (let i = 0, r = n.length; i < r; i++)n[i] !== t[i] && (e.disableVertexAttribArray(i), n[i] = 0) } function m(t, n, r, s, o, a) { !0 !== i.isWebGL2 || 5124 !== r && 5125 !== r ? e.vertexAttribPointer(t, n, r, s, o, a) : e.vertexAttribIPointer(t, n, r, o, a) } function v() { y(), c !== l && (c = l, A(c.object)) } function y() { l.geometry = null, l.program = null, l.wireframe = !1 } return { setup: function (r, l, u, v, y) { let w = !1; if (o) { const t = function (t, n, r) { const o = !0 === r.wireframe; let l = a[t.id]; void 0 === l && (l = {}, a[t.id] = l); let c = l[n.id]; void 0 === c && (c = {}, l[n.id] = c); let A = c[o]; void 0 === A && (A = h(i.isWebGL2 ? e.createVertexArray() : s.createVertexArrayOES()), c[o] = A); return A }(v, u, l); c !== t && (c = t, A(c.object)), w = function (e, t) { const n = c.attributes, i = e.attributes; let r = 0; for (const e in i) { const t = n[e], s = i[e]; if (void 0 === t) return !0; if (t.attribute !== s) return !0; if (t.data !== s.data) return !0; r++ } return c.attributesNum !== r || c.index !== t }(v, y), w && function (e, t) { const n = {}, i = e.attributes; let r = 0; for (const e in i) { const t = i[e], s = {}; s.attribute = t, t.data && (s.data = t.data), n[e] = s, r++ } c.attributes = n, c.attributesNum = r, c.index = t }(v, y) } else { const e = !0 === l.wireframe; c.geometry === v.id && c.program === u.id && c.wireframe === e || (c.geometry = v.id, c.program = u.id, c.wireframe = e, w = !0) } !0 === r.isInstancedMesh && (w = !0), null !== y && n.update(y, 34963), w && (!function (r, s, o, a) { if (!1 === i.isWebGL2 && (r.isInstancedMesh || a.isInstancedBufferGeometry) && null === t.get("ANGLE_instanced_arrays")) return; d(); const l = a.attributes, c = o.getAttributes(), A = s.defaultAttributeValues; for (const t in c) { const i = c[t]; if (i >= 0) { const s = l[t]; if (void 0 !== s) { const t = s.normalized, r = s.itemSize, o = n.get(s); if (void 0 === o) continue; const l = o.buffer, c = o.type, A = o.bytesPerElement; if (s.isInterleavedBufferAttribute) { const n = s.data, o = n.stride, u = s.offset; n && n.isInstancedInterleavedBuffer ? (f(i, n.meshPerAttribute), void 0 === a._maxInstanceCount && (a._maxInstanceCount = n.meshPerAttribute * n.count)) : p(i), e.bindBuffer(34962, l), m(i, r, c, t, o * A, u * A) } else s.isInstancedBufferAttribute ? (f(i, s.meshPerAttribute), void 0 === a._maxInstanceCount && (a._maxInstanceCount = s.meshPerAttribute * s.count)) : p(i), e.bindBuffer(34962, l), m(i, r, c, t, 0, 0) } else if ("instanceMatrix" === t) { const t = n.get(r.instanceMatrix); if (void 0 === t) continue; const s = t.buffer, o = t.type; f(i + 0, 1), f(i + 1, 1), f(i + 2, 1), f(i + 3, 1), e.bindBuffer(34962, s), e.vertexAttribPointer(i + 0, 4, o, !1, 64, 0), e.vertexAttribPointer(i + 1, 4, o, !1, 64, 16), e.vertexAttribPointer(i + 2, 4, o, !1, 64, 32), e.vertexAttribPointer(i + 3, 4, o, !1, 64, 48) } else if ("instanceColor" === t) { const t = n.get(r.instanceColor); if (void 0 === t) continue; const s = t.buffer, o = t.type; f(i, 1), e.bindBuffer(34962, s), e.vertexAttribPointer(i, 3, o, !1, 12, 0) } else if (void 0 !== A) { const n = A[t]; if (void 0 !== n) switch (n.length) { case 2: e.vertexAttrib2fv(i, n); break; case 3: e.vertexAttrib3fv(i, n); break; case 4: e.vertexAttrib4fv(i, n); break; default: e.vertexAttrib1fv(i, n) } } } } g() }(r, l, u, v), null !== y && e.bindBuffer(34963, n.get(y).buffer)) }, reset: v, resetDefaultState: y, dispose: function () { v(); for (const e in a) { const t = a[e]; for (const e in t) { const n = t[e]; for (const e in n) u(n[e].object), delete n[e]; delete t[e] } delete a[e] } }, releaseStatesOfGeometry: function (e) { if (void 0 === a[e.id]) return; const t = a[e.id]; for (const e in t) { const n = t[e]; for (const e in n) u(n[e].object), delete n[e]; delete t[e] } delete a[e.id] }, releaseStatesOfProgram: function (e) { for (const t in a) { const n = a[t]; if (void 0 === n[e.id]) continue; const i = n[e.id]; for (const e in i) u(i[e].object), delete i[e]; delete n[e.id] } }, initAttributes: d, enableAttribute: p, disableUnusedAttributes: g } } function An(e, t, n, i) { const r = i.isWebGL2; let s; this.setMode = function (e) { s = e }, this.render = function (t, i) { e.drawArrays(s, t, i), n.update(i, s, 1) }, this.renderInstances = function (i, o, a) { if (0 === a) return; let l, c; if (r) l = e, c = "drawArraysInstanced"; else if (l = t.get("ANGLE_instanced_arrays"), c = "drawArraysInstancedANGLE", null === l) return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."); l[c](s, i, o, a), n.update(o, s, a) } } function un(e, t, n) { let i; function r(t) { if ("highp" === t) { if (e.getShaderPrecisionFormat(35633, 36338).precision > 0 && e.getShaderPrecisionFormat(35632, 36338).precision > 0) return "highp"; t = "mediump" } return "mediump" === t && e.getShaderPrecisionFormat(35633, 36337).precision > 0 && e.getShaderPrecisionFormat(35632, 36337).precision > 0 ? "mediump" : "lowp" } const s = "undefined" != typeof WebGL2RenderingContext && e instanceof WebGL2RenderingContext || "undefined" != typeof WebGL2ComputeRenderingContext && e instanceof WebGL2ComputeRenderingContext; let o = void 0 !== n.precision ? n.precision : "highp"; const a = r(o); a !== o && (console.warn("THREE.WebGLRenderer:", o, "not supported, using", a, "instead."), o = a); const l = s || t.has("WEBGL_draw_buffers"), c = !0 === n.logarithmicDepthBuffer, A = e.getParameter(34930), u = e.getParameter(35660), h = e.getParameter(3379), d = e.getParameter(34076), p = e.getParameter(34921), f = e.getParameter(36347), g = e.getParameter(36348), m = e.getParameter(36349), v = u > 0, y = s || t.has("OES_texture_float"); return { isWebGL2: s, drawBuffers: l, getMaxAnisotropy: function () { if (void 0 !== i) return i; if (!0 === t.has("EXT_texture_filter_anisotropic")) { const n = t.get("EXT_texture_filter_anisotropic"); i = e.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT) } else i = 0; return i }, getMaxPrecision: r, precision: o, logarithmicDepthBuffer: c, maxTextures: A, maxVertexTextures: u, maxTextureSize: h, maxCubemapSize: d, maxAttributes: p, maxVertexUniforms: f, maxVaryings: g, maxFragmentUniforms: m, vertexTextures: v, floatFragmentTextures: y, floatVertexTextures: v && y, maxSamples: s ? e.getParameter(36183) : 0 } } function hn(e) { const t = this; let n = null, i = 0, r = !1, s = !1; const o = new qt, a = new M, l = { value: null, needsUpdate: !1 }; function c() { l.value !== n && (l.value = n, l.needsUpdate = i > 0), t.numPlanes = i, t.numIntersection = 0 } function A(e, n, i, r) { const s = null !== e ? e.length : 0; let c = null; if (0 !== s) { if (c = l.value, !0 !== r || null === c) { const t = i + 4 * s, r = n.matrixWorldInverse; a.getNormalMatrix(r), (null === c || c.length < t) && (c = new Float32Array(t)); for (let t = 0, n = i; t !== s; ++t, n += 4)o.copy(e[t]).applyMatrix4(r, a), o.normal.toArray(c, n), c[n + 3] = o.constant } l.value = c, l.needsUpdate = !0 } return t.numPlanes = s, t.numIntersection = 0, c } this.uniform = l, this.numPlanes = 0, this.numIntersection = 0, this.init = function (e, t, s) { const o = 0 !== e.length || t || 0 !== i || r; return r = t, n = A(e, s, 0), i = e.length, o }, this.beginShadows = function () { s = !0, A(null) }, this.endShadows = function () { s = !1, c() }, this.setState = function (t, o, a) { const u = t.clippingPlanes, h = t.clipIntersection, d = t.clipShadows, p = e.get(t); if (!r || null === u || 0 === u.length || s && !d) s ? A(null) : c(); else { const e = s ? 0 : i, t = 4 * e; let r = p.clippingState || null; l.value = r, r = A(u, o, t, a); for (let e = 0; e !== t; ++e)r[e] = n[e]; p.clippingState = r, this.numIntersection = h ? this.numPlanes : 0, this.numPlanes += e } } } function dn(e) { let t = new WeakMap; function n(e, t) { return 303 === t ? e.mapping = 301 : 304 === t && (e.mapping = 302), e } function i(e) { const n = e.target; n.removeEventListener("dispose", i); const r = t.get(n); void 0 !== r && (t.delete(n), r.dispose()) } return { get: function (r) { if (r && r.isTexture) { const s = r.mapping; if (303 === s || 304 === s) { if (t.has(r)) { return n(t.get(r).texture, r.mapping) } { const s = r.image; if (s && s.height > 0) { const o = e.getRenderTarget(), a = new Xt(s.height / 2); return a.fromEquirectangularTexture(e, r), t.set(r, a), e.setRenderTarget(o), r.addEventListener("dispose", i), n(a.texture, r.mapping) } return null } } } return r }, dispose: function () { t = new WeakMap } } } function pn(e) { const t = {}; function n(n) { if (void 0 !== t[n]) return t[n]; let i; switch (n) { case "WEBGL_depth_texture": i = e.getExtension("WEBGL_depth_texture") || e.getExtension("MOZ_WEBGL_depth_texture") || e.getExtension("WEBKIT_WEBGL_depth_texture"); break; case "EXT_texture_filter_anisotropic": i = e.getExtension("EXT_texture_filter_anisotropic") || e.getExtension("MOZ_EXT_texture_filter_anisotropic") || e.getExtension("WEBKIT_EXT_texture_filter_anisotropic"); break; case "WEBGL_compressed_texture_s3tc": i = e.getExtension("WEBGL_compressed_texture_s3tc") || e.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || e.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc"); break; case "WEBGL_compressed_texture_pvrtc": i = e.getExtension("WEBGL_compressed_texture_pvrtc") || e.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"); break; default: i = e.getExtension(n) }return t[n] = i, i } return { has: function (e) { return null !== n(e) }, init: function (e) { e.isWebGL2 ? n("EXT_color_buffer_float") : (n("WEBGL_depth_texture"), n("OES_texture_float"), n("OES_texture_half_float"), n("OES_texture_half_float_linear"), n("OES_standard_derivatives"), n("OES_element_index_uint"), n("OES_vertex_array_object"), n("ANGLE_instanced_arrays")), n("OES_texture_float_linear"), n("EXT_color_buffer_half_float") }, get: function (e) { const t = n(e); return null === t && console.warn("THREE.WebGLRenderer: " + e + " extension not supported."), t } } } function fn(e, t, n, i) { const r = {}, s = new WeakMap; function o(e) { const a = e.target; null !== a.index && t.remove(a.index); for (const e in a.attributes) t.remove(a.attributes[e]); a.removeEventListener("dispose", o), delete r[a.id]; const l = s.get(a); l && (t.remove(l), s.delete(a)), i.releaseStatesOfGeometry(a), !0 === a.isInstancedBufferGeometry && delete a._maxInstanceCount, n.memory.geometries-- } function a(e) { const n = [], i = e.index, r = e.attributes.position; let o = 0; if (null !== i) { const e = i.array; o = i.version; for (let t = 0, i = e.length; t < i; t += 3) { const i = e[t + 0], r = e[t + 1], s = e[t + 2]; n.push(i, r, r, s, s, i) } } else { const e = r.array; o = r.version; for (let t = 0, i = e.length / 3 - 1; t < i; t += 3) { const e = t + 0, i = t + 1, r = t + 2; n.push(e, i, i, r, r, e) } } const a = new (At(n) > 65535 ? lt : at)(n, 1); a.version = o; const l = s.get(e); l && t.remove(l), s.set(e, a) } return { get: function (e, t) { return !0 === r[t.id] || (t.addEventListener("dispose", o), r[t.id] = !0, n.memory.geometries++), t }, update: function (e) { const n = e.attributes; for (const e in n) t.update(n[e], 34962); const i = e.morphAttributes; for (const e in i) { const n = i[e]; for (let e = 0, i = n.length; e < i; e++)t.update(n[e], 34962) } }, getWireframeAttribute: function (e) { const t = s.get(e); if (t) { const n = e.index; null !== n && t.version < n.version && a(e) } else a(e); return s.get(e) } } } function gn(e, t, n, i) { const r = i.isWebGL2; let s, o, a; this.setMode = function (e) { s = e }, this.setIndex = function (e) { o = e.type, a = e.bytesPerElement }, this.render = function (t, i) { e.drawElements(s, i, o, t * a), n.update(i, s, 1) }, this.renderInstances = function (i, l, c) { if (0 === c) return; let A, u; if (r) A = e, u = "drawElementsInstanced"; else if (A = t.get("ANGLE_instanced_arrays"), u = "drawElementsInstancedANGLE", null === A) return void console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."); A[u](s, l, o, i * a, c), n.update(l, s, c) } } function mn(e) { const t = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 }; return { memory: { geometries: 0, textures: 0 }, render: t, programs: null, autoReset: !0, reset: function () { t.frame++, t.calls = 0, t.triangles = 0, t.points = 0, t.lines = 0 }, update: function (e, n, i) { switch (t.calls++, n) { case 4: t.triangles += i * (e / 3); break; case 1: t.lines += i * (e / 2); break; case 3: t.lines += i * (e - 1); break; case 2: t.lines += i * e; break; case 0: t.points += i * e; break; default: console.error("THREE.WebGLInfo: Unknown draw mode:", n) } } } } function vn(e, t) { return e[0] - t[0] } function yn(e, t) { return Math.abs(t[1]) - Math.abs(e[1]) } function wn(e) { const t = {}, n = new Float32Array(8), i = []; for (let e = 0; e < 8; e++)i[e] = [e, 0]; return { update: function (r, s, o, a) { const l = r.morphTargetInfluences, c = void 0 === l ? 0 : l.length; let A = t[s.id]; if (void 0 === A || A.length !== c) { A = []; for (let e = 0; e < c; e++)A[e] = [e, 0]; t[s.id] = A } for (let e = 0; e < c; e++) { const t = A[e]; t[0] = e, t[1] = l[e] } A.sort(yn); for (let e = 0; e < 8; e++)e < c && A[e][1] ? (i[e][0] = A[e][0], i[e][1] = A[e][1]) : (i[e][0] = Number.MAX_SAFE_INTEGER, i[e][1] = 0); i.sort(vn); const u = o.morphTargets && s.morphAttributes.position, h = o.morphNormals && s.morphAttributes.normal; let d = 0; for (let e = 0; e < 8; e++) { const t = i[e], r = t[0], o = t[1]; r !== Number.MAX_SAFE_INTEGER && o ? (u && s.getAttribute("morphTarget" + e) !== u[r] && s.setAttribute("morphTarget" + e, u[r]), h && s.getAttribute("morphNormal" + e) !== h[r] && s.setAttribute("morphNormal" + e, h[r]), n[e] = o, d += o) : (u && !0 === s.hasAttribute("morphTarget" + e) && s.deleteAttribute("morphTarget" + e), h && !0 === s.hasAttribute("morphNormal" + e) && s.deleteAttribute("morphNormal" + e), n[e] = 0) } const p = s.morphTargetsRelative ? 1 : 1 - d; a.getUniforms().setValue(e, "morphTargetBaseInfluence", p), a.getUniforms().setValue(e, "morphTargetInfluences", n) } } } function xn(e, t, n, i) { let r = new WeakMap; function s(e) { const t = e.target; t.removeEventListener("dispose", s), n.remove(t.instanceMatrix), null !== t.instanceColor && n.remove(t.instanceColor) } return { update: function (e) { const o = i.render.frame, a = e.geometry, l = t.get(e, a); return r.get(l) !== o && (t.update(l), r.set(l, o)), e.isInstancedMesh && (!1 === e.hasEventListener("dispose", s) && e.addEventListener("dispose", s), n.update(e.instanceMatrix, 34962), null !== e.instanceColor && n.update(e.instanceColor, 34962)), l }, dispose: function () { r = new WeakMap } } } an.physical = { uniforms: Qt([an.standard.uniforms, { clearcoat: { value: 0 }, clearcoatMap: { value: null }, clearcoatRoughness: { value: 0 }, clearcoatRoughnessMap: { value: null }, clearcoatNormalScale: { value: new b(1, 1) }, clearcoatNormalMap: { value: null }, sheen: { value: new nt(0) }, transmission: { value: 0 }, transmissionMap: { value: null }, transmissionSamplerSize: { value: new b }, transmissionSamplerMap: { value: null }, thickness: { value: 0 }, thicknessMap: { value: null }, attenuationDistance: { value: 0 }, attenuationColor: { value: new nt(0) } }]), vertexShader: sn.meshphysical_vert, fragmentShader: sn.meshphysical_frag }; class Cn extends P { constructor(e = null, t = 1, n = 1, i = 1) { super(null), this.image = { data: e, width: t, height: n, depth: i }, this.magFilter = 1003, this.minFilter = 1003, this.wrapR = 1001, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1, this.needsUpdate = !0 } } Cn.prototype.isDataTexture2DArray = !0; class bn extends P { constructor(e = null, t = 1, n = 1, i = 1) { super(null), this.image = { data: e, width: t, height: n, depth: i }, this.magFilter = 1003, this.minFilter = 1003, this.wrapR = 1001, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1, this.needsUpdate = !0 } } bn.prototype.isDataTexture3D = !0; const Mn = new P, In = new Cn, En = new bn, Tn = new Wt, Pn = [], Sn = [], Bn = new Float32Array(16), Dn = new Float32Array(9), Rn = new Float32Array(4); function Ln(e, t, n) { const i = e[0]; if (i <= 0 || i > 0) return e; const r = t * n; let s = Pn[r]; if (void 0 === s && (s = new Float32Array(r), Pn[r] = s), 0 !== t) { i.toArray(s, 0); for (let i = 1, r = 0; i !== t; ++i)r += n, e[i].toArray(s, r) } return s } function On(e, t) { if (e.length !== t.length) return !1; for (let n = 0, i = e.length; n < i; n++)if (e[n] !== t[n]) return !1; return !0 } function Nn(e, t) { for (let n = 0, i = t.length; n < i; n++)e[n] = t[n] } function kn(e, t) { let n = Sn[t]; void 0 === n && (n = new Int32Array(t), Sn[t] = n); for (let i = 0; i !== t; ++i)n[i] = e.allocateTextureUnit(); return n } function Hn(e, t) { const n = this.cache; n[0] !== t && (e.uniform1f(this.addr, t), n[0] = t) } function zn(e, t) { const n = this.cache; if (void 0 !== t.x) n[0] === t.x && n[1] === t.y || (e.uniform2f(this.addr, t.x, t.y), n[0] = t.x, n[1] = t.y); else { if (On(n, t)) return; e.uniform2fv(this.addr, t), Nn(n, t) } } function Fn(e, t) { const n = this.cache; if (void 0 !== t.x) n[0] === t.x && n[1] === t.y && n[2] === t.z || (e.uniform3f(this.addr, t.x, t.y, t.z), n[0] = t.x, n[1] = t.y, n[2] = t.z); else if (void 0 !== t.r) n[0] === t.r && n[1] === t.g && n[2] === t.b || (e.uniform3f(this.addr, t.r, t.g, t.b), n[0] = t.r, n[1] = t.g, n[2] = t.b); else { if (On(n, t)) return; e.uniform3fv(this.addr, t), Nn(n, t) } } function Qn(e, t) { const n = this.cache; if (void 0 !== t.x) n[0] === t.x && n[1] === t.y && n[2] === t.z && n[3] === t.w || (e.uniform4f(this.addr, t.x, t.y, t.z, t.w), n[0] = t.x, n[1] = t.y, n[2] = t.z, n[3] = t.w); else { if (On(n, t)) return; e.uniform4fv(this.addr, t), Nn(n, t) } } function Gn(e, t) { const n = this.cache, i = t.elements; if (void 0 === i) { if (On(n, t)) return; e.uniformMatrix2fv(this.addr, !1, t), Nn(n, t) } else { if (On(n, i)) return; Rn.set(i), e.uniformMatrix2fv(this.addr, !1, Rn), Nn(n, i) } } function jn(e, t) { const n = this.cache, i = t.elements; if (void 0 === i) { if (On(n, t)) return; e.uniformMatrix3fv(this.addr, !1, t), Nn(n, t) } else { if (On(n, i)) return; Dn.set(i), e.uniformMatrix3fv(this.addr, !1, Dn), Nn(n, i) } } function Un(e, t) { const n = this.cache, i = t.elements; if (void 0 === i) { if (On(n, t)) return; e.uniformMatrix4fv(this.addr, !1, t), Nn(n, t) } else { if (On(n, i)) return; Bn.set(i), e.uniformMatrix4fv(this.addr, !1, Bn), Nn(n, i) } } function Vn(e, t) { const n = this.cache; n[0] !== t && (e.uniform1i(this.addr, t), n[0] = t) } function Yn(e, t) { const n = this.cache; On(n, t) || (e.uniform2iv(this.addr, t), Nn(n, t)) } function Wn(e, t) { const n = this.cache; On(n, t) || (e.uniform3iv(this.addr, t), Nn(n, t)) } function Xn(e, t) { const n = this.cache; On(n, t) || (e.uniform4iv(this.addr, t), Nn(n, t)) } function Jn(e, t) { const n = this.cache; n[0] !== t && (e.uniform1ui(this.addr, t), n[0] = t) } function Kn(e, t) { const n = this.cache; On(n, t) || (e.uniform2uiv(this.addr, t), Nn(n, t)) } function Zn(e, t) { const n = this.cache; On(n, t) || (e.uniform3uiv(this.addr, t), Nn(n, t)) } function qn(e, t) { const n = this.cache; On(n, t) || (e.uniform4uiv(this.addr, t), Nn(n, t)) } function _n(e, t, n) { const i = this.cache, r = n.allocateTextureUnit(); i[0] !== r && (e.uniform1i(this.addr, r), i[0] = r), n.safeSetTexture2D(t || Mn, r) } function $n(e, t, n) { const i = this.cache, r = n.allocateTextureUnit(); i[0] !== r && (e.uniform1i(this.addr, r), i[0] = r), n.setTexture3D(t || En, r) } function ei(e, t, n) { const i = this.cache, r = n.allocateTextureUnit(); i[0] !== r && (e.uniform1i(this.addr, r), i[0] = r), n.safeSetTextureCube(t || Tn, r) } function ti(e, t, n) { const i = this.cache, r = n.allocateTextureUnit(); i[0] !== r && (e.uniform1i(this.addr, r), i[0] = r), n.setTexture2DArray(t || In, r) } function ni(e, t) { e.uniform1fv(this.addr, t) } function ii(e, t) { const n = Ln(t, this.size, 2); e.uniform2fv(this.addr, n) } function ri(e, t) { const n = Ln(t, this.size, 3); e.uniform3fv(this.addr, n) } function si(e, t) { const n = Ln(t, this.size, 4); e.uniform4fv(this.addr, n) } function oi(e, t) { const n = Ln(t, this.size, 4); e.uniformMatrix2fv(this.addr, !1, n) } function ai(e, t) { const n = Ln(t, this.size, 9); e.uniformMatrix3fv(this.addr, !1, n) } function li(e, t) { const n = Ln(t, this.size, 16); e.uniformMatrix4fv(this.addr, !1, n) } function ci(e, t) { e.uniform1iv(this.addr, t) } function Ai(e, t) { e.uniform2iv(this.addr, t) } function ui(e, t) { e.uniform3iv(this.addr, t) } function hi(e, t) { e.uniform4iv(this.addr, t) } function di(e, t) { e.uniform1uiv(this.addr, t) } function pi(e, t) { e.uniform2uiv(this.addr, t) } function fi(e, t) { e.uniform3uiv(this.addr, t) } function gi(e, t) { e.uniform4uiv(this.addr, t) } function mi(e, t, n) { const i = t.length, r = kn(n, i); e.uniform1iv(this.addr, r); for (let e = 0; e !== i; ++e)n.safeSetTexture2D(t[e] || Mn, r[e]) } function vi(e, t, n) { const i = t.length, r = kn(n, i); e.uniform1iv(this.addr, r); for (let e = 0; e !== i; ++e)n.safeSetTextureCube(t[e] || Tn, r[e]) } function yi(e, t, n) { this.id = e, this.addr = n, this.cache = [], this.setValue = function (e) { switch (e) { case 5126: return Hn; case 35664: return zn; case 35665: return Fn; case 35666: return Qn; case 35674: return Gn; case 35675: return jn; case 35676: return Un; case 5124: case 35670: return Vn; case 35667: case 35671: return Yn; case 35668: case 35672: return Wn; case 35669: case 35673: return Xn; case 5125: return Jn; case 36294: return Kn; case 36295: return Zn; case 36296: return qn; case 35678: case 36198: case 36298: case 36306: case 35682: return _n; case 35679: case 36299: case 36307: return $n; case 35680: case 36300: case 36308: case 36293: return ei; case 36289: case 36303: case 36311: case 36292: return ti } }(t.type) } function wi(e, t, n) { this.id = e, this.addr = n, this.cache = [], this.size = t.size, this.setValue = function (e) { switch (e) { case 5126: return ni; case 35664: return ii; case 35665: return ri; case 35666: return si; case 35674: return oi; case 35675: return ai; case 35676: return li; case 5124: case 35670: return ci; case 35667: case 35671: return Ai; case 35668: case 35672: return ui; case 35669: case 35673: return hi; case 5125: return di; case 36294: return pi; case 36295: return fi; case 36296: return gi; case 35678: case 36198: case 36298: case 36306: case 35682: return mi; case 35680: case 36300: case 36308: case 36293: return vi } }(t.type) } function xi(e) { this.id = e, this.seq = [], this.map = {} } wi.prototype.updateCache = function (e) { const t = this.cache; e instanceof Float32Array && t.length !== e.length && (this.cache = new Float32Array(e.length)), Nn(t, e) }, xi.prototype.setValue = function (e, t, n) { const i = this.seq; for (let r = 0, s = i.length; r !== s; ++r) { const s = i[r]; s.setValue(e, t[s.id], n) } }; const Ci = /(\w+)(\])?(\[|\.)?/g; function bi(e, t) { e.seq.push(t), e.map[t.id] = t } function Mi(e, t, n) { const i = e.name, r = i.length; for (Ci.lastIndex = 0; ;) { const s = Ci.exec(i), o = Ci.lastIndex; let a = s[1]; const l = "]" === s[2], c = s[3]; if (l && (a |= 0), void 0 === c || "[" === c && o + 2 === r) { bi(n, void 0 === c ? new yi(a, e, t) : new wi(a, e, t)); break } { let e = n.map[a]; void 0 === e && (e = new xi(a), bi(n, e)), n = e } } } function Ii(e, t) { this.seq = [], this.map = {}; const n = e.getProgramParameter(t, 35718); for (let i = 0; i < n; ++i) { const n = e.getActiveUniform(t, i); Mi(n, e.getUniformLocation(t, n.name), this) } } function Ei(e, t, n) { const i = e.createShader(t); return e.shaderSource(i, n), e.compileShader(i), i } Ii.prototype.setValue = function (e, t, n, i) { const r = this.map[t]; void 0 !== r && r.setValue(e, n, i) }, Ii.prototype.setOptional = function (e, t, n) { const i = t[n]; void 0 !== i && this.setValue(e, n, i) }, Ii.upload = function (e, t, n, i) { for (let r = 0, s = t.length; r !== s; ++r) { const s = t[r], o = n[s.id]; !1 !== o.needsUpdate && s.setValue(e, o.value, i) } }, Ii.seqWithValue = function (e, t) { const n = []; for (let i = 0, r = e.length; i !== r; ++i) { const r = e[i]; r.id in t && n.push(r) } return n }; let Ti = 0; function Pi(e) { switch (e) { case 3e3: return ["Linear", "( value )"]; case 3001: return ["sRGB", "( value )"]; case 3002: return ["RGBE", "( value )"]; case 3004: return ["RGBM", "( value, 7.0 )"]; case 3005: return ["RGBM", "( value, 16.0 )"]; case 3006: return ["RGBD", "( value, 256.0 )"]; case 3007: return ["Gamma", "( value, float( GAMMA_FACTOR ) )"]; case 3003: return ["LogLuv", "( value )"]; default: return console.warn("THREE.WebGLProgram: Unsupported encoding:", e), ["Linear", "( value )"] } } function Si(e, t, n) { const i = e.getShaderParameter(t, 35713), r = e.getShaderInfoLog(t).trim(); if (i && "" === r) return ""; return "THREE.WebGLShader: gl.getShaderInfoLog() " + n + "\n" + r + function (e) { const t = e.split("\n"); for (let e = 0; e < t.length; e++)t[e] = e + 1 + ": " + t[e]; return t.join("\n") }(e.getShaderSource(t)) } function Bi(e, t) { const n = Pi(t); return "vec4 " + e + "( vec4 value ) { return " + n[0] + "ToLinear" + n[1] + "; }" } function Di(e, t) { const n = Pi(t); return "vec4 " + e + "( vec4 value ) { return LinearTo" + n[0] + n[1] + "; }" } function Ri(e, t) { let n; switch (t) { case 1: n = "Linear"; break; case 2: n = "Reinhard"; break; case 3: n = "OptimizedCineon"; break; case 4: n = "ACESFilmic"; break; case 5: n = "Custom"; break; default: console.warn("THREE.WebGLProgram: Unsupported toneMapping:", t), n = "Linear" }return "vec3 " + e + "( vec3 color ) { return " + n + "ToneMapping( color ); }" } function Li(e) { return "" !== e } function Oi(e, t) { return e.replace(/NUM_DIR_LIGHTS/g, t.numDirLights).replace(/NUM_SPOT_LIGHTS/g, t.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, t.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, t.numPointLights).replace(/NUM_HEMI_LIGHTS/g, t.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, t.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g, t.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, t.numPointLightShadows) } function Ni(e, t) { return e.replace(/NUM_CLIPPING_PLANES/g, t.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, t.numClippingPlanes - t.numClipIntersection) } const ki = /^[ \t]*#include +<([\w\d./]+)>/gm; function Hi(e) { return e.replace(ki, zi) } function zi(e, t) { const n = sn[t]; if (void 0 === n) throw new Error("Can not resolve #include <" + t + ">"); return Hi(n) } const Fi = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g, Qi = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g; function Gi(e) { return e.replace(Qi, Ui).replace(Fi, ji) } function ji(e, t, n, i) { return console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."), Ui(e, t, n, i) } function Ui(e, t, n, i) { let r = ""; for (let e = parseInt(t); e < parseInt(n); e++)r += i.replace(/\[\s*i\s*\]/g, "[ " + e + " ]").replace(/UNROLLED_LOOP_INDEX/g, e); return r } function Vi(e) { let t = "precision " + e.precision + " float;\nprecision " + e.precision + " int;"; return "highp" === e.precision ? t += "\n#define HIGH_PRECISION" : "mediump" === e.precision ? t += "\n#define MEDIUM_PRECISION" : "lowp" === e.precision && (t += "\n#define LOW_PRECISION"), t } function Yi(e, t, n, i) { const r = e.getContext(), s = n.defines; let o = n.vertexShader, a = n.fragmentShader; const l = function (e) { let t = "SHADOWMAP_TYPE_BASIC"; return 1 === e.shadowMapType ? t = "SHADOWMAP_TYPE_PCF" : 2 === e.shadowMapType ? t = "SHADOWMAP_TYPE_PCF_SOFT" : 3 === e.shadowMapType && (t = "SHADOWMAP_TYPE_VSM"), t }(n), c = function (e) { let t = "ENVMAP_TYPE_CUBE"; if (e.envMap) switch (e.envMapMode) { case 301: case 302: t = "ENVMAP_TYPE_CUBE"; break; case 306: case 307: t = "ENVMAP_TYPE_CUBE_UV" }return t }(n), A = function (e) { let t = "ENVMAP_MODE_REFLECTION"; if (e.envMap) switch (e.envMapMode) { case 302: case 307: t = "ENVMAP_MODE_REFRACTION" }return t }(n), u = function (e) { let t = "ENVMAP_BLENDING_NONE"; if (e.envMap) switch (e.combine) { case 0: t = "ENVMAP_BLENDING_MULTIPLY"; break; case 1: t = "ENVMAP_BLENDING_MIX"; break; case 2: t = "ENVMAP_BLENDING_ADD" }return t }(n), h = e.gammaFactor > 0 ? e.gammaFactor : 1, d = n.isWebGL2 ? "" : function (e) { return [e.extensionDerivatives || e.envMapCubeUV || e.bumpMap || e.tangentSpaceNormalMap || e.clearcoatNormalMap || e.flatShading || "physical" === e.shaderID ? "#extension GL_OES_standard_derivatives : enable" : "", (e.extensionFragDepth || e.logarithmicDepthBuffer) && e.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "", e.extensionDrawBuffers && e.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "", (e.extensionShaderTextureLOD || e.envMap || e.transmission > 0) && e.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(Li).join("\n") }(n), p = function (e) { const t = []; for (const n in e) { const i = e[n]; !1 !== i && t.push("#define " + n + " " + i) } return t.join("\n") }(s), f = r.createProgram(); let g, m, v = n.glslVersion ? "#version " + n.glslVersion + "\n" : ""; n.isRawShaderMaterial ? (g = [p].filter(Li).join("\n"), g.length > 0 && (g += "\n"), m = [d, p].filter(Li).join("\n"), m.length > 0 && (m += "\n")) : (g = [Vi(n), "#define SHADER_NAME " + n.shaderName, p, n.instancing ? "#define USE_INSTANCING" : "", n.instancingColor ? "#define USE_INSTANCING_COLOR" : "", n.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", "#define GAMMA_FACTOR " + h, "#define MAX_BONES " + n.maxBones, n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + A : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMap && n.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", n.normalMap && n.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.displacementMap && n.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.transmission ? "#define USE_TRANSMISSION" : "", n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n.thicknessMap ? "#define USE_THICKNESSMAP" : "", n.vertexTangents ? "#define USE_TANGENT" : "", n.vertexColors ? "#define USE_COLOR" : "", n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", n.vertexUvs ? "#define USE_UV" : "", n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.skinning ? "#define USE_SKINNING" : "", n.useVertexTexture ? "#define BONE_TEXTURE" : "", n.morphTargets ? "#define USE_MORPHTARGETS" : "", n.morphNormals && !1 === n.flatShading ? "#define USE_MORPHNORMALS" : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + l : "", n.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.logarithmicDepthBuffer && n.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "\tattribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "\tattribute vec3 instanceColor;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_TANGENT", "\tattribute vec4 tangent;", "#endif", "#if defined( USE_COLOR_ALPHA )", "\tattribute vec4 color;", "#elif defined( USE_COLOR )", "\tattribute vec3 color;", "#endif", "#ifdef USE_MORPHTARGETS", "\tattribute vec3 morphTarget0;", "\tattribute vec3 morphTarget1;", "\tattribute vec3 morphTarget2;", "\tattribute vec3 morphTarget3;", "\t#ifdef USE_MORPHNORMALS", "\t\tattribute vec3 morphNormal0;", "\t\tattribute vec3 morphNormal1;", "\t\tattribute vec3 morphNormal2;", "\t\tattribute vec3 morphNormal3;", "\t#else", "\t\tattribute vec3 morphTarget4;", "\t\tattribute vec3 morphTarget5;", "\t\tattribute vec3 morphTarget6;", "\t\tattribute vec3 morphTarget7;", "\t#endif", "#endif", "#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n"].filter(Li).join("\n"), m = [d, Vi(n), "#define SHADER_NAME " + n.shaderName, p, n.alphaTest ? "#define ALPHATEST " + n.alphaTest + (n.alphaTest % 1 ? "" : ".0") : "", "#define GAMMA_FACTOR " + h, n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.matcap ? "#define USE_MATCAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + c : "", n.envMap ? "#define " + A : "", n.envMap ? "#define " + u : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMap && n.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", n.normalMap && n.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.sheen ? "#define USE_SHEEN" : "", n.transmission ? "#define USE_TRANSMISSION" : "", n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n.thicknessMap ? "#define USE_THICKNESSMAP" : "", n.vertexTangents ? "#define USE_TANGENT" : "", n.vertexColors || n.instancingColor ? "#define USE_COLOR" : "", n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", n.vertexUvs ? "#define USE_UV" : "", n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", n.gradientMap ? "#define USE_GRADIENTMAP" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + l : "", n.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", n.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.logarithmicDepthBuffer && n.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", (n.extensionShaderTextureLOD || n.envMap) && n.rendererExtensionShaderTextureLod ? "#define TEXTURE_LOD_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", 0 !== n.toneMapping ? "#define TONE_MAPPING" : "", 0 !== n.toneMapping ? sn.tonemapping_pars_fragment : "", 0 !== n.toneMapping ? Ri("toneMapping", n.toneMapping) : "", n.dithering ? "#define DITHERING" : "", sn.encodings_pars_fragment, n.map ? Bi("mapTexelToLinear", n.mapEncoding) : "", n.matcap ? Bi("matcapTexelToLinear", n.matcapEncoding) : "", n.envMap ? Bi("envMapTexelToLinear", n.envMapEncoding) : "", n.emissiveMap ? Bi("emissiveMapTexelToLinear", n.emissiveMapEncoding) : "", n.lightMap ? Bi("lightMapTexelToLinear", n.lightMapEncoding) : "", Di("linearToOutputTexel", n.outputEncoding), n.depthPacking ? "#define DEPTH_PACKING " + n.depthPacking : "", "\n"].filter(Li).join("\n")), o = Hi(o), o = Oi(o, n), o = Ni(o, n), a = Hi(a), a = Oi(a, n), a = Ni(a, n), o = Gi(o), a = Gi(a), n.isWebGL2 && !0 !== n.isRawShaderMaterial && (v = "#version 300 es\n", g = ["#define attribute in", "#define varying out", "#define texture2D texture"].join("\n") + "\n" + g, m = ["#define varying in", "300 es" === n.glslVersion ? "" : "out highp vec4 pc_fragColor;", "300 es" === n.glslVersion ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join("\n") + "\n" + m); const y = v + m + a, w = Ei(r, 35633, v + g + o), x = Ei(r, 35632, y); if (r.attachShader(f, w), r.attachShader(f, x), void 0 !== n.index0AttributeName ? r.bindAttribLocation(f, 0, n.index0AttributeName) : !0 === n.morphTargets && r.bindAttribLocation(f, 0, "position"), r.linkProgram(f), e.debug.checkShaderErrors) { const e = r.getProgramInfoLog(f).trim(), t = r.getShaderInfoLog(w).trim(), n = r.getShaderInfoLog(x).trim(); let i = !0, s = !0; if (!1 === r.getProgramParameter(f, 35714)) { i = !1; const t = Si(r, w, "vertex"), n = Si(r, x, "fragment"); console.error("THREE.WebGLProgram: shader error: ", r.getError(), "35715", r.getProgramParameter(f, 35715), "gl.getProgramInfoLog", e, t, n) } else "" !== e ? console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", e) : "" !== t && "" !== n || (s = !1); s && (this.diagnostics = { runnable: i, programLog: e, vertexShader: { log: t, prefix: g }, fragmentShader: { log: n, prefix: m } }) } let C, b; return r.deleteShader(w), r.deleteShader(x), this.getUniforms = function () { return void 0 === C && (C = new Ii(r, f)), C }, this.getAttributes = function () { return void 0 === b && (b = function (e, t) { const n = {}, i = e.getProgramParameter(t, 35721); for (let r = 0; r < i; r++) { const i = e.getActiveAttrib(t, r).name; n[i] = e.getAttribLocation(t, i) } return n }(r, f)), b }, this.destroy = function () { i.releaseStatesOfProgram(this), r.deleteProgram(f), this.program = void 0 }, this.name = n.shaderName, this.id = Ti++, this.cacheKey = t, this.usedTimes = 1, this.program = f, this.vertexShader = w, this.fragmentShader = x, this } function Wi(e, t, n, i, r, s) { const o = [], a = i.isWebGL2, l = i.logarithmicDepthBuffer, c = i.floatVertexTextures, A = i.maxVertexUniforms, u = i.vertexTextures; let h = i.precision; const d = { MeshDepthMaterial: "depth", MeshDistanceMaterial: "distanceRGBA", MeshNormalMaterial: "normal", MeshBasicMaterial: "basic", MeshLambertMaterial: "lambert", MeshPhongMaterial: "phong", MeshToonMaterial: "toon", MeshStandardMaterial: "physical", MeshPhysicalMaterial: "physical", MeshMatcapMaterial: "matcap", LineBasicMaterial: "basic", LineDashedMaterial: "dashed", PointsMaterial: "points", ShadowMaterial: "shadow", SpriteMaterial: "sprite" }, p = ["precision", "isWebGL2", "supportsVertexTextures", "outputEncoding", "instancing", "instancingColor", "map", "mapEncoding", "matcap", "matcapEncoding", "envMap", "envMapMode", "envMapEncoding", "envMapCubeUV", "lightMap", "lightMapEncoding", "aoMap", "emissiveMap", "emissiveMapEncoding", "bumpMap", "normalMap", "objectSpaceNormalMap", "tangentSpaceNormalMap", "clearcoatMap", "clearcoatRoughnessMap", "clearcoatNormalMap", "displacementMap", "specularMap", "roughnessMap", "metalnessMap", "gradientMap", "alphaMap", "combine", "vertexColors", "vertexAlphas", "vertexTangents", "vertexUvs", "uvsVertexOnly", "fog", "useFog", "fogExp2", "flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning", "maxBones", "useVertexTexture", "morphTargets", "morphNormals", "premultipliedAlpha", "numDirLights", "numPointLights", "numSpotLights", "numHemiLights", "numRectAreaLights", "numDirLightShadows", "numPointLightShadows", "numSpotLightShadows", "shadowMapEnabled", "shadowMapType", "toneMapping", "physicallyCorrectLights", "alphaTest", "doubleSided", "flipSided", "numClippingPlanes", "numClipIntersection", "depthPacking", "dithering", "sheen", "transmission", "transmissionMap", "thicknessMap"]; function f(e) { let t; return e && e.isTexture ? t = e.encoding : e && e.isWebGLRenderTarget ? (console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."), t = e.texture.encoding) : t = 3e3, t } return { getParameters: function (r, o, p, g, m) { const v = g.fog, y = r.isMeshStandardMaterial ? g.environment : null, w = t.get(r.envMap || y), x = d[r.type], C = m.isSkinnedMesh ? function (e) { const t = e.skeleton.bones; if (c) return 1024; { const e = A, n = Math.floor((e - 20) / 4), i = Math.min(n, t.length); return i < t.length ? (console.warn("THREE.WebGLRenderer: Skeleton has " + t.length + " bones. This GPU supports " + i + "."), 0) : i } }(m) : 0; let b, M; if (null !== r.precision && (h = i.getMaxPrecision(r.precision), h !== r.precision && console.warn("THREE.WebGLProgram.getParameters:", r.precision, "not supported, using", h, "instead.")), x) { const e = an[x]; b = e.vertexShader, M = e.fragmentShader } else b = r.vertexShader, M = r.fragmentShader; const I = e.getRenderTarget(); return { isWebGL2: a, shaderID: x, shaderName: r.type, vertexShader: b, fragmentShader: M, defines: r.defines, isRawShaderMaterial: !0 === r.isRawShaderMaterial, glslVersion: r.glslVersion, precision: h, instancing: !0 === m.isInstancedMesh, instancingColor: !0 === m.isInstancedMesh && null !== m.instanceColor, supportsVertexTextures: u, outputEncoding: null !== I ? f(I.texture) : e.outputEncoding, map: !!r.map, mapEncoding: f(r.map), matcap: !!r.matcap, matcapEncoding: f(r.matcap), envMap: !!w, envMapMode: w && w.mapping, envMapEncoding: f(w), envMapCubeUV: !!w && (306 === w.mapping || 307 === w.mapping), lightMap: !!r.lightMap, lightMapEncoding: f(r.lightMap), aoMap: !!r.aoMap, emissiveMap: !!r.emissiveMap, emissiveMapEncoding: f(r.emissiveMap), bumpMap: !!r.bumpMap, normalMap: !!r.normalMap, objectSpaceNormalMap: 1 === r.normalMapType, tangentSpaceNormalMap: 0 === r.normalMapType, clearcoatMap: !!r.clearcoatMap, clearcoatRoughnessMap: !!r.clearcoatRoughnessMap, clearcoatNormalMap: !!r.clearcoatNormalMap, displacementMap: !!r.displacementMap, roughnessMap: !!r.roughnessMap, metalnessMap: !!r.metalnessMap, specularMap: !!r.specularMap, alphaMap: !!r.alphaMap, gradientMap: !!r.gradientMap, sheen: !!r.sheen, transmission: !!r.transmission, transmissionMap: !!r.transmissionMap, thicknessMap: !!r.thicknessMap, combine: r.combine, vertexTangents: r.normalMap && r.vertexTangents, vertexColors: r.vertexColors, vertexAlphas: !0 === r.vertexColors && m.geometry && m.geometry.attributes.color && 4 === m.geometry.attributes.color.itemSize, vertexUvs: !!(r.map || r.bumpMap || r.normalMap || r.specularMap || r.alphaMap || r.emissiveMap || r.roughnessMap || r.metalnessMap || r.clearcoatMap || r.clearcoatRoughnessMap || r.clearcoatNormalMap || r.displacementMap || r.transmissionMap || r.thicknessMap), uvsVertexOnly: !(r.map || r.bumpMap || r.normalMap || r.specularMap || r.alphaMap || r.emissiveMap || r.roughnessMap || r.metalnessMap || r.clearcoatNormalMap || r.transmission || r.transmissionMap || r.thicknessMap || !r.displacementMap), fog: !!v, useFog: r.fog, fogExp2: v && v.isFogExp2, flatShading: !!r.flatShading, sizeAttenuation: r.sizeAttenuation, logarithmicDepthBuffer: l, skinning: !0 === m.isSkinnedMesh && C > 0, maxBones: C, useVertexTexture: c, morphTargets: r.morphTargets, morphNormals: r.morphNormals, numDirLights: o.directional.length, numPointLights: o.point.length, numSpotLights: o.spot.length, numRectAreaLights: o.rectArea.length, numHemiLights: o.hemi.length, numDirLightShadows: o.directionalShadowMap.length, numPointLightShadows: o.pointShadowMap.length, numSpotLightShadows: o.spotShadowMap.length, numClippingPlanes: s.numPlanes, numClipIntersection: s.numIntersection, dithering: r.dithering, shadowMapEnabled: e.shadowMap.enabled && p.length > 0, shadowMapType: e.shadowMap.type, toneMapping: r.toneMapped ? e.toneMapping : 0, physicallyCorrectLights: e.physicallyCorrectLights, premultipliedAlpha: r.premultipliedAlpha, alphaTest: r.alphaTest, doubleSided: 2 === r.side, flipSided: 1 === r.side, depthPacking: void 0 !== r.depthPacking && r.depthPacking, index0AttributeName: r.index0AttributeName, extensionDerivatives: r.extensions && r.extensions.derivatives, extensionFragDepth: r.extensions && r.extensions.fragDepth, extensionDrawBuffers: r.extensions && r.extensions.drawBuffers, extensionShaderTextureLOD: r.extensions && r.extensions.shaderTextureLOD, rendererExtensionFragDepth: a || n.has("EXT_frag_depth"), rendererExtensionDrawBuffers: a || n.has("WEBGL_draw_buffers"), rendererExtensionShaderTextureLod: a || n.has("EXT_shader_texture_lod"), customProgramCacheKey: r.customProgramCacheKey() } }, getProgramCacheKey: function (t) { const n = []; if (t.shaderID ? n.push(t.shaderID) : (n.push(t.fragmentShader), n.push(t.vertexShader)), void 0 !== t.defines) for (const e in t.defines) n.push(e), n.push(t.defines[e]); if (!1 === t.isRawShaderMaterial) { for (let e = 0; e < p.length; e++)n.push(t[p[e]]); n.push(e.outputEncoding), n.push(e.gammaFactor) } return n.push(t.customProgramCacheKey), n.join() }, getUniforms: function (e) { const t = d[e.type]; let n; if (t) { const e = an[t]; n = Gt.clone(e.uniforms) } else n = e.uniforms; return n }, acquireProgram: function (t, n) { let i; for (let e = 0, t = o.length; e < t; e++) { const t = o[e]; if (t.cacheKey === n) { i = t, ++i.usedTimes; break } } return void 0 === i && (i = new Yi(e, n, t, r), o.push(i)), i }, releaseProgram: function (e) { if (0 == --e.usedTimes) { const t = o.indexOf(e); o[t] = o[o.length - 1], o.pop(), e.destroy() } }, programs: o } } function Xi() { let e = new WeakMap; return { get: function (t) { let n = e.get(t); return void 0 === n && (n = {}, e.set(t, n)), n }, remove: function (t) { e.delete(t) }, update: function (t, n, i) { e.get(t)[n] = i }, dispose: function () { e = new WeakMap } } } function Ji(e, t) { return e.groupOrder !== t.groupOrder ? e.groupOrder - t.groupOrder : e.renderOrder !== t.renderOrder ? e.renderOrder - t.renderOrder : e.program !== t.program ? e.program.id - t.program.id : e.material.id !== t.material.id ? e.material.id - t.material.id : e.z !== t.z ? e.z - t.z : e.id - t.id } function Ki(e, t) { return e.groupOrder !== t.groupOrder ? e.groupOrder - t.groupOrder : e.renderOrder !== t.renderOrder ? e.renderOrder - t.renderOrder : e.z !== t.z ? t.z - e.z : e.id - t.id } function Zi(e) { const t = []; let n = 0; const i = [], r = [], s = [], o = { id: -1 }; function a(i, r, s, a, l, c) { let A = t[n]; const u = e.get(s); return void 0 === A ? (A = { id: i.id, object: i, geometry: r, material: s, program: u.program || o, groupOrder: a, renderOrder: i.renderOrder, z: l, group: c }, t[n] = A) : (A.id = i.id, A.object = i, A.geometry = r, A.material = s, A.program = u.program || o, A.groupOrder = a, A.renderOrder = i.renderOrder, A.z = l, A.group = c), n++, A } return { opaque: i, transmissive: r, transparent: s, init: function () { n = 0, i.length = 0, r.length = 0, s.length = 0 }, push: function (e, t, n, o, l, c) { const A = a(e, t, n, o, l, c); n.transmission > 0 ? r.push(A) : !0 === n.transparent ? s.push(A) : i.push(A) }, unshift: function (e, t, n, o, l, c) { const A = a(e, t, n, o, l, c); n.transmission > 0 ? r.unshift(A) : !0 === n.transparent ? s.unshift(A) : i.unshift(A) }, finish: function () { for (let e = n, i = t.length; e < i; e++) { const n = t[e]; if (null === n.id) break; n.id = null, n.object = null, n.geometry = null, n.material = null, n.program = null, n.group = null } }, sort: function (e, t) { i.length > 1 && i.sort(e || Ji), r.length > 1 && r.sort(t || Ki), s.length > 1 && s.sort(t || Ki) } } } function qi(e) { let t = new WeakMap; return { get: function (n, i) { let r; return !1 === t.has(n) ? (r = new Zi(e), t.set(n, [r])) : i >= t.get(n).length ? (r = new Zi(e), t.get(n).push(r)) : r = t.get(n)[i], r }, dispose: function () { t = new WeakMap } } } function _i() { const e = {}; return { get: function (t) { if (void 0 !== e[t.id]) return e[t.id]; let n; switch (t.type) { case "DirectionalLight": n = { direction: new O, color: new nt }; break; case "SpotLight": n = { position: new O, direction: new O, color: new nt, distance: 0, coneCos: 0, penumbraCos: 0, decay: 0 }; break; case "PointLight": n = { position: new O, color: new nt, distance: 0, decay: 0 }; break; case "HemisphereLight": n = { direction: new O, skyColor: new nt, groundColor: new nt }; break; case "RectAreaLight": n = { color: new nt, position: new O, halfWidth: new O, halfHeight: new O } }return e[t.id] = n, n } } } let $i = 0; function er(e, t) { return (t.castShadow ? 1 : 0) - (e.castShadow ? 1 : 0) } function tr(e, t) { const n = new _i, i = function () { const e = {}; return { get: function (t) { if (void 0 !== e[t.id]) return e[t.id]; let n; switch (t.type) { case "DirectionalLight": case "SpotLight": n = { shadowBias: 0, shadowNormalBias: 0, shadowRadius: 1, shadowMapSize: new b }; break; case "PointLight": n = { shadowBias: 0, shadowNormalBias: 0, shadowRadius: 1, shadowMapSize: new b, shadowCameraNear: 1, shadowCameraFar: 1e3 } }return e[t.id] = n, n } } }(), r = { version: 0, hash: { directionalLength: -1, pointLength: -1, spotLength: -1, rectAreaLength: -1, hemiLength: -1, numDirectionalShadows: -1, numPointShadows: -1, numSpotShadows: -1 }, ambient: [0, 0, 0], probe: [], directional: [], directionalShadow: [], directionalShadowMap: [], directionalShadowMatrix: [], spot: [], spotShadow: [], spotShadowMap: [], spotShadowMatrix: [], rectArea: [], rectAreaLTC1: null, rectAreaLTC2: null, point: [], pointShadow: [], pointShadowMap: [], pointShadowMatrix: [], hemi: [] }; for (let e = 0; e < 9; e++)r.probe.push(new O); const s = new O, o = new ue, a = new ue; return { setup: function (s) { let o = 0, a = 0, l = 0; for (let e = 0; e < 9; e++)r.probe[e].set(0, 0, 0); let c = 0, A = 0, u = 0, h = 0, d = 0, p = 0, f = 0, g = 0; s.sort(er); for (let e = 0, t = s.length; e < t; e++) { const t = s[e], m = t.color, v = t.intensity, y = t.distance, w = t.shadow && t.shadow.map ? t.shadow.map.texture : null; if (t.isAmbientLight) o += m.r * v, a += m.g * v, l += m.b * v; else if (t.isLightProbe) for (let e = 0; e < 9; e++)r.probe[e].addScaledVector(t.sh.coefficients[e], v); else if (t.isDirectionalLight) { const e = n.get(t); if (e.color.copy(t.color).multiplyScalar(t.intensity), t.castShadow) { const e = t.shadow, n = i.get(t); n.shadowBias = e.bias, n.shadowNormalBias = e.normalBias, n.shadowRadius = e.radius, n.shadowMapSize = e.mapSize, r.directionalShadow[c] = n, r.directionalShadowMap[c] = w, r.directionalShadowMatrix[c] = t.shadow.matrix, p++ } r.directional[c] = e, c++ } else if (t.isSpotLight) { const e = n.get(t); if (e.position.setFromMatrixPosition(t.matrixWorld), e.color.copy(m).multiplyScalar(v), e.distance = y, e.coneCos = Math.cos(t.angle), e.penumbraCos = Math.cos(t.angle * (1 - t.penumbra)), e.decay = t.decay, t.castShadow) { const e = t.shadow, n = i.get(t); n.shadowBias = e.bias, n.shadowNormalBias = e.normalBias, n.shadowRadius = e.radius, n.shadowMapSize = e.mapSize, r.spotShadow[u] = n, r.spotShadowMap[u] = w, r.spotShadowMatrix[u] = t.shadow.matrix, g++ } r.spot[u] = e, u++ } else if (t.isRectAreaLight) { const e = n.get(t); e.color.copy(m).multiplyScalar(v), e.halfWidth.set(.5 * t.width, 0, 0), e.halfHeight.set(0, .5 * t.height, 0), r.rectArea[h] = e, h++ } else if (t.isPointLight) { const e = n.get(t); if (e.color.copy(t.color).multiplyScalar(t.intensity), e.distance = t.distance, e.decay = t.decay, t.castShadow) { const e = t.shadow, n = i.get(t); n.shadowBias = e.bias, n.shadowNormalBias = e.normalBias, n.shadowRadius = e.radius, n.shadowMapSize = e.mapSize, n.shadowCameraNear = e.camera.near, n.shadowCameraFar = e.camera.far, r.pointShadow[A] = n, r.pointShadowMap[A] = w, r.pointShadowMatrix[A] = t.shadow.matrix, f++ } r.point[A] = e, A++ } else if (t.isHemisphereLight) { const e = n.get(t); e.skyColor.copy(t.color).multiplyScalar(v), e.groundColor.copy(t.groundColor).multiplyScalar(v), r.hemi[d] = e, d++ } } h > 0 && (t.isWebGL2 || !0 === e.has("OES_texture_float_linear") ? (r.rectAreaLTC1 = on.LTC_FLOAT_1, r.rectAreaLTC2 = on.LTC_FLOAT_2) : !0 === e.has("OES_texture_half_float_linear") ? (r.rectAreaLTC1 = on.LTC_HALF_1, r.rectAreaLTC2 = on.LTC_HALF_2) : console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")), r.ambient[0] = o, r.ambient[1] = a, r.ambient[2] = l; const m = r.hash; m.directionalLength === c && m.pointLength === A && m.spotLength === u && m.rectAreaLength === h && m.hemiLength === d && m.numDirectionalShadows === p && m.numPointShadows === f && m.numSpotShadows === g || (r.directional.length = c, r.spot.length = u, r.rectArea.length = h, r.point.length = A, r.hemi.length = d, r.directionalShadow.length = p, r.directionalShadowMap.length = p, r.pointShadow.length = f, r.pointShadowMap.length = f, r.spotShadow.length = g, r.spotShadowMap.length = g, r.directionalShadowMatrix.length = p, r.pointShadowMatrix.length = f, r.spotShadowMatrix.length = g, m.directionalLength = c, m.pointLength = A, m.spotLength = u, m.rectAreaLength = h, m.hemiLength = d, m.numDirectionalShadows = p, m.numPointShadows = f, m.numSpotShadows = g, r.version = $i++) }, setupView: function (e, t) { let n = 0, i = 0, l = 0, c = 0, A = 0; const u = t.matrixWorldInverse; for (let t = 0, h = e.length; t < h; t++) { const h = e[t]; if (h.isDirectionalLight) { const e = r.directional[n]; e.direction.setFromMatrixPosition(h.matrixWorld), s.setFromMatrixPosition(h.target.matrixWorld), e.direction.sub(s), e.direction.transformDirection(u), n++ } else if (h.isSpotLight) { const e = r.spot[l]; e.position.setFromMatrixPosition(h.matrixWorld), e.position.applyMatrix4(u), e.direction.setFromMatrixPosition(h.matrixWorld), s.setFromMatrixPosition(h.target.matrixWorld), e.direction.sub(s), e.direction.transformDirection(u), l++ } else if (h.isRectAreaLight) { const e = r.rectArea[c]; e.position.setFromMatrixPosition(h.matrixWorld), e.position.applyMatrix4(u), a.identity(), o.copy(h.matrixWorld), o.premultiply(u), a.extractRotation(o), e.halfWidth.set(.5 * h.width, 0, 0), e.halfHeight.set(0, .5 * h.height, 0), e.halfWidth.applyMatrix4(a), e.halfHeight.applyMatrix4(a), c++ } else if (h.isPointLight) { const e = r.point[i]; e.position.setFromMatrixPosition(h.matrixWorld), e.position.applyMatrix4(u), i++ } else if (h.isHemisphereLight) { const e = r.hemi[A]; e.direction.setFromMatrixPosition(h.matrixWorld), e.direction.transformDirection(u), e.direction.normalize(), A++ } } }, state: r } } function nr(e, t) { const n = new tr(e, t), i = [], r = []; return { init: function () { i.length = 0, r.length = 0 }, state: { lightsArray: i, shadowsArray: r, lights: n }, setupLights: function () { n.setup(i) }, setupLightsView: function (e) { n.setupView(i, e) }, pushLight: function (e) { i.push(e) }, pushShadow: function (e) { r.push(e) } } } function ir(e, t) { let n = new WeakMap; return { get: function (i, r = 0) { let s; return !1 === n.has(i) ? (s = new nr(e, t), n.set(i, [s])) : r >= n.get(i).length ? (s = new nr(e, t), n.get(i).push(s)) : s = n.get(i)[r], s }, dispose: function () { n = new WeakMap } } } class rr extends Ke { constructor(e) { super(), this.type = "MeshDepthMaterial", this.depthPacking = 3200, this.morphTargets = !1, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.setValues(e) } copy(e) { return super.copy(e), this.depthPacking = e.depthPacking, this.morphTargets = e.morphTargets, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this } } rr.prototype.isMeshDepthMaterial = !0; class sr extends Ke { constructor(e) { super(), this.type = "MeshDistanceMaterial", this.referencePosition = new O, this.nearDistance = 1, this.farDistance = 1e3, this.morphTargets = !1, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.fog = !1, this.setValues(e) } copy(e) { return super.copy(e), this.referencePosition.copy(e.referencePosition), this.nearDistance = e.nearDistance, this.farDistance = e.farDistance, this.morphTargets = e.morphTargets, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this } } sr.prototype.isMeshDistanceMaterial = !0; function or(e, t, n) { let i = new en; const r = new b, s = new b, o = new B, a = [], l = [], c = {}, A = n.maxTextureSize, u = { 0: 1, 1: 0, 2: 2 }, h = new jt({ defines: { SAMPLE_RATE: 2 / 8, HALF_SAMPLE_RATE: 1 / 8 }, uniforms: { shadow_pass: { value: null }, resolution: { value: new b }, radius: { value: 4 } }, vertexShader: "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}", fragmentShader: "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy ) / resolution ) );\n\tfor ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, i ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean * HALF_SAMPLE_RATE;\n\tsquared_mean = squared_mean * HALF_SAMPLE_RATE;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}" }), d = h.clone(); d.defines.HORIZONTAL_PASS = 1; const p = new vt; p.setAttribute("position", new ot(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]), 3)); const f = new kt(p, h), g = this; function m(n, i) { const r = t.update(f); h.uniforms.shadow_pass.value = n.map.texture, h.uniforms.resolution.value = n.mapSize, h.uniforms.radius.value = n.radius, e.setRenderTarget(n.mapPass), e.clear(), e.renderBufferDirect(i, null, r, h, f, null), d.uniforms.shadow_pass.value = n.mapPass.texture, d.uniforms.resolution.value = n.mapSize, d.uniforms.radius.value = n.radius, e.setRenderTarget(n.map), e.clear(), e.renderBufferDirect(i, null, r, d, f, null) } function v(e) { const t = e << 0; let n = a[t]; return void 0 === n && (n = new rr({ depthPacking: 3201, morphTargets: e }), a[t] = n), n } function y(e) { const t = e << 0; let n = l[t]; return void 0 === n && (n = new sr({ morphTargets: e }), l[t] = n), n } function w(t, n, i, r, s, o, a) { let l = null, A = v, h = t.customDepthMaterial; if (!0 === r.isPointLight && (A = y, h = t.customDistanceMaterial), void 0 === h) { let e = !1; !0 === i.morphTargets && (e = n.morphAttributes && n.morphAttributes.position && n.morphAttributes.position.length > 0), l = A(e) } else l = h; if (e.localClippingEnabled && !0 === i.clipShadows && 0 !== i.clippingPlanes.length) { const e = l.uuid, t = i.uuid; let n = c[e]; void 0 === n && (n = {}, c[e] = n); let r = n[t]; void 0 === r && (r = l.clone(), n[t] = r), l = r } return l.visible = i.visible, l.wireframe = i.wireframe, l.side = 3 === a ? null !== i.shadowSide ? i.shadowSide : i.side : null !== i.shadowSide ? i.shadowSide : u[i.side], l.clipShadows = i.clipShadows, l.clippingPlanes = i.clippingPlanes, l.clipIntersection = i.clipIntersection, l.wireframeLinewidth = i.wireframeLinewidth, l.linewidth = i.linewidth, !0 === r.isPointLight && !0 === l.isMeshDistanceMaterial && (l.referencePosition.setFromMatrixPosition(r.matrixWorld), l.nearDistance = s, l.farDistance = o), l } function x(n, r, s, o, a) { if (!1 === n.visible) return; if (n.layers.test(r.layers) && (n.isMesh || n.isLine || n.isPoints) && (n.castShadow || n.receiveShadow && 3 === a) && (!n.frustumCulled || i.intersectsObject(n))) { n.modelViewMatrix.multiplyMatrices(s.matrixWorldInverse, n.matrixWorld); const i = t.update(n), r = n.material; if (Array.isArray(r)) { const t = i.groups; for (let l = 0, c = t.length; l < c; l++) { const c = t[l], A = r[c.materialIndex]; if (A && A.visible) { const t = w(n, i, A, o, s.near, s.far, a); e.renderBufferDirect(s, null, i, t, n, c) } } } else if (r.visible) { const t = w(n, i, r, o, s.near, s.far, a); e.renderBufferDirect(s, null, i, t, n, null) } } const l = n.children; for (let e = 0, t = l.length; e < t; e++)x(l[e], r, s, o, a) } this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = 1, this.render = function (t, n, a) { if (!1 === g.enabled) return; if (!1 === g.autoUpdate && !1 === g.needsUpdate) return; if (0 === t.length) return; const l = e.getRenderTarget(), c = e.getActiveCubeFace(), u = e.getActiveMipmapLevel(), h = e.state; h.setBlending(0), h.buffers.color.setClear(1, 1, 1, 1), h.buffers.depth.setTest(!0), h.setScissorTest(!1); for (let l = 0, c = t.length; l < c; l++) { const c = t[l], u = c.shadow; if (void 0 === u) { console.warn("THREE.WebGLShadowMap:", c, "has no shadow."); continue } if (!1 === u.autoUpdate && !1 === u.needsUpdate) continue; r.copy(u.mapSize); const d = u.getFrameExtents(); if (r.multiply(d), s.copy(u.mapSize), (r.x > A || r.y > A) && (r.x > A && (s.x = Math.floor(A / d.x), r.x = s.x * d.x, u.mapSize.x = s.x), r.y > A && (s.y = Math.floor(A / d.y), r.y = s.y * d.y, u.mapSize.y = s.y)), null === u.map && !u.isPointLightShadow && 3 === this.type) { const e = { minFilter: 1006, magFilter: 1006, format: 1023 }; u.map = new D(r.x, r.y, e), u.map.texture.name = c.name + ".shadowMap", u.mapPass = new D(r.x, r.y, e), u.camera.updateProjectionMatrix() } if (null === u.map) { const e = { minFilter: 1003, magFilter: 1003, format: 1023 }; u.map = new D(r.x, r.y, e), u.map.texture.name = c.name + ".shadowMap", u.camera.updateProjectionMatrix() } e.setRenderTarget(u.map), e.clear(); const p = u.getViewportCount(); for (let e = 0; e < p; e++) { const t = u.getViewport(e); o.set(s.x * t.x, s.y * t.y, s.x * t.z, s.y * t.w), h.viewport(o), u.updateMatrices(c, e), i = u.getFrustum(), x(n, a, u.camera, c, this.type) } u.isPointLightShadow || 3 !== this.type || m(u, a), u.needsUpdate = !1 } g.needsUpdate = !1, e.setRenderTarget(l, c, u) } } function ar(e, t, n) { const i = n.isWebGL2; const r = new function () { let t = !1; const n = new B; let i = null; const r = new B(0, 0, 0, 0); return { setMask: function (n) { i === n || t || (e.colorMask(n, n, n, n), i = n) }, setLocked: function (e) { t = e }, setClear: function (t, i, s, o, a) { !0 === a && (t *= o, i *= o, s *= o), n.set(t, i, s, o), !1 === r.equals(n) && (e.clearColor(t, i, s, o), r.copy(n)) }, reset: function () { t = !1, i = null, r.set(-1, 0, 0, 0) } } }, s = new function () { let t = !1, n = null, i = null, r = null; return { setTest: function (e) { e ? z(2929) : F(2929) }, setMask: function (i) { n === i || t || (e.depthMask(i), n = i) }, setFunc: function (t) { if (i !== t) { if (t) switch (t) { case 0: e.depthFunc(512); break; case 1: e.depthFunc(519); break; case 2: e.depthFunc(513); break; case 3: e.depthFunc(515); break; case 4: e.depthFunc(514); break; case 5: e.depthFunc(518); break; case 6: e.depthFunc(516); break; case 7: e.depthFunc(517); break; default: e.depthFunc(515) } else e.depthFunc(515); i = t } }, setLocked: function (e) { t = e }, setClear: function (t) { r !== t && (e.clearDepth(t), r = t) }, reset: function () { t = !1, n = null, i = null, r = null } } }, o = new function () { let t = !1, n = null, i = null, r = null, s = null, o = null, a = null, l = null, c = null; return { setTest: function (e) { t || (e ? z(2960) : F(2960)) }, setMask: function (i) { n === i || t || (e.stencilMask(i), n = i) }, setFunc: function (t, n, o) { i === t && r === n && s === o || (e.stencilFunc(t, n, o), i = t, r = n, s = o) }, setOp: function (t, n, i) { o === t && a === n && l === i || (e.stencilOp(t, n, i), o = t, a = n, l = i) }, setLocked: function (e) { t = e }, setClear: function (t) { c !== t && (e.clearStencil(t), c = t) }, reset: function () { t = !1, n = null, i = null, r = null, s = null, o = null, a = null, l = null, c = null } } }; let a = {}, l = null, c = {}, A = null, u = !1, h = null, d = null, p = null, f = null, g = null, m = null, v = null, y = !1, w = null, x = null, C = null, b = null, M = null; const I = e.getParameter(35661); let E = !1, T = 0; const P = e.getParameter(7938); -1 !== P.indexOf("WebGL") ? (T = parseFloat(/^WebGL (\d)/.exec(P)[1]), E = T >= 1) : -1 !== P.indexOf("OpenGL ES") && (T = parseFloat(/^OpenGL ES (\d)/.exec(P)[1]), E = T >= 2); let S = null, D = {}; const R = e.getParameter(3088), L = e.getParameter(2978), O = (new B).fromArray(R), N = (new B).fromArray(L); function k(t, n, i) { const r = new Uint8Array(4), s = e.createTexture(); e.bindTexture(t, s), e.texParameteri(t, 10241, 9728), e.texParameteri(t, 10240, 9728); for (let t = 0; t < i; t++)e.texImage2D(n + t, 0, 6408, 1, 1, 0, 6408, 5121, r); return s } const H = {}; function z(t) { !0 !== a[t] && (e.enable(t), a[t] = !0) } function F(t) { !1 !== a[t] && (e.disable(t), a[t] = !1) } H[3553] = k(3553, 3553, 1), H[34067] = k(34067, 34069, 6), r.setClear(0, 0, 0, 1), s.setClear(1), o.setClear(0), z(2929), s.setFunc(3), U(!1), V(1), z(2884), j(0); const Q = { 100: 32774, 101: 32778, 102: 32779 }; if (i) Q[103] = 32775, Q[104] = 32776; else { const e = t.get("EXT_blend_minmax"); null !== e && (Q[103] = e.MIN_EXT, Q[104] = e.MAX_EXT) } const G = { 200: 0, 201: 1, 202: 768, 204: 770, 210: 776, 208: 774, 206: 772, 203: 769, 205: 771, 209: 775, 207: 773 }; function j(t, n, i, r, s, o, a, l) { if (0 !== t) { if (!1 === u && (z(3042), u = !0), 5 === t) s = s || n, o = o || i, a = a || r, n === d && s === g || (e.blendEquationSeparate(Q[n], Q[s]), d = n, g = s), i === p && r === f && o === m && a === v || (e.blendFuncSeparate(G[i], G[r], G[o], G[a]), p = i, f = r, m = o, v = a), h = t, y = null; else if (t !== h || l !== y) { if (100 === d && 100 === g || (e.blendEquation(32774), d = 100, g = 100), l) switch (t) { case 1: e.blendFuncSeparate(1, 771, 1, 771); break; case 2: e.blendFunc(1, 1); break; case 3: e.blendFuncSeparate(0, 0, 769, 771); break; case 4: e.blendFuncSeparate(0, 768, 0, 770); break; default: console.error("THREE.WebGLState: Invalid blending: ", t) } else switch (t) { case 1: e.blendFuncSeparate(770, 771, 1, 771); break; case 2: e.blendFunc(770, 1); break; case 3: e.blendFunc(0, 769); break; case 4: e.blendFunc(0, 768); break; default: console.error("THREE.WebGLState: Invalid blending: ", t) }p = null, f = null, m = null, v = null, h = t, y = l } } else !0 === u && (F(3042), u = !1) } function U(t) { w !== t && (t ? e.frontFace(2304) : e.frontFace(2305), w = t) } function V(t) { 0 !== t ? (z(2884), t !== x && (1 === t ? e.cullFace(1029) : 2 === t ? e.cullFace(1028) : e.cullFace(1032))) : F(2884), x = t } function Y(t, n, i) { t ? (z(32823), b === n && M === i || (e.polygonOffset(n, i), b = n, M = i)) : F(32823) } function W(t) { void 0 === t && (t = 33984 + I - 1), S !== t && (e.activeTexture(t), S = t) } return { buffers: { color: r, depth: s, stencil: o }, enable: z, disable: F, bindFramebuffer: function (t, n) { return null === n && null !== l && (n = l), c[t] !== n && (e.bindFramebuffer(t, n), c[t] = n, i && (36009 === t && (c[36160] = n), 36160 === t && (c[36009] = n)), !0) }, bindXRFramebuffer: function (t) { t !== l && (e.bindFramebuffer(36160, t), l = t) }, useProgram: function (t) { return A !== t && (e.useProgram(t), A = t, !0) }, setBlending: j, setMaterial: function (e, t) { 2 === e.side ? F(2884) : z(2884); let n = 1 === e.side; t && (n = !n), U(n), 1 === e.blending && !1 === e.transparent ? j(0) : j(e.blending, e.blendEquation, e.blendSrc, e.blendDst, e.blendEquationAlpha, e.blendSrcAlpha, e.blendDstAlpha, e.premultipliedAlpha), s.setFunc(e.depthFunc), s.setTest(e.depthTest), s.setMask(e.depthWrite), r.setMask(e.colorWrite); const i = e.stencilWrite; o.setTest(i), i && (o.setMask(e.stencilWriteMask), o.setFunc(e.stencilFunc, e.stencilRef, e.stencilFuncMask), o.setOp(e.stencilFail, e.stencilZFail, e.stencilZPass)), Y(e.polygonOffset, e.polygonOffsetFactor, e.polygonOffsetUnits), !0 === e.alphaToCoverage ? z(32926) : F(32926) }, setFlipSided: U, setCullFace: V, setLineWidth: function (t) { t !== C && (E && e.lineWidth(t), C = t) }, setPolygonOffset: Y, setScissorTest: function (e) { e ? z(3089) : F(3089) }, activeTexture: W, bindTexture: function (t, n) { null === S && W(); let i = D[S]; void 0 === i && (i = { type: void 0, texture: void 0 }, D[S] = i), i.type === t && i.texture === n || (e.bindTexture(t, n || H[t]), i.type = t, i.texture = n) }, unbindTexture: function () { const t = D[S]; void 0 !== t && void 0 !== t.type && (e.bindTexture(t.type, null), t.type = void 0, t.texture = void 0) }, compressedTexImage2D: function () { try { e.compressedTexImage2D.apply(e, arguments) } catch (e) { console.error("THREE.WebGLState:", e) } }, texImage2D: function () { try { e.texImage2D.apply(e, arguments) } catch (e) { console.error("THREE.WebGLState:", e) } }, texImage3D: function () { try { e.texImage3D.apply(e, arguments) } catch (e) { console.error("THREE.WebGLState:", e) } }, scissor: function (t) { !1 === O.equals(t) && (e.scissor(t.x, t.y, t.z, t.w), O.copy(t)) }, viewport: function (t) { !1 === N.equals(t) && (e.viewport(t.x, t.y, t.z, t.w), N.copy(t)) }, reset: function () { e.disable(3042), e.disable(2884), e.disable(2929), e.disable(32823), e.disable(3089), e.disable(2960), e.disable(32926), e.blendEquation(32774), e.blendFunc(1, 0), e.blendFuncSeparate(1, 0, 1, 0), e.colorMask(!0, !0, !0, !0), e.clearColor(0, 0, 0, 0), e.depthMask(!0), e.depthFunc(513), e.clearDepth(1), e.stencilMask(4294967295), e.stencilFunc(519, 0, 4294967295), e.stencilOp(7680, 7680, 7680), e.clearStencil(0), e.cullFace(1029), e.frontFace(2305), e.polygonOffset(0, 0), e.activeTexture(33984), e.bindFramebuffer(36160, null), !0 === i && (e.bindFramebuffer(36009, null), e.bindFramebuffer(36008, null)), e.useProgram(null), e.lineWidth(1), e.scissor(0, 0, e.canvas.width, e.canvas.height), e.viewport(0, 0, e.canvas.width, e.canvas.height), a = {}, S = null, D = {}, l = null, c = {}, A = null, u = !1, h = null, d = null, p = null, f = null, g = null, m = null, v = null, y = !1, w = null, x = null, C = null, b = null, M = null, O.set(0, 0, e.canvas.width, e.canvas.height), N.set(0, 0, e.canvas.width, e.canvas.height), r.reset(), s.reset(), o.reset() } } } function lr(e, t, n, i, r, s, o) { const a = r.isWebGL2, l = r.maxTextures, c = r.maxCubemapSize, A = r.maxTextureSize, u = r.maxSamples, h = new WeakMap; let d, p = !1; try { p = "undefined" != typeof OffscreenCanvas && null !== new OffscreenCanvas(1, 1).getContext("2d") } catch (e) { } function f(e, t) { return p ? new OffscreenCanvas(e, t) : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas") } function g(e, t, n, i) { let r = 1; if ((e.width > i || e.height > i) && (r = i / Math.max(e.width, e.height)), r < 1 || !0 === t) { if ("undefined" != typeof HTMLImageElement && e instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && e instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && e instanceof ImageBitmap) { const i = t ? x : Math.floor, s = i(r * e.width), o = i(r * e.height); void 0 === d && (d = f(s, o)); const a = n ? f(s, o) : d; a.width = s, a.height = o; return a.getContext("2d").drawImage(e, 0, 0, s, o), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + e.width + "x" + e.height + ") to (" + s + "x" + o + ")."), a } return "data" in e && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + e.width + "x" + e.height + ")."), e } return e } function m(e) { return y(e.width) && y(e.height) } function v(e, t) { return e.generateMipmaps && t && 1003 !== e.minFilter && 1006 !== e.minFilter } function w(t, n, r, s, o = 1) { e.generateMipmap(t); i.get(n).__maxMipLevel = Math.log2(Math.max(r, s, o)) } function C(n, i, r) { if (!1 === a) return i; if (null !== n) { if (void 0 !== e[n]) return e[n]; console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + n + "'") } let s = i; return 6403 === i && (5126 === r && (s = 33326), 5131 === r && (s = 33325), 5121 === r && (s = 33321)), 6407 === i && (5126 === r && (s = 34837), 5131 === r && (s = 34843), 5121 === r && (s = 32849)), 6408 === i && (5126 === r && (s = 34836), 5131 === r && (s = 34842), 5121 === r && (s = 32856)), 33325 !== s && 33326 !== s && 34842 !== s && 34836 !== s || t.get("EXT_color_buffer_float"), s } function b(e) { return 1003 === e || 1004 === e || 1005 === e ? 9728 : 9729 } function M(t) { const n = t.target; n.removeEventListener("dispose", M), function (t) { const n = i.get(t); if (void 0 === n.__webglInit) return; e.deleteTexture(n.__webglTexture), i.remove(t) }(n), n.isVideoTexture && h.delete(n), o.memory.textures-- } function I(t) { const n = t.target; n.removeEventListener("dispose", I), function (t) { const n = t.texture, r = i.get(t), s = i.get(n); if (!t) return; void 0 !== s.__webglTexture && (e.deleteTexture(s.__webglTexture), o.memory.textures--); t.depthTexture && t.depthTexture.dispose(); if (t.isWebGLCubeRenderTarget) for (let t = 0; t < 6; t++)e.deleteFramebuffer(r.__webglFramebuffer[t]), r.__webglDepthbuffer && e.deleteRenderbuffer(r.__webglDepthbuffer[t]); else e.deleteFramebuffer(r.__webglFramebuffer), r.__webglDepthbuffer && e.deleteRenderbuffer(r.__webglDepthbuffer), r.__webglMultisampledFramebuffer && e.deleteFramebuffer(r.__webglMultisampledFramebuffer), r.__webglColorRenderbuffer && e.deleteRenderbuffer(r.__webglColorRenderbuffer), r.__webglDepthRenderbuffer && e.deleteRenderbuffer(r.__webglDepthRenderbuffer); if (t.isWebGLMultipleRenderTargets) for (let t = 0, r = n.length; t < r; t++) { const r = i.get(n[t]); r.__webglTexture && (e.deleteTexture(r.__webglTexture), o.memory.textures--), i.remove(n[t]) } i.remove(n), i.remove(t) }(n) } let E = 0; function T(e, t) { const r = i.get(e); if (e.isVideoTexture && function (e) { const t = o.render.frame; h.get(e) !== t && (h.set(e, t), e.update()) }(e), e.version > 0 && r.__version !== e.version) { const n = e.image; if (void 0 === n) console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined"); else { if (!1 !== n.complete) return void L(r, e, t); console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete") } } n.activeTexture(33984 + t), n.bindTexture(3553, r.__webglTexture) } function P(t, r) { const o = i.get(t); t.version > 0 && o.__version !== t.version ? function (t, i, r) { if (6 !== i.image.length) return; R(t, i), n.activeTexture(33984 + r), n.bindTexture(34067, t.__webglTexture), e.pixelStorei(37440, i.flipY), e.pixelStorei(37441, i.premultiplyAlpha), e.pixelStorei(3317, i.unpackAlignment), e.pixelStorei(37443, 0); const o = i && (i.isCompressedTexture || i.image[0].isCompressedTexture), l = i.image[0] && i.image[0].isDataTexture, A = []; for (let e = 0; e < 6; e++)A[e] = o || l ? l ? i.image[e].image : i.image[e] : g(i.image[e], !1, !0, c); const u = A[0], h = m(u) || a, d = s.convert(i.format), p = s.convert(i.type), f = C(i.internalFormat, d, p); let y; if (D(34067, i, h), o) { for (let e = 0; e < 6; e++) { y = A[e].mipmaps; for (let t = 0; t < y.length; t++) { const r = y[t]; 1023 !== i.format && 1022 !== i.format ? null !== d ? n.compressedTexImage2D(34069 + e, t, f, r.width, r.height, 0, r.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : n.texImage2D(34069 + e, t, f, r.width, r.height, 0, d, p, r.data) } } t.__maxMipLevel = y.length - 1 } else { y = i.mipmaps; for (let e = 0; e < 6; e++)if (l) { n.texImage2D(34069 + e, 0, f, A[e].width, A[e].height, 0, d, p, A[e].data); for (let t = 0; t < y.length; t++) { const i = y[t].image[e].image; n.texImage2D(34069 + e, t + 1, f, i.width, i.height, 0, d, p, i.data) } } else { n.texImage2D(34069 + e, 0, f, d, p, A[e]); for (let t = 0; t < y.length; t++) { const i = y[t]; n.texImage2D(34069 + e, t + 1, f, d, p, i.image[e]) } } t.__maxMipLevel = y.length } v(i, h) && w(34067, i, u.width, u.height); t.__version = i.version, i.onUpdate && i.onUpdate(i) }(o, t, r) : (n.activeTexture(33984 + r), n.bindTexture(34067, o.__webglTexture)) } const S = { 1e3: 10497, 1001: 33071, 1002: 33648 }, B = { 1003: 9728, 1004: 9984, 1005: 9986, 1006: 9729, 1007: 9985, 1008: 9987 }; function D(n, s, o) { if (o ? (e.texParameteri(n, 10242, S[s.wrapS]), e.texParameteri(n, 10243, S[s.wrapT]), 32879 !== n && 35866 !== n || e.texParameteri(n, 32882, S[s.wrapR]), e.texParameteri(n, 10240, B[s.magFilter]), e.texParameteri(n, 10241, B[s.minFilter])) : (e.texParameteri(n, 10242, 33071), e.texParameteri(n, 10243, 33071), 32879 !== n && 35866 !== n || e.texParameteri(n, 32882, 33071), 1001 === s.wrapS && 1001 === s.wrapT || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."), e.texParameteri(n, 10240, b(s.magFilter)), e.texParameteri(n, 10241, b(s.minFilter)), 1003 !== s.minFilter && 1006 !== s.minFilter && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")), !0 === t.has("EXT_texture_filter_anisotropic")) { const o = t.get("EXT_texture_filter_anisotropic"); if (1015 === s.type && !1 === t.has("OES_texture_float_linear")) return; if (!1 === a && 1016 === s.type && !1 === t.has("OES_texture_half_float_linear")) return; (s.anisotropy > 1 || i.get(s).__currentAnisotropy) && (e.texParameterf(n, o.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(s.anisotropy, r.getMaxAnisotropy())), i.get(s).__currentAnisotropy = s.anisotropy) } } function R(t, n) { void 0 === t.__webglInit && (t.__webglInit = !0, n.addEventListener("dispose", M), t.__webglTexture = e.createTexture(), o.memory.textures++) } function L(t, i, r) { let o = 3553; i.isDataTexture2DArray && (o = 35866), i.isDataTexture3D && (o = 32879), R(t, i), n.activeTexture(33984 + r), n.bindTexture(o, t.__webglTexture), e.pixelStorei(37440, i.flipY), e.pixelStorei(37441, i.premultiplyAlpha), e.pixelStorei(3317, i.unpackAlignment), e.pixelStorei(37443, 0); const l = function (e) { return !a && (1001 !== e.wrapS || 1001 !== e.wrapT || 1003 !== e.minFilter && 1006 !== e.minFilter) }(i) && !1 === m(i.image), c = g(i.image, l, !1, A), u = m(c) || a, h = s.convert(i.format); let d, p = s.convert(i.type), f = C(i.internalFormat, h, p); D(o, i, u); const y = i.mipmaps; if (i.isDepthTexture) f = 6402, a ? f = 1015 === i.type ? 36012 : 1014 === i.type ? 33190 : 1020 === i.type ? 35056 : 33189 : 1015 === i.type && console.error("WebGLRenderer: Floating point depth texture requires WebGL2."), 1026 === i.format && 6402 === f && 1012 !== i.type && 1014 !== i.type && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), i.type = 1012, p = s.convert(i.type)), 1027 === i.format && 6402 === f && (f = 34041, 1020 !== i.type && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), i.type = 1020, p = s.convert(i.type))), n.texImage2D(3553, 0, f, c.width, c.height, 0, h, p, null); else if (i.isDataTexture) if (y.length > 0 && u) { for (let e = 0, t = y.length; e < t; e++)d = y[e], n.texImage2D(3553, e, f, d.width, d.height, 0, h, p, d.data); i.generateMipmaps = !1, t.__maxMipLevel = y.length - 1 } else n.texImage2D(3553, 0, f, c.width, c.height, 0, h, p, c.data), t.__maxMipLevel = 0; else if (i.isCompressedTexture) { for (let e = 0, t = y.length; e < t; e++)d = y[e], 1023 !== i.format && 1022 !== i.format ? null !== h ? n.compressedTexImage2D(3553, e, f, d.width, d.height, 0, d.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : n.texImage2D(3553, e, f, d.width, d.height, 0, h, p, d.data); t.__maxMipLevel = y.length - 1 } else if (i.isDataTexture2DArray) n.texImage3D(35866, 0, f, c.width, c.height, c.depth, 0, h, p, c.data), t.__maxMipLevel = 0; else if (i.isDataTexture3D) n.texImage3D(32879, 0, f, c.width, c.height, c.depth, 0, h, p, c.data), t.__maxMipLevel = 0; else if (y.length > 0 && u) { for (let e = 0, t = y.length; e < t; e++)d = y[e], n.texImage2D(3553, e, f, h, p, d); i.generateMipmaps = !1, t.__maxMipLevel = y.length - 1 } else n.texImage2D(3553, 0, f, h, p, c), t.__maxMipLevel = 0; v(i, u) && w(o, i, c.width, c.height), t.__version = i.version, i.onUpdate && i.onUpdate(i) } function O(t, r, o, a, l) { const c = s.convert(o.format), A = s.convert(o.type), u = C(o.internalFormat, c, A); 32879 === l || 35866 === l ? n.texImage3D(l, 0, u, r.width, r.height, r.depth, 0, c, A, null) : n.texImage2D(l, 0, u, r.width, r.height, 0, c, A, null), n.bindFramebuffer(36160, t), e.framebufferTexture2D(36160, a, l, i.get(o).__webglTexture, 0), n.bindFramebuffer(36160, null) } function N(t, n, i) { if (e.bindRenderbuffer(36161, t), n.depthBuffer && !n.stencilBuffer) { let r = 33189; if (i) { const t = n.depthTexture; t && t.isDepthTexture && (1015 === t.type ? r = 36012 : 1014 === t.type && (r = 33190)); const i = H(n); e.renderbufferStorageMultisample(36161, i, r, n.width, n.height) } else e.renderbufferStorage(36161, r, n.width, n.height); e.framebufferRenderbuffer(36160, 36096, 36161, t) } else if (n.depthBuffer && n.stencilBuffer) { if (i) { const t = H(n); e.renderbufferStorageMultisample(36161, t, 35056, n.width, n.height) } else e.renderbufferStorage(36161, 34041, n.width, n.height); e.framebufferRenderbuffer(36160, 33306, 36161, t) } else { const t = !0 === n.isWebGLMultipleRenderTargets ? n.texture[0] : n.texture, r = s.convert(t.format), o = s.convert(t.type), a = C(t.internalFormat, r, o); if (i) { const t = H(n); e.renderbufferStorageMultisample(36161, t, a, n.width, n.height) } else e.renderbufferStorage(36161, a, n.width, n.height) } e.bindRenderbuffer(36161, null) } function k(t) { const r = i.get(t), s = !0 === t.isWebGLCubeRenderTarget; if (t.depthTexture) { if (s) throw new Error("target.depthTexture not supported in Cube render targets"); !function (t, r) { if (r && r.isWebGLCubeRenderTarget) throw new Error("Depth Texture with cube render targets is not supported"); if (n.bindFramebuffer(36160, t), !r.depthTexture || !r.depthTexture.isDepthTexture) throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture"); i.get(r.depthTexture).__webglTexture && r.depthTexture.image.width === r.width && r.depthTexture.image.height === r.height || (r.depthTexture.image.width = r.width, r.depthTexture.image.height = r.height, r.depthTexture.needsUpdate = !0), T(r.depthTexture, 0); const s = i.get(r.depthTexture).__webglTexture; if (1026 === r.depthTexture.format) e.framebufferTexture2D(36160, 36096, 3553, s, 0); else { if (1027 !== r.depthTexture.format) throw new Error("Unknown depthTexture format"); e.framebufferTexture2D(36160, 33306, 3553, s, 0) } }(r.__webglFramebuffer, t) } else if (s) { r.__webglDepthbuffer = []; for (let i = 0; i < 6; i++)n.bindFramebuffer(36160, r.__webglFramebuffer[i]), r.__webglDepthbuffer[i] = e.createRenderbuffer(), N(r.__webglDepthbuffer[i], t, !1) } else n.bindFramebuffer(36160, r.__webglFramebuffer), r.__webglDepthbuffer = e.createRenderbuffer(), N(r.__webglDepthbuffer, t, !1); n.bindFramebuffer(36160, null) } function H(e) { return a && e.isWebGLMultisampleRenderTarget ? Math.min(u, e.samples) : 0 } let z = !1, F = !1; this.allocateTextureUnit = function () { const e = E; return e >= l && console.warn("THREE.WebGLTextures: Trying to use " + e + " texture units while this GPU supports only " + l), E += 1, e }, this.resetTextureUnits = function () { E = 0 }, this.setTexture2D = T, this.setTexture2DArray = function (e, t) { const r = i.get(e); e.version > 0 && r.__version !== e.version ? L(r, e, t) : (n.activeTexture(33984 + t), n.bindTexture(35866, r.__webglTexture)) }, this.setTexture3D = function (e, t) { const r = i.get(e); e.version > 0 && r.__version !== e.version ? L(r, e, t) : (n.activeTexture(33984 + t), n.bindTexture(32879, r.__webglTexture)) }, this.setTextureCube = P, this.setupRenderTarget = function (t) { const l = t.texture, c = i.get(t), A = i.get(l); t.addEventListener("dispose", I), !0 !== t.isWebGLMultipleRenderTargets && (A.__webglTexture = e.createTexture(), A.__version = l.version, o.memory.textures++); const u = !0 === t.isWebGLCubeRenderTarget, h = !0 === t.isWebGLMultipleRenderTargets, d = !0 === t.isWebGLMultisampleRenderTarget, p = l.isDataTexture3D || l.isDataTexture2DArray, f = m(t) || a; if (!a || 1022 !== l.format || 1015 !== l.type && 1016 !== l.type || (l.format = 1023, console.warn("THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.")), u) { c.__webglFramebuffer = []; for (let t = 0; t < 6; t++)c.__webglFramebuffer[t] = e.createFramebuffer() } else if (c.__webglFramebuffer = e.createFramebuffer(), h) if (r.drawBuffers) { const n = t.texture; for (let t = 0, r = n.length; t < r; t++) { const r = i.get(n[t]); void 0 === r.__webglTexture && (r.__webglTexture = e.createTexture(), o.memory.textures++) } } else console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension."); else if (d) if (a) { c.__webglMultisampledFramebuffer = e.createFramebuffer(), c.__webglColorRenderbuffer = e.createRenderbuffer(), e.bindRenderbuffer(36161, c.__webglColorRenderbuffer); const i = s.convert(l.format), r = s.convert(l.type), o = C(l.internalFormat, i, r), a = H(t); e.renderbufferStorageMultisample(36161, a, o, t.width, t.height), n.bindFramebuffer(36160, c.__webglMultisampledFramebuffer), e.framebufferRenderbuffer(36160, 36064, 36161, c.__webglColorRenderbuffer), e.bindRenderbuffer(36161, null), t.depthBuffer && (c.__webglDepthRenderbuffer = e.createRenderbuffer(), N(c.__webglDepthRenderbuffer, t, !0)), n.bindFramebuffer(36160, null) } else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2."); if (u) { n.bindTexture(34067, A.__webglTexture), D(34067, l, f); for (let e = 0; e < 6; e++)O(c.__webglFramebuffer[e], t, l, 36064, 34069 + e); v(l, f) && w(34067, l, t.width, t.height), n.bindTexture(34067, null) } else if (h) { const e = t.texture; for (let r = 0, s = e.length; r < s; r++) { const s = e[r], o = i.get(s); n.bindTexture(3553, o.__webglTexture), D(3553, s, f), O(c.__webglFramebuffer, t, s, 36064 + r, 3553), v(s, f) && w(3553, s, t.width, t.height) } n.bindTexture(3553, null) } else { let e = 3553; if (p) if (a) { e = l.isDataTexture3D ? 32879 : 35866 } else console.warn("THREE.DataTexture3D and THREE.DataTexture2DArray only supported with WebGL2."); n.bindTexture(e, A.__webglTexture), D(e, l, f), O(c.__webglFramebuffer, t, l, 36064, e), v(l, f) && w(e, l, t.width, t.height, t.depth), n.bindTexture(e, null) } t.depthBuffer && k(t) }, this.updateRenderTargetMipmap = function (e) { const t = m(e) || a, r = !0 === e.isWebGLMultipleRenderTargets ? e.texture : [e.texture]; for (let s = 0, o = r.length; s < o; s++) { const o = r[s]; if (v(o, t)) { const t = e.isWebGLCubeRenderTarget ? 34067 : 3553, r = i.get(o).__webglTexture; n.bindTexture(t, r), w(t, o, e.width, e.height), n.bindTexture(t, null) } } }, this.updateMultisampleRenderTarget = function (t) { if (t.isWebGLMultisampleRenderTarget) if (a) { const r = t.width, s = t.height; let o = 16384; t.depthBuffer && (o |= 256), t.stencilBuffer && (o |= 1024); const a = i.get(t); n.bindFramebuffer(36008, a.__webglMultisampledFramebuffer), n.bindFramebuffer(36009, a.__webglFramebuffer), e.blitFramebuffer(0, 0, r, s, 0, 0, r, s, o, 9728), n.bindFramebuffer(36008, null), n.bindFramebuffer(36009, a.__webglMultisampledFramebuffer) } else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.") }, this.safeSetTexture2D = function (e, t) { e && e.isWebGLRenderTarget && (!1 === z && (console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."), z = !0), e = e.texture), T(e, t) }, this.safeSetTextureCube = function (e, t) { e && e.isWebGLCubeRenderTarget && (!1 === F && (console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."), F = !0), e = e.texture), P(e, t) } } function cr(e, t, n) { const i = n.isWebGL2; return { convert: function (e) { let n; if (1009 === e) return 5121; if (1017 === e) return 32819; if (1018 === e) return 32820; if (1019 === e) return 33635; if (1010 === e) return 5120; if (1011 === e) return 5122; if (1012 === e) return 5123; if (1013 === e) return 5124; if (1014 === e) return 5125; if (1015 === e) return 5126; if (1016 === e) return i ? 5131 : (n = t.get("OES_texture_half_float"), null !== n ? n.HALF_FLOAT_OES : null); if (1021 === e) return 6406; if (1022 === e) return 6407; if (1023 === e) return 6408; if (1024 === e) return 6409; if (1025 === e) return 6410; if (1026 === e) return 6402; if (1027 === e) return 34041; if (1028 === e) return 6403; if (1029 === e) return 36244; if (1030 === e) return 33319; if (1031 === e) return 33320; if (1032 === e) return 36248; if (1033 === e) return 36249; if (33776 === e || 33777 === e || 33778 === e || 33779 === e) { if (n = t.get("WEBGL_compressed_texture_s3tc"), null === n) return null; if (33776 === e) return n.COMPRESSED_RGB_S3TC_DXT1_EXT; if (33777 === e) return n.COMPRESSED_RGBA_S3TC_DXT1_EXT; if (33778 === e) return n.COMPRESSED_RGBA_S3TC_DXT3_EXT; if (33779 === e) return n.COMPRESSED_RGBA_S3TC_DXT5_EXT } if (35840 === e || 35841 === e || 35842 === e || 35843 === e) { if (n = t.get("WEBGL_compressed_texture_pvrtc"), null === n) return null; if (35840 === e) return n.COMPRESSED_RGB_PVRTC_4BPPV1_IMG; if (35841 === e) return n.COMPRESSED_RGB_PVRTC_2BPPV1_IMG; if (35842 === e) return n.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG; if (35843 === e) return n.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG } if (36196 === e) return n = t.get("WEBGL_compressed_texture_etc1"), null !== n ? n.COMPRESSED_RGB_ETC1_WEBGL : null; if ((37492 === e || 37496 === e) && (n = t.get("WEBGL_compressed_texture_etc"), null !== n)) { if (37492 === e) return n.COMPRESSED_RGB8_ETC2; if (37496 === e) return n.COMPRESSED_RGBA8_ETC2_EAC } return 37808 === e || 37809 === e || 37810 === e || 37811 === e || 37812 === e || 37813 === e || 37814 === e || 37815 === e || 37816 === e || 37817 === e || 37818 === e || 37819 === e || 37820 === e || 37821 === e || 37840 === e || 37841 === e || 37842 === e || 37843 === e || 37844 === e || 37845 === e || 37846 === e || 37847 === e || 37848 === e || 37849 === e || 37850 === e || 37851 === e || 37852 === e || 37853 === e ? (n = t.get("WEBGL_compressed_texture_astc"), null !== n ? e : null) : 36492 === e ? (n = t.get("EXT_texture_compression_bptc"), null !== n ? e : null) : 1020 === e ? i ? 34042 : (n = t.get("WEBGL_depth_texture"), null !== n ? n.UNSIGNED_INT_24_8_WEBGL : null) : void 0 } } } class Ar extends Vt { constructor(e = []) { super(), this.cameras = e } } Ar.prototype.isArrayCamera = !0; class ur extends ke { constructor() { super(), this.type = "Group" } } ur.prototype.isGroup = !0; const hr = { type: "move" }; class dr { constructor() { this._targetRay = null, this._grip = null, this._hand = null } getHandSpace() { return null === this._hand && (this._hand = new ur, this._hand.matrixAutoUpdate = !1, this._hand.visible = !1, this._hand.joints = {}, this._hand.inputState = { pinching: !1 }), this._hand } getTargetRaySpace() { return null === this._targetRay && (this._targetRay = new ur, this._targetRay.matrixAutoUpdate = !1, this._targetRay.visible = !1, this._targetRay.hasLinearVelocity = !1, this._targetRay.linearVelocity = new O, this._targetRay.hasAngularVelocity = !1, this._targetRay.angularVelocity = new O), this._targetRay } getGripSpace() { return null === this._grip && (this._grip = new ur, this._grip.matrixAutoUpdate = !1, this._grip.visible = !1, this._grip.hasLinearVelocity = !1, this._grip.linearVelocity = new O, this._grip.hasAngularVelocity = !1, this._grip.angularVelocity = new O), this._grip } dispatchEvent(e) { return null !== this._targetRay && this._targetRay.dispatchEvent(e), null !== this._grip && this._grip.dispatchEvent(e), null !== this._hand && this._hand.dispatchEvent(e), this } disconnect(e) { return this.dispatchEvent({ type: "disconnected", data: e }), null !== this._targetRay && (this._targetRay.visible = !1), null !== this._grip && (this._grip.visible = !1), null !== this._hand && (this._hand.visible = !1), this } update(e, t, n) { let i = null, r = null, s = null; const o = this._targetRay, a = this._grip, l = this._hand; if (e && "visible-blurred" !== t.session.visibilityState) if (null !== o && (i = t.getPose(e.targetRaySpace, n), null !== i && (o.matrix.fromArray(i.transform.matrix), o.matrix.decompose(o.position, o.rotation, o.scale), i.linearVelocity ? (o.hasLinearVelocity = !0, o.linearVelocity.copy(i.linearVelocity)) : o.hasLinearVelocity = !1, i.angularVelocity ? (o.hasAngularVelocity = !0, o.angularVelocity.copy(i.angularVelocity)) : o.hasAngularVelocity = !1, this.dispatchEvent(hr))), l && e.hand) { s = !0; for (const i of e.hand.values()) { const e = t.getJointPose(i, n); if (void 0 === l.joints[i.jointName]) { const e = new ur; e.matrixAutoUpdate = !1, e.visible = !1, l.joints[i.jointName] = e, l.add(e) } const r = l.joints[i.jointName]; null !== e && (r.matrix.fromArray(e.transform.matrix), r.matrix.decompose(r.position, r.rotation, r.scale), r.jointRadius = e.radius), r.visible = null !== e } const i = l.joints["index-finger-tip"], r = l.joints["thumb-tip"], o = i.position.distanceTo(r.position), a = .02, c = .005; l.inputState.pinching && o > a + c ? (l.inputState.pinching = !1, this.dispatchEvent({ type: "pinchend", handedness: e.handedness, target: this })) : !l.inputState.pinching && o <= a - c && (l.inputState.pinching = !0, this.dispatchEvent({ type: "pinchstart", handedness: e.handedness, target: this })) } else null !== a && e.gripSpace && (r = t.getPose(e.gripSpace, n), null !== r && (a.matrix.fromArray(r.transform.matrix), a.matrix.decompose(a.position, a.rotation, a.scale), r.linearVelocity ? (a.hasLinearVelocity = !0, a.linearVelocity.copy(r.linearVelocity)) : a.hasLinearVelocity = !1, r.angularVelocity ? (a.hasAngularVelocity = !0, a.angularVelocity.copy(r.angularVelocity)) : a.hasAngularVelocity = !1)); return null !== o && (o.visible = null !== i), null !== a && (a.visible = null !== r), null !== l && (l.visible = null !== s), this } } class pr extends A { constructor(e, t) { super(); const n = this, i = e.state; let r = null, s = 1, o = null, a = "local-floor", l = null, c = null, A = null, u = null; const h = [], d = new Map, p = new Vt; p.layers.enable(1), p.viewport = new B; const f = new Vt; f.layers.enable(2), f.viewport = new B; const g = [p, f], m = new Ar; m.layers.enable(1), m.layers.enable(2); let v = null, y = null; function w(e) { const t = d.get(e.inputSource); t && t.dispatchEvent({ type: e.type, data: e.inputSource }) } function x() { d.forEach((function (e, t) { e.disconnect(t) })), d.clear(), v = null, y = null, i.bindXRFramebuffer(null), e.setRenderTarget(e.getRenderTarget()), T.stop(), n.isPresenting = !1, n.dispatchEvent({ type: "sessionend" }) } function C(e) { const t = r.inputSources; for (let e = 0; e < h.length; e++)d.set(t[e], h[e]); for (let t = 0; t < e.removed.length; t++) { const n = e.removed[t], i = d.get(n); i && (i.dispatchEvent({ type: "disconnected", data: n }), d.delete(n)) } for (let t = 0; t < e.added.length; t++) { const n = e.added[t], i = d.get(n); i && i.dispatchEvent({ type: "connected", data: n }) } } this.cameraAutoUpdate = !0, this.enabled = !1, this.isPresenting = !1, this.getController = function (e) { let t = h[e]; return void 0 === t && (t = new dr, h[e] = t), t.getTargetRaySpace() }, this.getControllerGrip = function (e) { let t = h[e]; return void 0 === t && (t = new dr, h[e] = t), t.getGripSpace() }, this.getHand = function (e) { let t = h[e]; return void 0 === t && (t = new dr, h[e] = t), t.getHandSpace() }, this.setFramebufferScaleFactor = function (e) { s = e, !0 === n.isPresenting && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.") }, this.setReferenceSpaceType = function (e) { a = e, !0 === n.isPresenting && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.") }, this.getReferenceSpace = function () { return o }, this.getSession = function () { return r }, this.setSession = async function (e) { if (r = e, null !== r) { r.addEventListener("select", w), r.addEventListener("selectstart", w), r.addEventListener("selectend", w), r.addEventListener("squeeze", w), r.addEventListener("squeezestart", w), r.addEventListener("squeezeend", w), r.addEventListener("end", x), r.addEventListener("inputsourceschange", C); const e = t.getContextAttributes(); if (!0 !== e.xrCompatible && await t.makeXRCompatible(), void 0 === r.renderState.layers) { const n = { antialias: e.antialias, alpha: e.alpha, depth: e.depth, stencil: e.stencil, framebufferScaleFactor: s }, i = new XRWebGLLayer(r, t, n); r.updateRenderState({ baseLayer: i }) } else { let n = 0; e.depth && (n = e.stencil ? 34041 : 6402); const i = { colorFormat: e.alpha ? 6408 : 6407, depthFormat: n, scaleFactor: s }; c = new XRWebGLBinding(r, t), u = c.createProjectionLayer(i), A = t.createFramebuffer(), r.updateRenderState({ layers: [u] }) } o = await r.requestReferenceSpace(a), T.setContext(r), T.start(), n.isPresenting = !0, n.dispatchEvent({ type: "sessionstart" }) } }; const b = new O, M = new O; function I(e, t) { null === t ? e.matrixWorld.copy(e.matrix) : e.matrixWorld.multiplyMatrices(t.matrixWorld, e.matrix), e.matrixWorldInverse.copy(e.matrixWorld).invert() } this.updateCamera = function (e) { if (null === r) return; m.near = f.near = p.near = e.near, m.far = f.far = p.far = e.far, v === m.near && y === m.far || (r.updateRenderState({ depthNear: m.near, depthFar: m.far }), v = m.near, y = m.far); const t = e.parent, n = m.cameras; I(m, t); for (let e = 0; e < n.length; e++)I(n[e], t); m.matrixWorld.decompose(m.position, m.quaternion, m.scale), e.position.copy(m.position), e.quaternion.copy(m.quaternion), e.scale.copy(m.scale), e.matrix.copy(m.matrix), e.matrixWorld.copy(m.matrixWorld); const i = e.children; for (let e = 0, t = i.length; e < t; e++)i[e].updateMatrixWorld(!0); 2 === n.length ? function (e, t, n) { b.setFromMatrixPosition(t.matrixWorld), M.setFromMatrixPosition(n.matrixWorld); const i = b.distanceTo(M), r = t.projectionMatrix.elements, s = n.projectionMatrix.elements, o = r[14] / (r[10] - 1), a = r[14] / (r[10] + 1), l = (r[9] + 1) / r[5], c = (r[9] - 1) / r[5], A = (r[8] - 1) / r[0], u = (s[8] + 1) / s[0], h = o * A, d = o * u, p = i / (-A + u), f = p * -A; t.matrixWorld.decompose(e.position, e.quaternion, e.scale), e.translateX(f), e.translateZ(p), e.matrixWorld.compose(e.position, e.quaternion, e.scale), e.matrixWorldInverse.copy(e.matrixWorld).invert(); const g = o + p, m = a + p, v = h - f, y = d + (i - f), w = l * a / m * g, x = c * a / m * g; e.projectionMatrix.makePerspective(v, y, w, x, g, m) }(m, p, f) : m.projectionMatrix.copy(p.projectionMatrix) }, this.getCamera = function () { return m }; let E = null; const T = new tn; T.setAnimationLoop((function (e, n) { if (l = n.getViewerPose(o), null !== l) { const e = l.views, n = r.renderState.baseLayer; void 0 === r.renderState.layers && i.bindXRFramebuffer(n.framebuffer); let s = !1; e.length !== m.cameras.length && (m.cameras.length = 0, s = !0); for (let o = 0; o < e.length; o++) { const a = e[o]; let l = null; if (void 0 === r.renderState.layers) l = n.getViewport(a); else { const e = c.getViewSubImage(u, a); i.bindXRFramebuffer(A), t.framebufferTexture2D(36160, 36064, 3553, e.colorTexture, 0), void 0 !== e.depthStencilTexture && t.framebufferTexture2D(36160, 36096, 3553, e.depthStencilTexture, 0), l = e.viewport } const h = g[o]; h.matrix.fromArray(a.transform.matrix), h.projectionMatrix.fromArray(a.projectionMatrix), h.viewport.set(l.x, l.y, l.width, l.height), 0 === o && m.matrix.copy(h.matrix), !0 === s && m.cameras.push(h) } } const s = r.inputSources; for (let e = 0; e < h.length; e++) { const t = h[e], i = s[e]; t.update(i, n, o) } E && E(e, n) })), this.setAnimationLoop = function (e) { E = e }, this.dispose = function () { } } } function fr(e) { function t(t, n) { t.opacity.value = n.opacity, n.color && t.diffuse.value.copy(n.color), n.emissive && t.emissive.value.copy(n.emissive).multiplyScalar(n.emissiveIntensity), n.map && (t.map.value = n.map), n.alphaMap && (t.alphaMap.value = n.alphaMap), n.specularMap && (t.specularMap.value = n.specularMap); const i = e.get(n).envMap; if (i) { t.envMap.value = i, t.flipEnvMap.value = i.isCubeTexture && i._needsFlipEnvMap ? -1 : 1, t.reflectivity.value = n.reflectivity, t.refractionRatio.value = n.refractionRatio; const r = e.get(i).__maxMipLevel; void 0 !== r && (t.maxMipLevel.value = r) } let r, s; n.lightMap && (t.lightMap.value = n.lightMap, t.lightMapIntensity.value = n.lightMapIntensity), n.aoMap && (t.aoMap.value = n.aoMap, t.aoMapIntensity.value = n.aoMapIntensity), n.map ? r = n.map : n.specularMap ? r = n.specularMap : n.displacementMap ? r = n.displacementMap : n.normalMap ? r = n.normalMap : n.bumpMap ? r = n.bumpMap : n.roughnessMap ? r = n.roughnessMap : n.metalnessMap ? r = n.metalnessMap : n.alphaMap ? r = n.alphaMap : n.emissiveMap ? r = n.emissiveMap : n.clearcoatMap ? r = n.clearcoatMap : n.clearcoatNormalMap ? r = n.clearcoatNormalMap : n.clearcoatRoughnessMap && (r = n.clearcoatRoughnessMap), void 0 !== r && (r.isWebGLRenderTarget && (r = r.texture), !0 === r.matrixAutoUpdate && r.updateMatrix(), t.uvTransform.value.copy(r.matrix)), n.aoMap ? s = n.aoMap : n.lightMap && (s = n.lightMap), void 0 !== s && (s.isWebGLRenderTarget && (s = s.texture), !0 === s.matrixAutoUpdate && s.updateMatrix(), t.uv2Transform.value.copy(s.matrix)) } function n(t, n) { t.roughness.value = n.roughness, t.metalness.value = n.metalness, n.roughnessMap && (t.roughnessMap.value = n.roughnessMap), n.metalnessMap && (t.metalnessMap.value = n.metalnessMap), n.emissiveMap && (t.emissiveMap.value = n.emissiveMap), n.bumpMap && (t.bumpMap.value = n.bumpMap, t.bumpScale.value = n.bumpScale, 1 === n.side && (t.bumpScale.value *= -1)), n.normalMap && (t.normalMap.value = n.normalMap, t.normalScale.value.copy(n.normalScale), 1 === n.side && t.normalScale.value.negate()), n.displacementMap && (t.displacementMap.value = n.displacementMap, t.displacementScale.value = n.displacementScale, t.displacementBias.value = n.displacementBias); e.get(n).envMap && (t.envMapIntensity.value = n.envMapIntensity) } return { refreshFogUniforms: function (e, t) { e.fogColor.value.copy(t.color), t.isFog ? (e.fogNear.value = t.near, e.fogFar.value = t.far) : t.isFogExp2 && (e.fogDensity.value = t.density) }, refreshMaterialUniforms: function (e, i, r, s, o) { i.isMeshBasicMaterial ? t(e, i) : i.isMeshLambertMaterial ? (t(e, i), function (e, t) { t.emissiveMap && (e.emissiveMap.value = t.emissiveMap) }(e, i)) : i.isMeshToonMaterial ? (t(e, i), function (e, t) { t.gradientMap && (e.gradientMap.value = t.gradientMap); t.emissiveMap && (e.emissiveMap.value = t.emissiveMap); t.bumpMap && (e.bumpMap.value = t.bumpMap, e.bumpScale.value = t.bumpScale, 1 === t.side && (e.bumpScale.value *= -1)); t.normalMap && (e.normalMap.value = t.normalMap, e.normalScale.value.copy(t.normalScale), 1 === t.side && e.normalScale.value.negate()); t.displacementMap && (e.displacementMap.value = t.displacementMap, e.displacementScale.value = t.displacementScale, e.displacementBias.value = t.displacementBias) }(e, i)) : i.isMeshPhongMaterial ? (t(e, i), function (e, t) { e.specular.value.copy(t.specular), e.shininess.value = Math.max(t.shininess, 1e-4), t.emissiveMap && (e.emissiveMap.value = t.emissiveMap); t.bumpMap && (e.bumpMap.value = t.bumpMap, e.bumpScale.value = t.bumpScale, 1 === t.side && (e.bumpScale.value *= -1)); t.normalMap && (e.normalMap.value = t.normalMap, e.normalScale.value.copy(t.normalScale), 1 === t.side && e.normalScale.value.negate()); t.displacementMap && (e.displacementMap.value = t.displacementMap, e.displacementScale.value = t.displacementScale, e.displacementBias.value = t.displacementBias) }(e, i)) : i.isMeshStandardMaterial ? (t(e, i), i.isMeshPhysicalMaterial ? function (e, t, i) { n(e, t), e.reflectivity.value = t.reflectivity, e.clearcoat.value = t.clearcoat, e.clearcoatRoughness.value = t.clearcoatRoughness, t.sheen && e.sheen.value.copy(t.sheen); t.clearcoatMap && (e.clearcoatMap.value = t.clearcoatMap); t.clearcoatRoughnessMap && (e.clearcoatRoughnessMap.value = t.clearcoatRoughnessMap); t.clearcoatNormalMap && (e.clearcoatNormalScale.value.copy(t.clearcoatNormalScale), e.clearcoatNormalMap.value = t.clearcoatNormalMap, 1 === t.side && e.clearcoatNormalScale.value.negate()); e.transmission.value = t.transmission, t.transmissionMap && (e.transmissionMap.value = t.transmissionMap); t.transmission > 0 && (e.transmissionSamplerMap.value = i.texture, e.transmissionSamplerSize.value.set(i.width, i.height)); e.thickness.value = t.thickness, t.thicknessMap && (e.thicknessMap.value = t.thicknessMap); e.attenuationDistance.value = t.attenuationDistance, e.attenuationColor.value.copy(t.attenuationColor) }(e, i, o) : n(e, i)) : i.isMeshMatcapMaterial ? (t(e, i), function (e, t) { t.matcap && (e.matcap.value = t.matcap); t.bumpMap && (e.bumpMap.value = t.bumpMap, e.bumpScale.value = t.bumpScale, 1 === t.side && (e.bumpScale.value *= -1)); t.normalMap && (e.normalMap.value = t.normalMap, e.normalScale.value.copy(t.normalScale), 1 === t.side && e.normalScale.value.negate()); t.displacementMap && (e.displacementMap.value = t.displacementMap, e.displacementScale.value = t.displacementScale, e.displacementBias.value = t.displacementBias) }(e, i)) : i.isMeshDepthMaterial ? (t(e, i), function (e, t) { t.displacementMap && (e.displacementMap.value = t.displacementMap, e.displacementScale.value = t.displacementScale, e.displacementBias.value = t.displacementBias) }(e, i)) : i.isMeshDistanceMaterial ? (t(e, i), function (e, t) { t.displacementMap && (e.displacementMap.value = t.displacementMap, e.displacementScale.value = t.displacementScale, e.displacementBias.value = t.displacementBias); e.referencePosition.value.copy(t.referencePosition), e.nearDistance.value = t.nearDistance, e.farDistance.value = t.farDistance }(e, i)) : i.isMeshNormalMaterial ? (t(e, i), function (e, t) { t.bumpMap && (e.bumpMap.value = t.bumpMap, e.bumpScale.value = t.bumpScale, 1 === t.side && (e.bumpScale.value *= -1)); t.normalMap && (e.normalMap.value = t.normalMap, e.normalScale.value.copy(t.normalScale), 1 === t.side && e.normalScale.value.negate()); t.displacementMap && (e.displacementMap.value = t.displacementMap, e.displacementScale.value = t.displacementScale, e.displacementBias.value = t.displacementBias) }(e, i)) : i.isLineBasicMaterial ? (function (e, t) { e.diffuse.value.copy(t.color), e.opacity.value = t.opacity }(e, i), i.isLineDashedMaterial && function (e, t) { e.dashSize.value = t.dashSize, e.totalSize.value = t.dashSize + t.gapSize, e.scale.value = t.scale }(e, i)) : i.isPointsMaterial ? function (e, t, n, i) { e.diffuse.value.copy(t.color), e.opacity.value = t.opacity, e.size.value = t.size * n, e.scale.value = .5 * i, t.map && (e.map.value = t.map); t.alphaMap && (e.alphaMap.value = t.alphaMap); let r; t.map ? r = t.map : t.alphaMap && (r = t.alphaMap); void 0 !== r && (!0 === r.matrixAutoUpdate && r.updateMatrix(), e.uvTransform.value.copy(r.matrix)) }(e, i, r, s) : i.isSpriteMaterial ? function (e, t) { e.diffuse.value.copy(t.color), e.opacity.value = t.opacity, e.rotation.value = t.rotation, t.map && (e.map.value = t.map); t.alphaMap && (e.alphaMap.value = t.alphaMap); let n; t.map ? n = t.map : t.alphaMap && (n = t.alphaMap); void 0 !== n && (!0 === n.matrixAutoUpdate && n.updateMatrix(), e.uvTransform.value.copy(n.matrix)) }(e, i) : i.isShadowMaterial ? (e.color.value.copy(i.color), e.opacity.value = i.opacity) : i.isShaderMaterial && (i.uniformsNeedUpdate = !1) } } } function gr(e = {}) { const t = void 0 !== e.canvas ? e.canvas : function () { const e = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"); return e.style.display = "block", e }(), n = void 0 !== e.context ? e.context : null, i = void 0 !== e.alpha && e.alpha, r = void 0 === e.depth || e.depth, s = void 0 === e.stencil || e.stencil, o = void 0 !== e.antialias && e.antialias, a = void 0 === e.premultipliedAlpha || e.premultipliedAlpha, l = void 0 !== e.preserveDrawingBuffer && e.preserveDrawingBuffer, c = void 0 !== e.powerPreference ? e.powerPreference : "default", A = void 0 !== e.failIfMajorPerformanceCaveat && e.failIfMajorPerformanceCaveat; let u = null, h = null; const d = [], p = []; this.domElement = t, this.debug = { checkShaderErrors: !0 }, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this.gammaFactor = 2, this.outputEncoding = 3e3, this.physicallyCorrectLights = !1, this.toneMapping = 0, this.toneMappingExposure = 1; const f = this; let g = !1, m = 0, v = 0, y = null, w = -1, x = null; const C = new B, b = new B; let M = null, I = t.width, E = t.height, T = 1, P = null, S = null; const L = new B(0, 0, I, E), N = new B(0, 0, I, E); let k = !1; const H = [], z = new en; let F = !1, Q = !1, G = null; const j = new ue, U = new O, V = { background: null, fog: null, environment: null, overrideMaterial: null, isScene: !0 }; function Y() { return null === y ? T : 1 } let W, X, J, K, Z, q, _, $, ee, te, ne, ie, re, se, oe, ae, le, ce, Ae, he, de, pe, fe = n; function ge(e, n) { for (let i = 0; i < e.length; i++) { const r = e[i], s = t.getContext(r, n); if (null !== s) return s } return null } try { const e = { alpha: i, depth: r, stencil: s, antialias: o, premultipliedAlpha: a, preserveDrawingBuffer: l, powerPreference: c, failIfMajorPerformanceCaveat: A }; if (t.addEventListener("webglcontextlost", ye, !1), t.addEventListener("webglcontextrestored", we, !1), null === fe) { const t = ["webgl2", "webgl", "experimental-webgl"]; if (!0 === f.isWebGL1Renderer && t.shift(), fe = ge(t, e), null === fe) throw ge(t) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.") } void 0 === fe.getShaderPrecisionFormat && (fe.getShaderPrecisionFormat = function () { return { rangeMin: 1, rangeMax: 1, precision: 1 } }) } catch (e) { throw console.error("THREE.WebGLRenderer: " + e.message), e } function me() { W = new pn(fe), X = new un(fe, W, e), W.init(X), de = new cr(fe, W, X), J = new ar(fe, W, X), H[0] = 1029, K = new mn(fe), Z = new Xi, q = new lr(fe, W, J, Z, X, de, K), _ = new dn(f), $ = new nn(fe, X), pe = new cn(fe, W, $, X), ee = new fn(fe, $, K, pe), te = new xn(fe, ee, $, K), ce = new wn(fe), oe = new hn(Z), ne = new Wi(f, _, W, X, pe, oe), ie = new fr(Z), re = new qi(Z), se = new ir(W, X), le = new ln(f, _, J, te, a), ae = new or(f, te, X), Ae = new An(fe, W, K, X), he = new gn(fe, W, K, X), K.programs = ne.programs, f.capabilities = X, f.extensions = W, f.properties = Z, f.renderLists = re, f.shadowMap = ae, f.state = J, f.info = K } me(); const ve = new pr(f, fe); function ye(e) { e.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), g = !0 } function we() { console.log("THREE.WebGLRenderer: Context Restored."), g = !1; const e = K.autoReset, t = ae.enabled, n = ae.autoUpdate, i = ae.needsUpdate, r = ae.type; me(), K.autoReset = e, ae.enabled = t, ae.autoUpdate = n, ae.needsUpdate = i, ae.type = r } function xe(e) { const t = e.target; t.removeEventListener("dispose", xe), function (e) { (function (e) { const t = Z.get(e).programs; void 0 !== t && t.forEach((function (e) { ne.releaseProgram(e) })) })(e), Z.remove(e) }(t) } this.xr = ve, this.getContext = function () { return fe }, this.getContextAttributes = function () { return fe.getContextAttributes() }, this.forceContextLoss = function () { const e = W.get("WEBGL_lose_context"); e && e.loseContext() }, this.forceContextRestore = function () { const e = W.get("WEBGL_lose_context"); e && e.restoreContext() }, this.getPixelRatio = function () { return T }, this.setPixelRatio = function (e) { void 0 !== e && (T = e, this.setSize(I, E, !1)) }, this.getSize = function (e) { return e.set(I, E) }, this.setSize = function (e, n, i) { ve.isPresenting ? console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.") : (I = e, E = n, t.width = Math.floor(e * T), t.height = Math.floor(n * T), !1 !== i && (t.style.width = e + "px", t.style.height = n + "px"), this.setViewport(0, 0, e, n)) }, this.getDrawingBufferSize = function (e) { return e.set(I * T, E * T).floor() }, this.setDrawingBufferSize = function (e, n, i) { I = e, E = n, T = i, t.width = Math.floor(e * i), t.height = Math.floor(n * i), this.setViewport(0, 0, e, n) }, this.getCurrentViewport = function (e) { return e.copy(C) }, this.getViewport = function (e) { return e.copy(L) }, this.setViewport = function (e, t, n, i) { e.isVector4 ? L.set(e.x, e.y, e.z, e.w) : L.set(e, t, n, i), J.viewport(C.copy(L).multiplyScalar(T).floor()) }, this.getScissor = function (e) { return e.copy(N) }, this.setScissor = function (e, t, n, i) { e.isVector4 ? N.set(e.x, e.y, e.z, e.w) : N.set(e, t, n, i), J.scissor(b.copy(N).multiplyScalar(T).floor()) }, this.getScissorTest = function () { return k }, this.setScissorTest = function (e) { J.setScissorTest(k = e) }, this.setOpaqueSort = function (e) { P = e }, this.setTransparentSort = function (e) { S = e }, this.getClearColor = function (e) { return e.copy(le.getClearColor()) }, this.setClearColor = function () { le.setClearColor.apply(le, arguments) }, this.getClearAlpha = function () { return le.getClearAlpha() }, this.setClearAlpha = function () { le.setClearAlpha.apply(le, arguments) }, this.clear = function (e, t, n) { let i = 0; (void 0 === e || e) && (i |= 16384), (void 0 === t || t) && (i |= 256), (void 0 === n || n) && (i |= 1024), fe.clear(i) }, this.clearColor = function () { this.clear(!0, !1, !1) }, this.clearDepth = function () { this.clear(!1, !0, !1) }, this.clearStencil = function () { this.clear(!1, !1, !0) }, this.dispose = function () { t.removeEventListener("webglcontextlost", ye, !1), t.removeEventListener("webglcontextrestored", we, !1), re.dispose(), se.dispose(), Z.dispose(), _.dispose(), te.dispose(), pe.dispose(), ve.dispose(), ve.removeEventListener("sessionstart", be), ve.removeEventListener("sessionend", Me), G && (G.dispose(), G = null), Ie.stop() }, this.renderBufferImmediate = function (e, t) { pe.initAttributes(); const n = Z.get(e); e.hasPositions && !n.position && (n.position = fe.createBuffer()), e.hasNormals && !n.normal && (n.normal = fe.createBuffer()), e.hasUvs && !n.uv && (n.uv = fe.createBuffer()), e.hasColors && !n.color && (n.color = fe.createBuffer()); const i = t.getAttributes(); e.hasPositions && (fe.bindBuffer(34962, n.position), fe.bufferData(34962, e.positionArray, 35048), pe.enableAttribute(i.position), fe.vertexAttribPointer(i.position, 3, 5126, !1, 0, 0)), e.hasNormals && (fe.bindBuffer(34962, n.normal), fe.bufferData(34962, e.normalArray, 35048), pe.enableAttribute(i.normal), fe.vertexAttribPointer(i.normal, 3, 5126, !1, 0, 0)), e.hasUvs && (fe.bindBuffer(34962, n.uv), fe.bufferData(34962, e.uvArray, 35048), pe.enableAttribute(i.uv), fe.vertexAttribPointer(i.uv, 2, 5126, !1, 0, 0)), e.hasColors && (fe.bindBuffer(34962, n.color), fe.bufferData(34962, e.colorArray, 35048), pe.enableAttribute(i.color), fe.vertexAttribPointer(i.color, 3, 5126, !1, 0, 0)), pe.disableUnusedAttributes(), fe.drawArrays(4, 0, e.count), e.count = 0 }, this.renderBufferDirect = function (e, t, n, i, r, s) { null === t && (t = V); const o = r.isMesh && r.matrixWorld.determinant() < 0, a = Be(e, t, i, r); J.setMaterial(i, o); let l = n.index; const c = n.attributes.position; if (null === l) { if (void 0 === c || 0 === c.count) return } else if (0 === l.count) return; let A, u = 1; !0 === i.wireframe && (l = ee.getWireframeAttribute(n), u = 2), (i.morphTargets || i.morphNormals) && ce.update(r, n, i, a), pe.setup(r, i, a, n, l); let h = Ae; null !== l && (A = $.get(l), h = he, h.setIndex(A)); const d = null !== l ? l.count : c.count, p = n.drawRange.start * u, f = n.drawRange.count * u, g = null !== s ? s.start * u : 0, m = null !== s ? s.count * u : 1 / 0, v = Math.max(p, g), y = Math.min(d, p + f, g + m) - 1, w = Math.max(0, y - v + 1); if (0 !== w) { if (r.isMesh) !0 === i.wireframe ? (J.setLineWidth(i.wireframeLinewidth * Y()), h.setMode(1)) : h.setMode(4); else if (r.isLine) { let e = i.linewidth; void 0 === e && (e = 1), J.setLineWidth(e * Y()), r.isLineSegments ? h.setMode(1) : r.isLineLoop ? h.setMode(2) : h.setMode(3) } else r.isPoints ? h.setMode(0) : r.isSprite && h.setMode(4); if (r.isInstancedMesh) h.renderInstances(v, w, r.count); else if (n.isInstancedBufferGeometry) { const e = Math.min(n.instanceCount, n._maxInstanceCount); h.renderInstances(v, w, e) } else h.render(v, w) } }, this.compile = function (e, t) { h = se.get(e), h.init(), e.traverseVisible((function (e) { e.isLight && e.layers.test(t.layers) && (h.pushLight(e), e.castShadow && h.pushShadow(e)) })), h.setupLights(), e.traverse((function (t) { const n = t.material; if (n) if (Array.isArray(n)) for (let i = 0; i < n.length; i++) { Pe(n[i], e, t) } else Pe(n, e, t) })) }; let Ce = null; function be() { Ie.stop() } function Me() { Ie.start() } const Ie = new tn; function Ee(e, t, n) { const i = !0 === t.isScene ? t.overrideMaterial : null; for (let r = 0, s = e.length; r < s; r++) { const s = e[r], o = s.object, a = s.geometry, l = null === i ? s.material : i, c = s.group; if (n.isArrayCamera) { const e = n.cameras; for (let n = 0, i = e.length; n < i; n++) { const i = e[n]; o.layers.test(i.layers) && (J.viewport(C.copy(i.viewport)), h.setupLightsView(i), Te(o, t, i, a, l, c)) } } else Te(o, t, n, a, l, c) } } function Te(e, t, n, i, r, s) { if (e.onBeforeRender(f, t, n, i, r, s), e.modelViewMatrix.multiplyMatrices(n.matrixWorldInverse, e.matrixWorld), e.normalMatrix.getNormalMatrix(e.modelViewMatrix), e.isImmediateRenderObject) { const i = Be(n, t, r, e); J.setMaterial(r), pe.reset(), function (e, t) { e.render((function (e) { f.renderBufferImmediate(e, t) })) }(e, i) } else !0 === r.transparent && 2 === r.side ? (r.side = 1, r.needsUpdate = !0, f.renderBufferDirect(n, t, i, r, e, s), r.side = 0, r.needsUpdate = !0, f.renderBufferDirect(n, t, i, r, e, s), r.side = 2) : f.renderBufferDirect(n, t, i, r, e, s); e.onAfterRender(f, t, n, i, r, s) } function Pe(e, t, n) { !0 !== t.isScene && (t = V); const i = Z.get(e), r = h.state.lights, s = h.state.shadowsArray, o = r.state.version, a = ne.getParameters(e, r.state, s, t, n), l = ne.getProgramCacheKey(a); let c = i.programs; i.environment = e.isMeshStandardMaterial ? t.environment : null, i.fog = t.fog, i.envMap = _.get(e.envMap || i.environment), void 0 === c && (e.addEventListener("dispose", xe), c = new Map, i.programs = c); let A = c.get(l); if (void 0 !== A) { if (i.currentProgram === A && i.lightsStateVersion === o) return Se(e, a), A } else a.uniforms = ne.getUniforms(e), e.onBuild(a, f), e.onBeforeCompile(a, f), A = ne.acquireProgram(a, l), c.set(l, A), i.uniforms = a.uniforms; const u = i.uniforms; (e.isShaderMaterial || e.isRawShaderMaterial) && !0 !== e.clipping || (u.clippingPlanes = oe.uniform), Se(e, a), i.needsLights = function (e) { return e.isMeshLambertMaterial || e.isMeshToonMaterial || e.isMeshPhongMaterial || e.isMeshStandardMaterial || e.isShadowMaterial || e.isShaderMaterial && !0 === e.lights }(e), i.lightsStateVersion = o, i.needsLights && (u.ambientLightColor.value = r.state.ambient, u.lightProbe.value = r.state.probe, u.directionalLights.value = r.state.directional, u.directionalLightShadows.value = r.state.directionalShadow, u.spotLights.value = r.state.spot, u.spotLightShadows.value = r.state.spotShadow, u.rectAreaLights.value = r.state.rectArea, u.ltc_1.value = r.state.rectAreaLTC1, u.ltc_2.value = r.state.rectAreaLTC2, u.pointLights.value = r.state.point, u.pointLightShadows.value = r.state.pointShadow, u.hemisphereLights.value = r.state.hemi, u.directionalShadowMap.value = r.state.directionalShadowMap, u.directionalShadowMatrix.value = r.state.directionalShadowMatrix, u.spotShadowMap.value = r.state.spotShadowMap, u.spotShadowMatrix.value = r.state.spotShadowMatrix, u.pointShadowMap.value = r.state.pointShadowMap, u.pointShadowMatrix.value = r.state.pointShadowMatrix); const d = A.getUniforms(), p = Ii.seqWithValue(d.seq, u); return i.currentProgram = A, i.uniformsList = p, A } function Se(e, t) { const n = Z.get(e); n.outputEncoding = t.outputEncoding, n.instancing = t.instancing, n.skinning = t.skinning, n.numClippingPlanes = t.numClippingPlanes, n.numIntersection = t.numClipIntersection, n.vertexAlphas = t.vertexAlphas } function Be(e, t, n, i) { !0 !== t.isScene && (t = V), q.resetTextureUnits(); const r = t.fog, s = n.isMeshStandardMaterial ? t.environment : null, o = null === y ? f.outputEncoding : y.texture.encoding, a = _.get(n.envMap || s), l = !0 === n.vertexColors && i.geometry && i.geometry.attributes.color && 4 === i.geometry.attributes.color.itemSize, c = Z.get(n), A = h.state.lights; if (!0 === F && (!0 === Q || e !== x)) { const t = e === x && n.id === w; oe.setState(n, e, t) } let u = !1; n.version === c.__version ? c.needsLights && c.lightsStateVersion !== A.state.version || c.outputEncoding !== o || i.isInstancedMesh && !1 === c.instancing ? u = !0 : i.isInstancedMesh || !0 !== c.instancing ? i.isSkinnedMesh && !1 === c.skinning ? u = !0 : i.isSkinnedMesh || !0 !== c.skinning ? c.envMap !== a || n.fog && c.fog !== r ? u = !0 : void 0 === c.numClippingPlanes || c.numClippingPlanes === oe.numPlanes && c.numIntersection === oe.numIntersection ? c.vertexAlphas !== l && (u = !0) : u = !0 : u = !0 : u = !0 : (u = !0, c.__version = n.version); let d = c.currentProgram; !0 === u && (d = Pe(n, t, i)); let p = !1, g = !1, m = !1; const v = d.getUniforms(), C = c.uniforms; if (J.useProgram(d.program) && (p = !0, g = !0, m = !0), n.id !== w && (w = n.id, g = !0), p || x !== e) { if (v.setValue(fe, "projectionMatrix", e.projectionMatrix), X.logarithmicDepthBuffer && v.setValue(fe, "logDepthBufFC", 2 / (Math.log(e.far + 1) / Math.LN2)), x !== e && (x = e, g = !0, m = !0), n.isShaderMaterial || n.isMeshPhongMaterial || n.isMeshToonMaterial || n.isMeshStandardMaterial || n.envMap) { const t = v.map.cameraPosition; void 0 !== t && t.setValue(fe, U.setFromMatrixPosition(e.matrixWorld)) } (n.isMeshPhongMaterial || n.isMeshToonMaterial || n.isMeshLambertMaterial || n.isMeshBasicMaterial || n.isMeshStandardMaterial || n.isShaderMaterial) && v.setValue(fe, "isOrthographic", !0 === e.isOrthographicCamera), (n.isMeshPhongMaterial || n.isMeshToonMaterial || n.isMeshLambertMaterial || n.isMeshBasicMaterial || n.isMeshStandardMaterial || n.isShaderMaterial || n.isShadowMaterial || i.isSkinnedMesh) && v.setValue(fe, "viewMatrix", e.matrixWorldInverse) } if (i.isSkinnedMesh) { v.setOptional(fe, i, "bindMatrix"), v.setOptional(fe, i, "bindMatrixInverse"); const e = i.skeleton; e && (X.floatVertexTextures ? (null === e.boneTexture && e.computeBoneTexture(), v.setValue(fe, "boneTexture", e.boneTexture, q), v.setValue(fe, "boneTextureSize", e.boneTextureSize)) : v.setOptional(fe, e, "boneMatrices")) } var b, M; return (g || c.receiveShadow !== i.receiveShadow) && (c.receiveShadow = i.receiveShadow, v.setValue(fe, "receiveShadow", i.receiveShadow)), g && (v.setValue(fe, "toneMappingExposure", f.toneMappingExposure), c.needsLights && (M = m, (b = C).ambientLightColor.needsUpdate = M, b.lightProbe.needsUpdate = M, b.directionalLights.needsUpdate = M, b.directionalLightShadows.needsUpdate = M, b.pointLights.needsUpdate = M, b.pointLightShadows.needsUpdate = M, b.spotLights.needsUpdate = M, b.spotLightShadows.needsUpdate = M, b.rectAreaLights.needsUpdate = M, b.hemisphereLights.needsUpdate = M), r && n.fog && ie.refreshFogUniforms(C, r), ie.refreshMaterialUniforms(C, n, T, E, G), Ii.upload(fe, c.uniformsList, C, q)), n.isShaderMaterial && !0 === n.uniformsNeedUpdate && (Ii.upload(fe, c.uniformsList, C, q), n.uniformsNeedUpdate = !1), n.isSpriteMaterial && v.setValue(fe, "center", i.center), v.setValue(fe, "modelViewMatrix", i.modelViewMatrix), v.setValue(fe, "normalMatrix", i.normalMatrix), v.setValue(fe, "modelMatrix", i.matrixWorld), d } Ie.setAnimationLoop((function (e) { Ce && Ce(e) })), "undefined" != typeof window && Ie.setContext(window), this.setAnimationLoop = function (e) { Ce = e, ve.setAnimationLoop(e), null === e ? Ie.stop() : Ie.start() }, ve.addEventListener("sessionstart", be), ve.addEventListener("sessionend", Me), this.render = function (e, t) { if (void 0 !== t && !0 !== t.isCamera) return void console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera."); if (!0 === g) return; !0 === e.autoUpdate && e.updateMatrixWorld(), null === t.parent && t.updateMatrixWorld(), !0 === ve.enabled && !0 === ve.isPresenting && (!0 === ve.cameraAutoUpdate && ve.updateCamera(t), t = ve.getCamera()), !0 === e.isScene && e.onBeforeRender(f, e, t, y), h = se.get(e, p.length), h.init(), p.push(h), j.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse), z.setFromProjectionMatrix(j), Q = this.localClippingEnabled, F = oe.init(this.clippingPlanes, Q, t), u = re.get(e, d.length), u.init(), d.push(u), function e(t, n, i, r) { if (!1 === t.visible) return; if (t.layers.test(n.layers)) if (t.isGroup) i = t.renderOrder; else if (t.isLOD) !0 === t.autoUpdate && t.update(n); else if (t.isLight) h.pushLight(t), t.castShadow && h.pushShadow(t); else if (t.isSprite) { if (!t.frustumCulled || z.intersectsSprite(t)) { r && U.setFromMatrixPosition(t.matrixWorld).applyMatrix4(j); const e = te.update(t), n = t.material; n.visible && u.push(t, e, n, i, U.z, null) } } else if (t.isImmediateRenderObject) r && U.setFromMatrixPosition(t.matrixWorld).applyMatrix4(j), u.push(t, null, t.material, i, U.z, null); else if ((t.isMesh || t.isLine || t.isPoints) && (t.isSkinnedMesh && t.skeleton.frame !== K.render.frame && (t.skeleton.update(), t.skeleton.frame = K.render.frame), !t.frustumCulled || z.intersectsObject(t))) { r && U.setFromMatrixPosition(t.matrixWorld).applyMatrix4(j); const e = te.update(t), n = t.material; if (Array.isArray(n)) { const r = e.groups; for (let s = 0, o = r.length; s < o; s++) { const o = r[s], a = n[o.materialIndex]; a && a.visible && u.push(t, e, a, i, U.z, o) } } else n.visible && u.push(t, e, n, i, U.z, null) } const s = t.children; for (let t = 0, o = s.length; t < o; t++)e(s[t], n, i, r) }(e, t, 0, f.sortObjects), u.finish(), !0 === f.sortObjects && u.sort(P, S), !0 === F && oe.beginShadows(); const n = h.state.shadowsArray; ae.render(n, e, t), h.setupLights(), h.setupLightsView(t), !0 === F && oe.endShadows(), !0 === this.info.autoReset && this.info.reset(), le.render(u, e); const i = u.opaque, r = u.transmissive, s = u.transparent; i.length > 0 && Ee(i, e, t), r.length > 0 && function (e, t, n, i) { if (null === G) { const e = !0 === o && !0 === X.isWebGL2; G = new (e ? R : D)(1024, 1024, { generateMipmaps: !0, type: null !== de.convert(1016) ? 1016 : 1009, minFilter: 1008, magFilter: 1003, wrapS: 1001, wrapT: 1001 }) } const r = f.getRenderTarget(); f.setRenderTarget(G), f.clear(); const s = f.toneMapping; f.toneMapping = 0, Ee(e, n, i), f.toneMapping = s, q.updateMultisampleRenderTarget(G), q.updateRenderTargetMipmap(G), f.setRenderTarget(r), Ee(t, n, i) }(i, r, e, t), s.length > 0 && Ee(s, e, t), null !== y && (q.updateMultisampleRenderTarget(y), q.updateRenderTargetMipmap(y)), !0 === e.isScene && e.onAfterRender(f, e, t), J.buffers.depth.setTest(!0), J.buffers.depth.setMask(!0), J.buffers.color.setMask(!0), J.setPolygonOffset(!1), pe.resetDefaultState(), w = -1, x = null, p.pop(), h = p.length > 0 ? p[p.length - 1] : null, d.pop(), u = d.length > 0 ? d[d.length - 1] : null }, this.getActiveCubeFace = function () { return m }, this.getActiveMipmapLevel = function () { return v }, this.getRenderTarget = function () { return y }, this.setRenderTarget = function (e, t = 0, n = 0) { y = e, m = t, v = n, e && void 0 === Z.get(e).__webglFramebuffer && q.setupRenderTarget(e); let i = null, r = !1, s = !1; if (e) { const n = e.texture; (n.isDataTexture3D || n.isDataTexture2DArray) && (s = !0); const o = Z.get(e).__webglFramebuffer; e.isWebGLCubeRenderTarget ? (i = o[t], r = !0) : i = e.isWebGLMultisampleRenderTarget ? Z.get(e).__webglMultisampledFramebuffer : o, C.copy(e.viewport), b.copy(e.scissor), M = e.scissorTest } else C.copy(L).multiplyScalar(T).floor(), b.copy(N).multiplyScalar(T).floor(), M = k; if (J.bindFramebuffer(36160, i) && X.drawBuffers) { let t = !1; if (e) if (e.isWebGLMultipleRenderTargets) { const n = e.texture; if (H.length !== n.length || 36064 !== H[0]) { for (let e = 0, t = n.length; e < t; e++)H[e] = 36064 + e; H.length = n.length, t = !0 } } else 1 === H.length && 36064 === H[0] || (H[0] = 36064, H.length = 1, t = !0); else 1 === H.length && 1029 === H[0] || (H[0] = 1029, H.length = 1, t = !0); t && (X.isWebGL2 ? fe.drawBuffers(H) : W.get("WEBGL_draw_buffers").drawBuffersWEBGL(H)) } if (J.viewport(C), J.scissor(b), J.setScissorTest(M), r) { const i = Z.get(e.texture); fe.framebufferTexture2D(36160, 36064, 34069 + t, i.__webglTexture, n) } else if (s) { const i = Z.get(e.texture), r = t || 0; fe.framebufferTextureLayer(36160, 36064, i.__webglTexture, n || 0, r) } }, this.readRenderTargetPixels = function (e, t, n, i, r, s, o) { if (!e || !e.isWebGLRenderTarget) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget."); let a = Z.get(e).__webglFramebuffer; if (e.isWebGLCubeRenderTarget && void 0 !== o && (a = a[o]), a) { J.bindFramebuffer(36160, a); try { const o = e.texture, a = o.format, l = o.type; if (1023 !== a && de.convert(a) !== fe.getParameter(35739)) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format."); const c = 1016 === l && (W.has("EXT_color_buffer_half_float") || X.isWebGL2 && W.has("EXT_color_buffer_float")); if (!(1009 === l || de.convert(l) === fe.getParameter(35738) || 1015 === l && (X.isWebGL2 || W.has("OES_texture_float") || W.has("WEBGL_color_buffer_float")) || c)) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type."); 36053 === fe.checkFramebufferStatus(36160) ? t >= 0 && t <= e.width - i && n >= 0 && n <= e.height - r && fe.readPixels(t, n, i, r, de.convert(a), de.convert(l), s) : console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.") } finally { const e = null !== y ? Z.get(y).__webglFramebuffer : null; J.bindFramebuffer(36160, e) } } }, this.copyFramebufferToTexture = function (e, t, n = 0) { const i = Math.pow(2, -n), r = Math.floor(t.image.width * i), s = Math.floor(t.image.height * i); let o = de.convert(t.format); X.isWebGL2 && (6407 === o && (o = 32849), 6408 === o && (o = 32856)), q.setTexture2D(t, 0), fe.copyTexImage2D(3553, n, o, e.x, e.y, r, s, 0), J.unbindTexture() }, this.copyTextureToTexture = function (e, t, n, i = 0) { const r = t.image.width, s = t.image.height, o = de.convert(n.format), a = de.convert(n.type); q.setTexture2D(n, 0), fe.pixelStorei(37440, n.flipY), fe.pixelStorei(37441, n.premultiplyAlpha), fe.pixelStorei(3317, n.unpackAlignment), t.isDataTexture ? fe.texSubImage2D(3553, i, e.x, e.y, r, s, o, a, t.image.data) : t.isCompressedTexture ? fe.compressedTexSubImage2D(3553, i, e.x, e.y, t.mipmaps[0].width, t.mipmaps[0].height, o, t.mipmaps[0].data) : fe.texSubImage2D(3553, i, e.x, e.y, o, a, t.image), 0 === i && n.generateMipmaps && fe.generateMipmap(3553), J.unbindTexture() }, this.copyTextureToTexture3D = function (e, t, n, i, r = 0) { if (f.isWebGL1Renderer) return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2."); const s = e.max.x - e.min.x + 1, o = e.max.y - e.min.y + 1, a = e.max.z - e.min.z + 1, l = de.convert(i.format), c = de.convert(i.type); let A; if (i.isDataTexture3D) q.setTexture3D(i, 0), A = 32879; else { if (!i.isDataTexture2DArray) return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray."); q.setTexture2DArray(i, 0), A = 35866 } fe.pixelStorei(37440, i.flipY), fe.pixelStorei(37441, i.premultiplyAlpha), fe.pixelStorei(3317, i.unpackAlignment); const u = fe.getParameter(3314), h = fe.getParameter(32878), d = fe.getParameter(3316), p = fe.getParameter(3315), g = fe.getParameter(32877), m = n.isCompressedTexture ? n.mipmaps[0] : n.image; fe.pixelStorei(3314, m.width), fe.pixelStorei(32878, m.height), fe.pixelStorei(3316, e.min.x), fe.pixelStorei(3315, e.min.y), fe.pixelStorei(32877, e.min.z), n.isDataTexture || n.isDataTexture3D ? fe.texSubImage3D(A, r, t.x, t.y, t.z, s, o, a, l, c, m.data) : n.isCompressedTexture ? (console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."), fe.compressedTexSubImage3D(A, r, t.x, t.y, t.z, s, o, a, l, m.data)) : fe.texSubImage3D(A, r, t.x, t.y, t.z, s, o, a, l, c, m), fe.pixelStorei(3314, u), fe.pixelStorei(32878, h), fe.pixelStorei(3316, d), fe.pixelStorei(3315, p), fe.pixelStorei(32877, g), 0 === r && i.generateMipmaps && fe.generateMipmap(A), J.unbindTexture() }, this.initTexture = function (e) { q.setTexture2D(e, 0), J.unbindTexture() }, this.resetState = function () { m = 0, v = 0, y = null, J.reset(), pe.reset() }, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this })) } (class extends gr { }).prototype.isWebGL1Renderer = !0; class mr { constructor(e, t = 25e-5) { this.name = "", this.color = new nt(e), this.density = t } clone() { return new mr(this.color, this.density) } toJSON() { return { type: "FogExp2", color: this.color.getHex(), density: this.density } } } mr.prototype.isFogExp2 = !0; class vr { constructor(e, t = 1, n = 1e3) { this.name = "", this.color = new nt(e), this.near = t, this.far = n } clone() { return new vr(this.color, this.near, this.far) } toJSON() { return { type: "Fog", color: this.color.getHex(), near: this.near, far: this.far } } } vr.prototype.isFog = !0; class yr extends ke { constructor() { super(), this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.overrideMaterial = null, this.autoUpdate = !0, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this })) } copy(e, t) { return super.copy(e, t), null !== e.background && (this.background = e.background.clone()), null !== e.environment && (this.environment = e.environment.clone()), null !== e.fog && (this.fog = e.fog.clone()), null !== e.overrideMaterial && (this.overrideMaterial = e.overrideMaterial.clone()), this.autoUpdate = e.autoUpdate, this.matrixAutoUpdate = e.matrixAutoUpdate, this } toJSON(e) { const t = super.toJSON(e); return null !== this.fog && (t.object.fog = this.fog.toJSON()), t } } yr.prototype.isScene = !0; class wr { constructor(e, t) { this.array = e, this.stride = t, this.count = void 0 !== e ? e.length / t : 0, this.usage = 35044, this.updateRange = { offset: 0, count: -1 }, this.version = 0, this.uuid = f() } onUploadCallback() { } set needsUpdate(e) { !0 === e && this.version++ } setUsage(e) { return this.usage = e, this } copy(e) { return this.array = new e.array.constructor(e.array), this.count = e.count, this.stride = e.stride, this.usage = e.usage, this } copyAt(e, t, n) { e *= this.stride, n *= t.stride; for (let i = 0, r = this.stride; i < r; i++)this.array[e + i] = t.array[n + i]; return this } set(e, t = 0) { return this.array.set(e, t), this } clone(e) { void 0 === e.arrayBuffers && (e.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = f()), void 0 === e.arrayBuffers[this.array.buffer._uuid] && (e.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer); const t = new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid]), n = new this.constructor(t, this.stride); return n.setUsage(this.usage), n } onUpload(e) { return this.onUploadCallback = e, this } toJSON(e) { return void 0 === e.arrayBuffers && (e.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = f()), void 0 === e.arrayBuffers[this.array.buffer._uuid] && (e.arrayBuffers[this.array.buffer._uuid] = Array.prototype.slice.call(new Uint32Array(this.array.buffer))), { uuid: this.uuid, buffer: this.array.buffer._uuid, type: this.array.constructor.name, stride: this.stride } } } wr.prototype.isInterleavedBuffer = !0; const xr = new O; class Cr { constructor(e, t, n, i = !1) { this.name = "", this.data = e, this.itemSize = t, this.offset = n, this.normalized = !0 === i } get count() { return this.data.count } get array() { return this.data.array } set needsUpdate(e) { this.data.needsUpdate = e } applyMatrix4(e) { for (let t = 0, n = this.data.count; t < n; t++)xr.x = this.getX(t), xr.y = this.getY(t), xr.z = this.getZ(t), xr.applyMatrix4(e), this.setXYZ(t, xr.x, xr.y, xr.z); return this } applyNormalMatrix(e) { for (let t = 0, n = this.count; t < n; t++)xr.x = this.getX(t), xr.y = this.getY(t), xr.z = this.getZ(t), xr.applyNormalMatrix(e), this.setXYZ(t, xr.x, xr.y, xr.z); return this } transformDirection(e) { for (let t = 0, n = this.count; t < n; t++)xr.x = this.getX(t), xr.y = this.getY(t), xr.z = this.getZ(t), xr.transformDirection(e), this.setXYZ(t, xr.x, xr.y, xr.z); return this } setX(e, t) { return this.data.array[e * this.data.stride + this.offset] = t, this } setY(e, t) { return this.data.array[e * this.data.stride + this.offset + 1] = t, this } setZ(e, t) { return this.data.array[e * this.data.stride + this.offset + 2] = t, this } setW(e, t) { return this.data.array[e * this.data.stride + this.offset + 3] = t, this } getX(e) { return this.data.array[e * this.data.stride + this.offset] } getY(e) { return this.data.array[e * this.data.stride + this.offset + 1] } getZ(e) { return this.data.array[e * this.data.stride + this.offset + 2] } getW(e) { return this.data.array[e * this.data.stride + this.offset + 3] } setXY(e, t, n) { return e = e * this.data.stride + this.offset, this.data.array[e + 0] = t, this.data.array[e + 1] = n, this } setXYZ(e, t, n, i) { return e = e * this.data.stride + this.offset, this.data.array[e + 0] = t, this.data.array[e + 1] = n, this.data.array[e + 2] = i, this } setXYZW(e, t, n, i, r) { return e = e * this.data.stride + this.offset, this.data.array[e + 0] = t, this.data.array[e + 1] = n, this.data.array[e + 2] = i, this.data.array[e + 3] = r, this } clone(e) { if (void 0 === e) { console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data."); const e = []; for (let t = 0; t < this.count; t++) { const n = t * this.data.stride + this.offset; for (let t = 0; t < this.itemSize; t++)e.push(this.data.array[n + t]) } return new ot(new this.array.constructor(e), this.itemSize, this.normalized) } return void 0 === e.interleavedBuffers && (e.interleavedBuffers = {}), void 0 === e.interleavedBuffers[this.data.uuid] && (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)), new Cr(e.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized) } toJSON(e) { if (void 0 === e) { console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data."); const e = []; for (let t = 0; t < this.count; t++) { const n = t * this.data.stride + this.offset; for (let t = 0; t < this.itemSize; t++)e.push(this.data.array[n + t]) } return { itemSize: this.itemSize, type: this.array.constructor.name, array: e, normalized: this.normalized } } return void 0 === e.interleavedBuffers && (e.interleavedBuffers = {}), void 0 === e.interleavedBuffers[this.data.uuid] && (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)), { isInterleavedBufferAttribute: !0, itemSize: this.itemSize, data: this.data.uuid, offset: this.offset, normalized: this.normalized } } } Cr.prototype.isInterleavedBufferAttribute = !0; class br extends Ke { constructor(e) { super(), this.type = "SpriteMaterial", this.color = new nt(16777215), this.map = null, this.alphaMap = null, this.rotation = 0, this.sizeAttenuation = !0, this.transparent = !0, this.setValues(e) } copy(e) { return super.copy(e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.rotation = e.rotation, this.sizeAttenuation = e.sizeAttenuation, this } } let Mr; br.prototype.isSpriteMaterial = !0; const Ir = new O, Er = new O, Tr = new O, Pr = new b, Sr = new b, Br = new ue, Dr = new O, Rr = new O, Lr = new O, Or = new b, Nr = new b, kr = new b; class Hr extends ke { constructor(e) { if (super(), this.type = "Sprite", void 0 === Mr) { Mr = new vt; const e = new Float32Array([-.5, -.5, 0, 0, 0, .5, -.5, 0, 1, 0, .5, .5, 0, 1, 1, -.5, .5, 0, 0, 1]), t = new wr(e, 5); Mr.setIndex([0, 1, 2, 0, 2, 3]), Mr.setAttribute("position", new Cr(t, 3, 0, !1)), Mr.setAttribute("uv", new Cr(t, 2, 3, !1)) } this.geometry = Mr, this.material = void 0 !== e ? e : new br, this.center = new b(.5, .5) } raycast(e, t) { null === e.camera && console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'), Er.setFromMatrixScale(this.matrixWorld), Br.copy(e.camera.matrixWorld), this.modelViewMatrix.multiplyMatrices(e.camera.matrixWorldInverse, this.matrixWorld), Tr.setFromMatrixPosition(this.modelViewMatrix), e.camera.isPerspectiveCamera && !1 === this.material.sizeAttenuation && Er.multiplyScalar(-Tr.z); const n = this.material.rotation; let i, r; 0 !== n && (r = Math.cos(n), i = Math.sin(n)); const s = this.center; zr(Dr.set(-.5, -.5, 0), Tr, s, Er, i, r), zr(Rr.set(.5, -.5, 0), Tr, s, Er, i, r), zr(Lr.set(.5, .5, 0), Tr, s, Er, i, r), Or.set(0, 0), Nr.set(1, 0), kr.set(1, 1); let o = e.ray.intersectTriangle(Dr, Rr, Lr, !1, Ir); if (null === o && (zr(Rr.set(-.5, .5, 0), Tr, s, Er, i, r), Nr.set(0, 1), o = e.ray.intersectTriangle(Dr, Lr, Rr, !1, Ir), null === o)) return; const a = e.ray.origin.distanceTo(Ir); a < e.near || a > e.far || t.push({ distance: a, point: Ir.clone(), uv: Xe.getUV(Ir, Dr, Rr, Lr, Or, Nr, kr, new b), face: null, object: this }) } copy(e) { return super.copy(e), void 0 !== e.center && this.center.copy(e.center), this.material = e.material, this } } function zr(e, t, n, i, r, s) { Pr.subVectors(e, n).addScalar(.5).multiply(i), void 0 !== r ? (Sr.x = s * Pr.x - r * Pr.y, Sr.y = r * Pr.x + s * Pr.y) : Sr.copy(Pr), e.copy(t), e.x += Sr.x, e.y += Sr.y, e.applyMatrix4(Br) } Hr.prototype.isSprite = !0; const Fr = new O, Qr = new B, Gr = new B, jr = new O, Ur = new ue; class Vr extends kt { constructor(e, t) { super(e, t), this.type = "SkinnedMesh", this.bindMode = "attached", this.bindMatrix = new ue, this.bindMatrixInverse = new ue } copy(e) { return super.copy(e), this.bindMode = e.bindMode, this.bindMatrix.copy(e.bindMatrix), this.bindMatrixInverse.copy(e.bindMatrixInverse), this.skeleton = e.skeleton, this } bind(e, t) { this.skeleton = e, void 0 === t && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), t = this.matrixWorld), this.bindMatrix.copy(t), this.bindMatrixInverse.copy(t).invert() } pose() { this.skeleton.pose() } normalizeSkinWeights() { const e = new B, t = this.geometry.attributes.skinWeight; for (let n = 0, i = t.count; n < i; n++) { e.x = t.getX(n), e.y = t.getY(n), e.z = t.getZ(n), e.w = t.getW(n); const i = 1 / e.manhattanLength(); i !== 1 / 0 ? e.multiplyScalar(i) : e.set(1, 0, 0, 0), t.setXYZW(n, e.x, e.y, e.z, e.w) } } updateMatrixWorld(e) { super.updateMatrixWorld(e), "attached" === this.bindMode ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : "detached" === this.bindMode ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode) } boneTransform(e, t) { const n = this.skeleton, i = this.geometry; Qr.fromBufferAttribute(i.attributes.skinIndex, e), Gr.fromBufferAttribute(i.attributes.skinWeight, e), Fr.fromBufferAttribute(i.attributes.position, e).applyMatrix4(this.bindMatrix), t.set(0, 0, 0); for (let e = 0; e < 4; e++) { const i = Gr.getComponent(e); if (0 !== i) { const r = Qr.getComponent(e); Ur.multiplyMatrices(n.bones[r].matrixWorld, n.boneInverses[r]), t.addScaledVector(jr.copy(Fr).applyMatrix4(Ur), i) } } return t.applyMatrix4(this.bindMatrixInverse) } } Vr.prototype.isSkinnedMesh = !0; class Yr extends ke { constructor() { super(), this.type = "Bone" } } Yr.prototype.isBone = !0; class Wr extends P { constructor(e = null, t = 1, n = 1, i, r, s, o, a, l = 1003, c = 1003, A, u) { super(null, s, o, a, l, c, i, r, A, u), this.image = { data: e, width: t, height: n }, this.magFilter = l, this.minFilter = c, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1, this.needsUpdate = !0 } } Wr.prototype.isDataTexture = !0; const Xr = new ue, Jr = new ue; class Kr { constructor(e = [], t = []) { this.uuid = f(), this.bones = e.slice(0), this.boneInverses = t, this.boneMatrices = null, this.boneTexture = null, this.boneTextureSize = 0, this.frame = -1, this.init() } init() { const e = this.bones, t = this.boneInverses; if (this.boneMatrices = new Float32Array(16 * e.length), 0 === t.length) this.calculateInverses(); else if (e.length !== t.length) { console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."), this.boneInverses = []; for (let e = 0, t = this.bones.length; e < t; e++)this.boneInverses.push(new ue) } } calculateInverses() { this.boneInverses.length = 0; for (let e = 0, t = this.bones.length; e < t; e++) { const t = new ue; this.bones[e] && t.copy(this.bones[e].matrixWorld).invert(), this.boneInverses.push(t) } } pose() { for (let e = 0, t = this.bones.length; e < t; e++) { const t = this.bones[e]; t && t.matrixWorld.copy(this.boneInverses[e]).invert() } for (let e = 0, t = this.bones.length; e < t; e++) { const t = this.bones[e]; t && (t.parent && t.parent.isBone ? (t.matrix.copy(t.parent.matrixWorld).invert(), t.matrix.multiply(t.matrixWorld)) : t.matrix.copy(t.matrixWorld), t.matrix.decompose(t.position, t.quaternion, t.scale)) } } update() { const e = this.bones, t = this.boneInverses, n = this.boneMatrices, i = this.boneTexture; for (let i = 0, r = e.length; i < r; i++) { const r = e[i] ? e[i].matrixWorld : Jr; Xr.multiplyMatrices(r, t[i]), Xr.toArray(n, 16 * i) } null !== i && (i.needsUpdate = !0) } clone() { return new Kr(this.bones, this.boneInverses) } computeBoneTexture() { let e = Math.sqrt(4 * this.bones.length); e = w(e), e = Math.max(e, 4); const t = new Float32Array(e * e * 4); t.set(this.boneMatrices); const n = new Wr(t, e, e, 1023, 1015); return this.boneMatrices = t, this.boneTexture = n, this.boneTextureSize = e, this } getBoneByName(e) { for (let t = 0, n = this.bones.length; t < n; t++) { const n = this.bones[t]; if (n.name === e) return n } } dispose() { null !== this.boneTexture && (this.boneTexture.dispose(), this.boneTexture = null) } fromJSON(e, t) { this.uuid = e.uuid; for (let n = 0, i = e.bones.length; n < i; n++) { const i = e.bones[n]; let r = t[i]; void 0 === r && (console.warn("THREE.Skeleton: No bone found with UUID:", i), r = new Yr), this.bones.push(r), this.boneInverses.push((new ue).fromArray(e.boneInverses[n])) } return this.init(), this } toJSON() { const e = { metadata: { version: 4.5, type: "Skeleton", generator: "Skeleton.toJSON" }, bones: [], boneInverses: [] }; e.uuid = this.uuid; const t = this.bones, n = this.boneInverses; for (let i = 0, r = t.length; i < r; i++) { const r = t[i]; e.bones.push(r.uuid); const s = n[i]; e.boneInverses.push(s.toArray()) } return e } } const Zr = new ue, qr = new ue, _r = [], $r = new kt; class es extends kt { constructor(e, t, n) { super(e, t), this.instanceMatrix = new ot(new Float32Array(16 * n), 16), this.instanceColor = null, this.count = n, this.frustumCulled = !1 } copy(e) { return super.copy(e), this.instanceMatrix.copy(e.instanceMatrix), null !== e.instanceColor && (this.instanceColor = e.instanceColor.clone()), this.count = e.count, this } getColorAt(e, t) { t.fromArray(this.instanceColor.array, 3 * e) } getMatrixAt(e, t) { t.fromArray(this.instanceMatrix.array, 16 * e) } raycast(e, t) { const n = this.matrixWorld, i = this.count; if ($r.geometry = this.geometry, $r.material = this.material, void 0 !== $r.material) for (let r = 0; r < i; r++) { this.getMatrixAt(r, Zr), qr.multiplyMatrices(n, Zr), $r.matrixWorld = qr, $r.raycast(e, _r); for (let e = 0, n = _r.length; e < n; e++) { const n = _r[e]; n.instanceId = r, n.object = this, t.push(n) } _r.length = 0 } } setColorAt(e, t) { null === this.instanceColor && (this.instanceColor = new ot(new Float32Array(3 * this.count), 3)), t.toArray(this.instanceColor.array, 3 * e) } setMatrixAt(e, t) { t.toArray(this.instanceMatrix.array, 16 * e) } updateMorphTargets() { } dispose() { this.dispatchEvent({ type: "dispose" }) } } es.prototype.isInstancedMesh = !0; class ts extends Ke { constructor(e) { super(), this.type = "LineBasicMaterial", this.color = new nt(16777215), this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.morphTargets = !1, this.setValues(e) } copy(e) { return super.copy(e), this.color.copy(e.color), this.linewidth = e.linewidth, this.linecap = e.linecap, this.linejoin = e.linejoin, this.morphTargets = e.morphTargets, this } } ts.prototype.isLineBasicMaterial = !0; const ns = new O, is = new O, rs = new ue, ss = new Ae, os = new ne; class as extends ke { constructor(e = new vt, t = new ts) { super(), this.type = "Line", this.geometry = e, this.material = t, this.updateMorphTargets() } copy(e) { return super.copy(e), this.material = e.material, this.geometry = e.geometry, this } computeLineDistances() { const e = this.geometry; if (e.isBufferGeometry) if (null === e.index) { const t = e.attributes.position, n = [0]; for (let e = 1, i = t.count; e < i; e++)ns.fromBufferAttribute(t, e - 1), is.fromBufferAttribute(t, e), n[e] = n[e - 1], n[e] += ns.distanceTo(is); e.setAttribute("lineDistance", new ct(n, 1)) } else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."); else e.isGeometry && console.error("THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."); return this } raycast(e, t) { const n = this.geometry, i = this.matrixWorld, r = e.params.Line.threshold, s = n.drawRange; if (null === n.boundingSphere && n.computeBoundingSphere(), os.copy(n.boundingSphere), os.applyMatrix4(i), os.radius += r, !1 === e.ray.intersectsSphere(os)) return; rs.copy(i).invert(), ss.copy(e.ray).applyMatrix4(rs); const o = r / ((this.scale.x + this.scale.y + this.scale.z) / 3), a = o * o, l = new O, c = new O, A = new O, u = new O, h = this.isLineSegments ? 2 : 1; if (n.isBufferGeometry) { const i = n.index, r = n.attributes.position; if (null !== i) { for (let n = Math.max(0, s.start), o = Math.min(i.count, s.start + s.count) - 1; n < o; n += h) { const s = i.getX(n), o = i.getX(n + 1); l.fromBufferAttribute(r, s), c.fromBufferAttribute(r, o); if (ss.distanceSqToSegment(l, c, u, A) > a) continue; u.applyMatrix4(this.matrixWorld); const h = e.ray.origin.distanceTo(u); h < e.near || h > e.far || t.push({ distance: h, point: A.clone().applyMatrix4(this.matrixWorld), index: n, face: null, faceIndex: null, object: this }) } } else { for (let n = Math.max(0, s.start), i = Math.min(r.count, s.start + s.count) - 1; n < i; n += h) { l.fromBufferAttribute(r, n), c.fromBufferAttribute(r, n + 1); if (ss.distanceSqToSegment(l, c, u, A) > a) continue; u.applyMatrix4(this.matrixWorld); const i = e.ray.origin.distanceTo(u); i < e.near || i > e.far || t.push({ distance: i, point: A.clone().applyMatrix4(this.matrixWorld), index: n, face: null, faceIndex: null, object: this }) } } } else n.isGeometry && console.error("THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.") } updateMorphTargets() { const e = this.geometry; if (e.isBufferGeometry) { const t = e.morphAttributes, n = Object.keys(t); if (n.length > 0) { const e = t[n[0]]; if (void 0 !== e) { this.morphTargetInfluences = [], this.morphTargetDictionary = {}; for (let t = 0, n = e.length; t < n; t++) { const n = e[t].name || String(t); this.morphTargetInfluences.push(0), this.morphTargetDictionary[n] = t } } } } else { const t = e.morphTargets; void 0 !== t && t.length > 0 && console.error("THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.") } } } as.prototype.isLine = !0; const ls = new O, cs = new O; class As extends as { constructor(e, t) { super(e, t), this.type = "LineSegments" } computeLineDistances() { const e = this.geometry; if (e.isBufferGeometry) if (null === e.index) { const t = e.attributes.position, n = []; for (let e = 0, i = t.count; e < i; e += 2)ls.fromBufferAttribute(t, e), cs.fromBufferAttribute(t, e + 1), n[e] = 0 === e ? 0 : n[e - 1], n[e + 1] = n[e] + ls.distanceTo(cs); e.setAttribute("lineDistance", new ct(n, 1)) } else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."); else e.isGeometry && console.error("THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."); return this } } As.prototype.isLineSegments = !0; class us extends as { constructor(e, t) { super(e, t), this.type = "LineLoop" } } us.prototype.isLineLoop = !0; class hs extends Ke { constructor(e) { super(), this.type = "PointsMaterial", this.color = new nt(16777215), this.map = null, this.alphaMap = null, this.size = 1, this.sizeAttenuation = !0, this.morphTargets = !1, this.setValues(e) } copy(e) { return super.copy(e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.size = e.size, this.sizeAttenuation = e.sizeAttenuation, this.morphTargets = e.morphTargets, this } } hs.prototype.isPointsMaterial = !0; const ds = new ue, ps = new Ae, fs = new ne, gs = new O; class ms extends ke { constructor(e = new vt, t = new hs) { super(), this.type = "Points", this.geometry = e, this.material = t, this.updateMorphTargets() } copy(e) { return super.copy(e), this.material = e.material, this.geometry = e.geometry, this } raycast(e, t) { const n = this.geometry, i = this.matrixWorld, r = e.params.Points.threshold, s = n.drawRange; if (null === n.boundingSphere && n.computeBoundingSphere(), fs.copy(n.boundingSphere), fs.applyMatrix4(i), fs.radius += r, !1 === e.ray.intersectsSphere(fs)) return; ds.copy(i).invert(), ps.copy(e.ray).applyMatrix4(ds); const o = r / ((this.scale.x + this.scale.y + this.scale.z) / 3), a = o * o; if (n.isBufferGeometry) { const r = n.index, o = n.attributes.position; if (null !== r) { for (let n = Math.max(0, s.start), l = Math.min(r.count, s.start + s.count); n < l; n++) { const s = r.getX(n); gs.fromBufferAttribute(o, s), vs(gs, s, a, i, e, t, this) } } else { for (let n = Math.max(0, s.start), r = Math.min(o.count, s.start + s.count); n < r; n++)gs.fromBufferAttribute(o, n), vs(gs, n, a, i, e, t, this) } } else console.error("THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.") } updateMorphTargets() { const e = this.geometry; if (e.isBufferGeometry) { const t = e.morphAttributes, n = Object.keys(t); if (n.length > 0) { const e = t[n[0]]; if (void 0 !== e) { this.morphTargetInfluences = [], this.morphTargetDictionary = {}; for (let t = 0, n = e.length; t < n; t++) { const n = e[t].name || String(t); this.morphTargetInfluences.push(0), this.morphTargetDictionary[n] = t } } } } else { const t = e.morphTargets; void 0 !== t && t.length > 0 && console.error("THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.") } } } function vs(e, t, n, i, r, s, o) { const a = ps.distanceSqToPoint(e); if (a < n) { const n = new O; ps.closestPointToPoint(e, n), n.applyMatrix4(i); const l = r.ray.origin.distanceTo(n); if (l < r.near || l > r.far) return; s.push({ distance: l, distanceToRay: Math.sqrt(a), point: n, index: t, face: null, object: o }) } } ms.prototype.isPoints = !0; (class extends P { constructor(e, t, n, i, r, s, o, a, l) { super(e, t, n, i, r, s, o, a, l), this.format = void 0 !== o ? o : 1022, this.minFilter = void 0 !== s ? s : 1006, this.magFilter = void 0 !== r ? r : 1006, this.generateMipmaps = !1; const c = this; "requestVideoFrameCallback" in e && e.requestVideoFrameCallback((function t() { c.needsUpdate = !0, e.requestVideoFrameCallback(t) })) } clone() { return new this.constructor(this.image).copy(this) } update() { const e = this.image; !1 === "requestVideoFrameCallback" in e && e.readyState >= e.HAVE_CURRENT_DATA && (this.needsUpdate = !0) } }).prototype.isVideoTexture = !0; class ys extends P { constructor(e, t, n, i, r, s, o, a, l, c, A, u) { super(null, s, o, a, l, c, i, r, A, u), this.image = { width: t, height: n }, this.mipmaps = e, this.flipY = !1, this.generateMipmaps = !1 } } ys.prototype.isCompressedTexture = !0; (class extends P { constructor(e, t, n, i, r, s, o, a, l) { super(e, t, n, i, r, s, o, a, l), this.needsUpdate = !0 } }).prototype.isCanvasTexture = !0; (class extends P { constructor(e, t, n, i, r, s, o, a, l, c) { if (1026 !== (c = void 0 !== c ? c : 1026) && 1027 !== c) throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat"); void 0 === n && 1026 === c && (n = 1012), void 0 === n && 1027 === c && (n = 1020), super(null, i, r, s, o, a, c, n, l), this.image = { width: e, height: t }, this.magFilter = void 0 !== o ? o : 1003, this.minFilter = void 0 !== a ? a : 1003, this.flipY = !1, this.generateMipmaps = !1 } }).prototype.isDepthTexture = !0; class ws extends vt { constructor(e = 1, t = 8, n = 0, i = 2 * Math.PI) { super(), this.type = "CircleGeometry", this.parameters = { radius: e, segments: t, thetaStart: n, thetaLength: i }, t = Math.max(3, t); const r = [], s = [], o = [], a = [], l = new O, c = new b; s.push(0, 0, 0), o.push(0, 0, 1), a.push(.5, .5); for (let r = 0, A = 3; r <= t; r++, A += 3) { const u = n + r / t * i; l.x = e * Math.cos(u), l.y = e * Math.sin(u), s.push(l.x, l.y, l.z), o.push(0, 0, 1), c.x = (s[A] / e + 1) / 2, c.y = (s[A + 1] / e + 1) / 2, a.push(c.x, c.y) } for (let e = 1; e <= t; e++)r.push(e, e + 1, 0); this.setIndex(r), this.setAttribute("position", new ct(s, 3)), this.setAttribute("normal", new ct(o, 3)), this.setAttribute("uv", new ct(a, 2)) } static fromJSON(e) { return new ws(e.radius, e.segments, e.thetaStart, e.thetaLength) } } class xs extends vt { constructor(e = 1, t = 1, n = 1, i = 8, r = 1, s = !1, o = 0, a = 2 * Math.PI) { super(), this.type = "CylinderGeometry", this.parameters = { radiusTop: e, radiusBottom: t, height: n, radialSegments: i, heightSegments: r, openEnded: s, thetaStart: o, thetaLength: a }; const l = this; i = Math.floor(i), r = Math.floor(r); const c = [], A = [], u = [], h = []; let d = 0; const p = [], f = n / 2; let g = 0; function m(n) { const r = d, s = new b, p = new O; let m = 0; const v = !0 === n ? e : t, y = !0 === n ? 1 : -1; for (let e = 1; e <= i; e++)A.push(0, f * y, 0), u.push(0, y, 0), h.push(.5, .5), d++; const w = d; for (let e = 0; e <= i; e++) { const t = e / i * a + o, n = Math.cos(t), r = Math.sin(t); p.x = v * r, p.y = f * y, p.z = v * n, A.push(p.x, p.y, p.z), u.push(0, y, 0), s.x = .5 * n + .5, s.y = .5 * r * y + .5, h.push(s.x, s.y), d++ } for (let e = 0; e < i; e++) { const t = r + e, i = w + e; !0 === n ? c.push(i, i + 1, t) : c.push(i + 1, i, t), m += 3 } l.addGroup(g, m, !0 === n ? 1 : 2), g += m } !function () { const s = new O, m = new O; let v = 0; const y = (t - e) / n; for (let l = 0; l <= r; l++) { const c = [], g = l / r, v = g * (t - e) + e; for (let e = 0; e <= i; e++) { const t = e / i, r = t * a + o, l = Math.sin(r), p = Math.cos(r); m.x = v * l, m.y = -g * n + f, m.z = v * p, A.push(m.x, m.y, m.z), s.set(l, y, p).normalize(), u.push(s.x, s.y, s.z), h.push(t, 1 - g), c.push(d++) } p.push(c) } for (let e = 0; e < i; e++)for (let t = 0; t < r; t++) { const n = p[t][e], i = p[t + 1][e], r = p[t + 1][e + 1], s = p[t][e + 1]; c.push(n, i, s), c.push(i, r, s), v += 6 } l.addGroup(g, v, 0), g += v }(), !1 === s && (e > 0 && m(!0), t > 0 && m(!1)), this.setIndex(c), this.setAttribute("position", new ct(A, 3)), this.setAttribute("normal", new ct(u, 3)), this.setAttribute("uv", new ct(h, 2)) } static fromJSON(e) { return new xs(e.radiusTop, e.radiusBottom, e.height, e.radialSegments, e.heightSegments, e.openEnded, e.thetaStart, e.thetaLength) } } new O, new O, new O, new Xe; class Cs { constructor() { this.type = "Curve", this.arcLengthDivisions = 200 } getPoint() { return console.warn("THREE.Curve: .getPoint() not implemented."), null } getPointAt(e, t) { const n = this.getUtoTmapping(e); return this.getPoint(n, t) } getPoints(e = 5) { const t = []; for (let n = 0; n <= e; n++)t.push(this.getPoint(n / e)); return t } getSpacedPoints(e = 5) { const t = []; for (let n = 0; n <= e; n++)t.push(this.getPointAt(n / e)); return t } getLength() { const e = this.getLengths(); return e[e.length - 1] } getLengths(e = this.arcLengthDivisions) { if (this.cacheArcLengths && this.cacheArcLengths.length === e + 1 && !this.needsUpdate) return this.cacheArcLengths; this.needsUpdate = !1; const t = []; let n, i = this.getPoint(0), r = 0; t.push(0); for (let s = 1; s <= e; s++)n = this.getPoint(s / e), r += n.distanceTo(i), t.push(r), i = n; return this.cacheArcLengths = t, t } updateArcLengths() { this.needsUpdate = !0, this.getLengths() } getUtoTmapping(e, t) { const n = this.getLengths(); let i = 0; const r = n.length; let s; s = t || e * n[r - 1]; let o, a = 0, l = r - 1; for (; a <= l;)if (i = Math.floor(a + (l - a) / 2), o = n[i] - s, o < 0) a = i + 1; else { if (!(o > 0)) { l = i; break } l = i - 1 } if (i = l, n[i] === s) return i / (r - 1); const c = n[i]; return (i + (s - c) / (n[i + 1] - c)) / (r - 1) } getTangent(e, t) { let n = e - 1e-4, i = e + 1e-4; n < 0 && (n = 0), i > 1 && (i = 1); const r = this.getPoint(n), s = this.getPoint(i), o = t || (r.isVector2 ? new b : new O); return o.copy(s).sub(r).normalize(), o } getTangentAt(e, t) { const n = this.getUtoTmapping(e); return this.getTangent(n, t) } computeFrenetFrames(e, t) { const n = new O, i = [], r = [], s = [], o = new O, a = new ue; for (let t = 0; t <= e; t++) { const n = t / e; i[t] = this.getTangentAt(n, new O), i[t].normalize() } r[0] = new O, s[0] = new O; let l = Number.MAX_VALUE; const c = Math.abs(i[0].x), A = Math.abs(i[0].y), u = Math.abs(i[0].z); c <= l && (l = c, n.set(1, 0, 0)), A <= l && (l = A, n.set(0, 1, 0)), u <= l && n.set(0, 0, 1), o.crossVectors(i[0], n).normalize(), r[0].crossVectors(i[0], o), s[0].crossVectors(i[0], r[0]); for (let t = 1; t <= e; t++) { if (r[t] = r[t - 1].clone(), s[t] = s[t - 1].clone(), o.crossVectors(i[t - 1], i[t]), o.length() > Number.EPSILON) { o.normalize(); const e = Math.acos(g(i[t - 1].dot(i[t]), -1, 1)); r[t].applyMatrix4(a.makeRotationAxis(o, e)) } s[t].crossVectors(i[t], r[t]) } if (!0 === t) { let t = Math.acos(g(r[0].dot(r[e]), -1, 1)); t /= e, i[0].dot(o.crossVectors(r[0], r[e])) > 0 && (t = -t); for (let n = 1; n <= e; n++)r[n].applyMatrix4(a.makeRotationAxis(i[n], t * n)), s[n].crossVectors(i[n], r[n]) } return { tangents: i, normals: r, binormals: s } } clone() { return (new this.constructor).copy(this) } copy(e) { return this.arcLengthDivisions = e.arcLengthDivisions, this } toJSON() { const e = { metadata: { version: 4.5, type: "Curve", generator: "Curve.toJSON" } }; return e.arcLengthDivisions = this.arcLengthDivisions, e.type = this.type, e } fromJSON(e) { return this.arcLengthDivisions = e.arcLengthDivisions, this } } class bs extends Cs { constructor(e = 0, t = 0, n = 1, i = 1, r = 0, s = 2 * Math.PI, o = !1, a = 0) { super(), this.type = "EllipseCurve", this.aX = e, this.aY = t, this.xRadius = n, this.yRadius = i, this.aStartAngle = r, this.aEndAngle = s, this.aClockwise = o, this.aRotation = a } getPoint(e, t) { const n = t || new b, i = 2 * Math.PI; let r = this.aEndAngle - this.aStartAngle; const s = Math.abs(r) < Number.EPSILON; for (; r < 0;)r += i; for (; r > i;)r -= i; r < Number.EPSILON && (r = s ? 0 : i), !0 !== this.aClockwise || s || (r === i ? r = -i : r -= i); const o = this.aStartAngle + e * r; let a = this.aX + this.xRadius * Math.cos(o), l = this.aY + this.yRadius * Math.sin(o); if (0 !== this.aRotation) { const e = Math.cos(this.aRotation), t = Math.sin(this.aRotation), n = a - this.aX, i = l - this.aY; a = n * e - i * t + this.aX, l = n * t + i * e + this.aY } return n.set(a, l) } copy(e) { return super.copy(e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this } toJSON() { const e = super.toJSON(); return e.aX = this.aX, e.aY = this.aY, e.xRadius = this.xRadius, e.yRadius = this.yRadius, e.aStartAngle = this.aStartAngle, e.aEndAngle = this.aEndAngle, e.aClockwise = this.aClockwise, e.aRotation = this.aRotation, e } fromJSON(e) { return super.fromJSON(e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this } } bs.prototype.isEllipseCurve = !0; class Ms extends bs { constructor(e, t, n, i, r, s) { super(e, t, n, n, i, r, s), this.type = "ArcCurve" } } function Is() { let e = 0, t = 0, n = 0, i = 0; function r(r, s, o, a) { e = r, t = o, n = -3 * r + 3 * s - 2 * o - a, i = 2 * r - 2 * s + o + a } return { initCatmullRom: function (e, t, n, i, s) { r(t, n, s * (n - e), s * (i - t)) }, initNonuniformCatmullRom: function (e, t, n, i, s, o, a) { let l = (t - e) / s - (n - e) / (s + o) + (n - t) / o, c = (n - t) / o - (i - t) / (o + a) + (i - n) / a; l *= o, c *= o, r(t, n, l, c) }, calc: function (r) { const s = r * r; return e + t * r + n * s + i * (s * r) } } } Ms.prototype.isArcCurve = !0; const Es = new O, Ts = new Is, Ps = new Is, Ss = new Is; class Bs extends Cs { constructor(e = [], t = !1, n = "centripetal", i = .5) { super(), this.type = "CatmullRomCurve3", this.points = e, this.closed = t, this.curveType = n, this.tension = i } getPoint(e, t = new O) { const n = t, i = this.points, r = i.length, s = (r - (this.closed ? 0 : 1)) * e; let o, a, l = Math.floor(s), c = s - l; this.closed ? l += l > 0 ? 0 : (Math.floor(Math.abs(l) / r) + 1) * r : 0 === c && l === r - 1 && (l = r - 2, c = 1), this.closed || l > 0 ? o = i[(l - 1) % r] : (Es.subVectors(i[0], i[1]).add(i[0]), o = Es); const A = i[l % r], u = i[(l + 1) % r]; if (this.closed || l + 2 < r ? a = i[(l + 2) % r] : (Es.subVectors(i[r - 1], i[r - 2]).add(i[r - 1]), a = Es), "centripetal" === this.curveType || "chordal" === this.curveType) { const e = "chordal" === this.curveType ? .5 : .25; let t = Math.pow(o.distanceToSquared(A), e), n = Math.pow(A.distanceToSquared(u), e), i = Math.pow(u.distanceToSquared(a), e); n < 1e-4 && (n = 1), t < 1e-4 && (t = n), i < 1e-4 && (i = n), Ts.initNonuniformCatmullRom(o.x, A.x, u.x, a.x, t, n, i), Ps.initNonuniformCatmullRom(o.y, A.y, u.y, a.y, t, n, i), Ss.initNonuniformCatmullRom(o.z, A.z, u.z, a.z, t, n, i) } else "catmullrom" === this.curveType && (Ts.initCatmullRom(o.x, A.x, u.x, a.x, this.tension), Ps.initCatmullRom(o.y, A.y, u.y, a.y, this.tension), Ss.initCatmullRom(o.z, A.z, u.z, a.z, this.tension)); return n.set(Ts.calc(c), Ps.calc(c), Ss.calc(c)), n } copy(e) { super.copy(e), this.points = []; for (let t = 0, n = e.points.length; t < n; t++) { const n = e.points[t]; this.points.push(n.clone()) } return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this } toJSON() { const e = super.toJSON(); e.points = []; for (let t = 0, n = this.points.length; t < n; t++) { const n = this.points[t]; e.points.push(n.toArray()) } return e.closed = this.closed, e.curveType = this.curveType, e.tension = this.tension, e } fromJSON(e) { super.fromJSON(e), this.points = []; for (let t = 0, n = e.points.length; t < n; t++) { const n = e.points[t]; this.points.push((new O).fromArray(n)) } return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this } } function Ds(e, t, n, i, r) { const s = .5 * (i - t), o = .5 * (r - n), a = e * e; return (2 * n - 2 * i + s + o) * (e * a) + (-3 * n + 3 * i - 2 * s - o) * a + s * e + n } function Rs(e, t, n, i) { return function (e, t) { const n = 1 - e; return n * n * t }(e, t) + function (e, t) { return 2 * (1 - e) * e * t }(e, n) + function (e, t) { return e * e * t }(e, i) } function Ls(e, t, n, i, r) { return function (e, t) { const n = 1 - e; return n * n * n * t }(e, t) + function (e, t) { const n = 1 - e; return 3 * n * n * e * t }(e, n) + function (e, t) { return 3 * (1 - e) * e * e * t }(e, i) + function (e, t) { return e * e * e * t }(e, r) } Bs.prototype.isCatmullRomCurve3 = !0; class Os extends Cs { constructor(e = new b, t = new b, n = new b, i = new b) { super(), this.type = "CubicBezierCurve", this.v0 = e, this.v1 = t, this.v2 = n, this.v3 = i } getPoint(e, t = new b) { const n = t, i = this.v0, r = this.v1, s = this.v2, o = this.v3; return n.set(Ls(e, i.x, r.x, s.x, o.x), Ls(e, i.y, r.y, s.y, o.y)), n } copy(e) { return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this } toJSON() { const e = super.toJSON(); return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e } fromJSON(e) { return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this } } Os.prototype.isCubicBezierCurve = !0; class Ns extends Cs { constructor(e = new O, t = new O, n = new O, i = new O) { super(), this.type = "CubicBezierCurve3", this.v0 = e, this.v1 = t, this.v2 = n, this.v3 = i } getPoint(e, t = new O) { const n = t, i = this.v0, r = this.v1, s = this.v2, o = this.v3; return n.set(Ls(e, i.x, r.x, s.x, o.x), Ls(e, i.y, r.y, s.y, o.y), Ls(e, i.z, r.z, s.z, o.z)), n } copy(e) { return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this } toJSON() { const e = super.toJSON(); return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e } fromJSON(e) { return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this } } Ns.prototype.isCubicBezierCurve3 = !0; class ks extends Cs { constructor(e = new b, t = new b) { super(), this.type = "LineCurve", this.v1 = e, this.v2 = t } getPoint(e, t = new b) { const n = t; return 1 === e ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(e).add(this.v1)), n } getPointAt(e, t) { return this.getPoint(e, t) } getTangent(e, t) { const n = t || new b; return n.copy(this.v2).sub(this.v1).normalize(), n } copy(e) { return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this } toJSON() { const e = super.toJSON(); return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e } fromJSON(e) { return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this } } ks.prototype.isLineCurve = !0; class Hs extends Cs { constructor(e = new b, t = new b, n = new b) { super(), this.type = "QuadraticBezierCurve", this.v0 = e, this.v1 = t, this.v2 = n } getPoint(e, t = new b) { const n = t, i = this.v0, r = this.v1, s = this.v2; return n.set(Rs(e, i.x, r.x, s.x), Rs(e, i.y, r.y, s.y)), n } copy(e) { return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this } toJSON() { const e = super.toJSON(); return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e } fromJSON(e) { return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this } } Hs.prototype.isQuadraticBezierCurve = !0; class zs extends Cs { constructor(e = new O, t = new O, n = new O) { super(), this.type = "QuadraticBezierCurve3", this.v0 = e, this.v1 = t, this.v2 = n } getPoint(e, t = new O) { const n = t, i = this.v0, r = this.v1, s = this.v2; return n.set(Rs(e, i.x, r.x, s.x), Rs(e, i.y, r.y, s.y), Rs(e, i.z, r.z, s.z)), n } copy(e) { return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this } toJSON() { const e = super.toJSON(); return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e } fromJSON(e) { return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this } } zs.prototype.isQuadraticBezierCurve3 = !0; class Fs extends Cs { constructor(e = []) { super(), this.type = "SplineCurve", this.points = e } getPoint(e, t = new b) { const n = t, i = this.points, r = (i.length - 1) * e, s = Math.floor(r), o = r - s, a = i[0 === s ? s : s - 1], l = i[s], c = i[s > i.length - 2 ? i.length - 1 : s + 1], A = i[s > i.length - 3 ? i.length - 1 : s + 2]; return n.set(Ds(o, a.x, l.x, c.x, A.x), Ds(o, a.y, l.y, c.y, A.y)), n } copy(e) { super.copy(e), this.points = []; for (let t = 0, n = e.points.length; t < n; t++) { const n = e.points[t]; this.points.push(n.clone()) } return this } toJSON() { const e = super.toJSON(); e.points = []; for (let t = 0, n = this.points.length; t < n; t++) { const n = this.points[t]; e.points.push(n.toArray()) } return e } fromJSON(e) { super.fromJSON(e), this.points = []; for (let t = 0, n = e.points.length; t < n; t++) { const n = e.points[t]; this.points.push((new b).fromArray(n)) } return this } } Fs.prototype.isSplineCurve = !0; var Qs = Object.freeze({ __proto__: null, ArcCurve: Ms, CatmullRomCurve3: Bs, CubicBezierCurve: Os, CubicBezierCurve3: Ns, EllipseCurve: bs, LineCurve: ks, LineCurve3: class extends Cs { constructor(e = new O, t = new O) { super(), this.type = "LineCurve3", this.isLineCurve3 = !0, this.v1 = e, this.v2 = t } getPoint(e, t = new O) { const n = t; return 1 === e ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(e).add(this.v1)), n } getPointAt(e, t) { return this.getPoint(e, t) } copy(e) { return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this } toJSON() { const e = super.toJSON(); return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e } fromJSON(e) { return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this } }, QuadraticBezierCurve: Hs, QuadraticBezierCurve3: zs, SplineCurve: Fs }); const Gs = function (e, t, n = 2) { const i = t && t.length, r = i ? t[0] * n : e.length; let s = js(e, 0, r, n, !0); const o = []; if (!s || s.next === s.prev) return o; let a, l, c, A, u, h, d; if (i && (s = function (e, t, n, i) { const r = []; let s, o, a, l, c; for (s = 0, o = t.length; s < o; s++)a = t[s] * i, l = s < o - 1 ? t[s + 1] * i : e.length, c = js(e, a, l, i, !1), c === c.next && (c.steiner = !0), r.push($s(c)); for (r.sort(Ks), s = 0; s < r.length; s++)Zs(r[s], n), n = Us(n, n.next); return n }(e, t, s, n)), e.length > 80 * n) { a = c = e[0], l = A = e[1]; for (let t = n; t < r; t += n)u = e[t], h = e[t + 1], u < a && (a = u), h < l && (l = h), u > c && (c = u), h > A && (A = h); d = Math.max(c - a, A - l), d = 0 !== d ? 1 / d : 0 } return Vs(s, o, n, a, l, d), o }; function js(e, t, n, i, r) { let s, o; if (r === function (e, t, n, i) { let r = 0; for (let s = t, o = n - i; s < n; s += i)r += (e[o] - e[s]) * (e[s + 1] + e[o + 1]), o = s; return r }(e, t, n, i) > 0) for (s = t; s < n; s += i)o = co(s, e[s], e[s + 1], o); else for (s = n - i; s >= t; s -= i)o = co(s, e[s], e[s + 1], o); return o && io(o, o.next) && (Ao(o), o = o.next), o } function Us(e, t) { if (!e) return e; t || (t = e); let n, i = e; do { if (n = !1, i.steiner || !io(i, i.next) && 0 !== no(i.prev, i, i.next)) i = i.next; else { if (Ao(i), i = t = i.prev, i === i.next) break; n = !0 } } while (n || i !== t); return t } function Vs(e, t, n, i, r, s, o) { if (!e) return; !o && s && function (e, t, n, i) { let r = e; do { null === r.z && (r.z = _s(r.x, r.y, t, n, i)), r.prevZ = r.prev, r.nextZ = r.next, r = r.next } while (r !== e); r.prevZ.nextZ = null, r.prevZ = null, function (e) { let t, n, i, r, s, o, a, l, c = 1; do { for (n = e, e = null, s = null, o = 0; n;) { for (o++, i = n, a = 0, t = 0; t < c && (a++, i = i.nextZ, i); t++); for (l = c; a > 0 || l > 0 && i;)0 !== a && (0 === l || !i || n.z <= i.z) ? (r = n, n = n.nextZ, a--) : (r = i, i = i.nextZ, l--), s ? s.nextZ = r : e = r, r.prevZ = s, s = r; n = i } s.nextZ = null, c *= 2 } while (o > 1) }(r) }(e, i, r, s); let a, l, c = e; for (; e.prev !== e.next;)if (a = e.prev, l = e.next, s ? Ws(e, i, r, s) : Ys(e)) t.push(a.i / n), t.push(e.i / n), t.push(l.i / n), Ao(e), e = l.next, c = l.next; else if ((e = l) === c) { o ? 1 === o ? Vs(e = Xs(Us(e), t, n), t, n, i, r, s, 2) : 2 === o && Js(e, t, n, i, r, s) : Vs(Us(e), t, n, i, r, s, 1); break } } function Ys(e) { const t = e.prev, n = e, i = e.next; if (no(t, n, i) >= 0) return !1; let r = e.next.next; for (; r !== e.prev;) { if (eo(t.x, t.y, n.x, n.y, i.x, i.y, r.x, r.y) && no(r.prev, r, r.next) >= 0) return !1; r = r.next } return !0 } function Ws(e, t, n, i) { const r = e.prev, s = e, o = e.next; if (no(r, s, o) >= 0) return !1; const a = r.x < s.x ? r.x < o.x ? r.x : o.x : s.x < o.x ? s.x : o.x, l = r.y < s.y ? r.y < o.y ? r.y : o.y : s.y < o.y ? s.y : o.y, c = r.x > s.x ? r.x > o.x ? r.x : o.x : s.x > o.x ? s.x : o.x, A = r.y > s.y ? r.y > o.y ? r.y : o.y : s.y > o.y ? s.y : o.y, u = _s(a, l, t, n, i), h = _s(c, A, t, n, i); let d = e.prevZ, p = e.nextZ; for (; d && d.z >= u && p && p.z <= h;) { if (d !== e.prev && d !== e.next && eo(r.x, r.y, s.x, s.y, o.x, o.y, d.x, d.y) && no(d.prev, d, d.next) >= 0) return !1; if (d = d.prevZ, p !== e.prev && p !== e.next && eo(r.x, r.y, s.x, s.y, o.x, o.y, p.x, p.y) && no(p.prev, p, p.next) >= 0) return !1; p = p.nextZ } for (; d && d.z >= u;) { if (d !== e.prev && d !== e.next && eo(r.x, r.y, s.x, s.y, o.x, o.y, d.x, d.y) && no(d.prev, d, d.next) >= 0) return !1; d = d.prevZ } for (; p && p.z <= h;) { if (p !== e.prev && p !== e.next && eo(r.x, r.y, s.x, s.y, o.x, o.y, p.x, p.y) && no(p.prev, p, p.next) >= 0) return !1; p = p.nextZ } return !0 } function Xs(e, t, n) { let i = e; do { const r = i.prev, s = i.next.next; !io(r, s) && ro(r, i, i.next, s) && ao(r, s) && ao(s, r) && (t.push(r.i / n), t.push(i.i / n), t.push(s.i / n), Ao(i), Ao(i.next), i = e = s), i = i.next } while (i !== e); return Us(i) } function Js(e, t, n, i, r, s) { let o = e; do { let e = o.next.next; for (; e !== o.prev;) { if (o.i !== e.i && to(o, e)) { let a = lo(o, e); return o = Us(o, o.next), a = Us(a, a.next), Vs(o, t, n, i, r, s), void Vs(a, t, n, i, r, s) } e = e.next } o = o.next } while (o !== e) } function Ks(e, t) { return e.x - t.x } function Zs(e, t) { if (t = function (e, t) { let n = t; const i = e.x, r = e.y; let s, o = -1 / 0; do { if (r <= n.y && r >= n.next.y && n.next.y !== n.y) { const e = n.x + (r - n.y) * (n.next.x - n.x) / (n.next.y - n.y); if (e <= i && e > o) { if (o = e, e === i) { if (r === n.y) return n; if (r === n.next.y) return n.next } s = n.x < n.next.x ? n : n.next } } n = n.next } while (n !== t); if (!s) return null; if (i === o) return s; const a = s, l = s.x, c = s.y; let A, u = 1 / 0; n = s; do { i >= n.x && n.x >= l && i !== n.x && eo(r < c ? i : o, r, l, c, r < c ? o : i, r, n.x, n.y) && (A = Math.abs(r - n.y) / (i - n.x), ao(n, e) && (A < u || A === u && (n.x > s.x || n.x === s.x && qs(s, n))) && (s = n, u = A)), n = n.next } while (n !== a); return s }(e, t)) { const n = lo(t, e); Us(t, t.next), Us(n, n.next) } } function qs(e, t) { return no(e.prev, e, t.prev) < 0 && no(t.next, e, e.next) < 0 } function _s(e, t, n, i, r) { return (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = 32767 * (e - n) * r) | e << 8)) | e << 4)) | e << 2)) | e << 1)) | (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = 32767 * (t - i) * r) | t << 8)) | t << 4)) | t << 2)) | t << 1)) << 1 } function $s(e) { let t = e, n = e; do { (t.x < n.x || t.x === n.x && t.y < n.y) && (n = t), t = t.next } while (t !== e); return n } function eo(e, t, n, i, r, s, o, a) { return (r - o) * (t - a) - (e - o) * (s - a) >= 0 && (e - o) * (i - a) - (n - o) * (t - a) >= 0 && (n - o) * (s - a) - (r - o) * (i - a) >= 0 } function to(e, t) { return e.next.i !== t.i && e.prev.i !== t.i && !function (e, t) { let n = e; do { if (n.i !== e.i && n.next.i !== e.i && n.i !== t.i && n.next.i !== t.i && ro(n, n.next, e, t)) return !0; n = n.next } while (n !== e); return !1 }(e, t) && (ao(e, t) && ao(t, e) && function (e, t) { let n = e, i = !1; const r = (e.x + t.x) / 2, s = (e.y + t.y) / 2; do { n.y > s != n.next.y > s && n.next.y !== n.y && r < (n.next.x - n.x) * (s - n.y) / (n.next.y - n.y) + n.x && (i = !i), n = n.next } while (n !== e); return i }(e, t) && (no(e.prev, e, t.prev) || no(e, t.prev, t)) || io(e, t) && no(e.prev, e, e.next) > 0 && no(t.prev, t, t.next) > 0) } function no(e, t, n) { return (t.y - e.y) * (n.x - t.x) - (t.x - e.x) * (n.y - t.y) } function io(e, t) { return e.x === t.x && e.y === t.y } function ro(e, t, n, i) { const r = oo(no(e, t, n)), s = oo(no(e, t, i)), o = oo(no(n, i, e)), a = oo(no(n, i, t)); return r !== s && o !== a || (!(0 !== r || !so(e, n, t)) || (!(0 !== s || !so(e, i, t)) || (!(0 !== o || !so(n, e, i)) || !(0 !== a || !so(n, t, i))))) } function so(e, t, n) { return t.x <= Math.max(e.x, n.x) && t.x >= Math.min(e.x, n.x) && t.y <= Math.max(e.y, n.y) && t.y >= Math.min(e.y, n.y) } function oo(e) { return e > 0 ? 1 : e < 0 ? -1 : 0 } function ao(e, t) { return no(e.prev, e, e.next) < 0 ? no(e, t, e.next) >= 0 && no(e, e.prev, t) >= 0 : no(e, t, e.prev) < 0 || no(e, e.next, t) < 0 } function lo(e, t) { const n = new uo(e.i, e.x, e.y), i = new uo(t.i, t.x, t.y), r = e.next, s = t.prev; return e.next = t, t.prev = e, n.next = r, r.prev = n, i.next = n, n.prev = i, s.next = i, i.prev = s, i } function co(e, t, n, i) { const r = new uo(e, t, n); return i ? (r.next = i.next, r.prev = i, i.next.prev = r, i.next = r) : (r.prev = r, r.next = r), r } function Ao(e) { e.next.prev = e.prev, e.prev.next = e.next, e.prevZ && (e.prevZ.nextZ = e.nextZ), e.nextZ && (e.nextZ.prevZ = e.prevZ) } function uo(e, t, n) { this.i = e, this.x = t, this.y = n, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1 } class ho { static area(e) { const t = e.length; let n = 0; for (let i = t - 1, r = 0; r < t; i = r++)n += e[i].x * e[r].y - e[r].x * e[i].y; return .5 * n } static isClockWise(e) { return ho.area(e) < 0 } static triangulateShape(e, t) { const n = [], i = [], r = []; po(e), fo(n, e); let s = e.length; t.forEach(po); for (let e = 0; e < t.length; e++)i.push(s), s += t[e].length, fo(n, t[e]); const o = Gs(n, i); for (let e = 0; e < o.length; e += 3)r.push(o.slice(e, e + 3)); return r } } function po(e) { const t = e.length; t > 2 && e[t - 1].equals(e[0]) && e.pop() } function fo(e, t) { for (let n = 0; n < t.length; n++)e.push(t[n].x), e.push(t[n].y) } class go extends vt { constructor(e, t) { super(), this.type = "ExtrudeGeometry", this.parameters = { shapes: e, options: t }, e = Array.isArray(e) ? e : [e]; const n = this, i = [], r = []; for (let t = 0, n = e.length; t < n; t++) { s(e[t]) } function s(e) { const s = [], o = void 0 !== t.curveSegments ? t.curveSegments : 12, a = void 0 !== t.steps ? t.steps : 1; let l = void 0 !== t.depth ? t.depth : 100, c = void 0 === t.bevelEnabled || t.bevelEnabled, A = void 0 !== t.bevelThickness ? t.bevelThickness : 6, u = void 0 !== t.bevelSize ? t.bevelSize : A - 2, h = void 0 !== t.bevelOffset ? t.bevelOffset : 0, d = void 0 !== t.bevelSegments ? t.bevelSegments : 3; const p = t.extrudePath, f = void 0 !== t.UVGenerator ? t.UVGenerator : mo; void 0 !== t.amount && (console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth."), l = t.amount); let g, m, v, y, w, x = !1; p && (g = p.getSpacedPoints(a), x = !0, c = !1, m = p.computeFrenetFrames(a, !1), v = new O, y = new O, w = new O), c || (d = 0, A = 0, u = 0, h = 0); const C = e.extractPoints(o); let M = C.shape; const I = C.holes; if (!ho.isClockWise(M)) { M = M.reverse(); for (let e = 0, t = I.length; e < t; e++) { const t = I[e]; ho.isClockWise(t) && (I[e] = t.reverse()) } } const E = ho.triangulateShape(M, I), T = M; for (let e = 0, t = I.length; e < t; e++) { const t = I[e]; M = M.concat(t) } function P(e, t, n) { return t || console.error("THREE.ExtrudeGeometry: vec does not exist"), t.clone().multiplyScalar(n).add(e) } const S = M.length, B = E.length; function D(e, t, n) { let i, r, s; const o = e.x - t.x, a = e.y - t.y, l = n.x - e.x, c = n.y - e.y, A = o * o + a * a, u = o * c - a * l; if (Math.abs(u) > Number.EPSILON) { const u = Math.sqrt(A), h = Math.sqrt(l * l + c * c), d = t.x - a / u, p = t.y + o / u, f = ((n.x - c / h - d) * c - (n.y + l / h - p) * l) / (o * c - a * l); i = d + o * f - e.x, r = p + a * f - e.y; const g = i * i + r * r; if (g <= 2) return new b(i, r); s = Math.sqrt(g / 2) } else { let e = !1; o > Number.EPSILON ? l > Number.EPSILON && (e = !0) : o < -Number.EPSILON ? l < -Number.EPSILON && (e = !0) : Math.sign(a) === Math.sign(c) && (e = !0), e ? (i = -a, r = o, s = Math.sqrt(A)) : (i = o, r = a, s = Math.sqrt(A / 2)) } return new b(i / s, r / s) } const R = []; for (let e = 0, t = T.length, n = t - 1, i = e + 1; e < t; e++, n++, i++)n === t && (n = 0), i === t && (i = 0), R[e] = D(T[e], T[n], T[i]); const L = []; let N, k = R.concat(); for (let e = 0, t = I.length; e < t; e++) { const t = I[e]; N = []; for (let e = 0, n = t.length, i = n - 1, r = e + 1; e < n; e++, i++, r++)i === n && (i = 0), r === n && (r = 0), N[e] = D(t[e], t[i], t[r]); L.push(N), k = k.concat(N) } for (let e = 0; e < d; e++) { const t = e / d, n = A * Math.cos(t * Math.PI / 2), i = u * Math.sin(t * Math.PI / 2) + h; for (let e = 0, t = T.length; e < t; e++) { const t = P(T[e], R[e], i); F(t.x, t.y, -n) } for (let e = 0, t = I.length; e < t; e++) { const t = I[e]; N = L[e]; for (let e = 0, r = t.length; e < r; e++) { const r = P(t[e], N[e], i); F(r.x, r.y, -n) } } } const H = u + h; for (let e = 0; e < S; e++) { const t = c ? P(M[e], k[e], H) : M[e]; x ? (y.copy(m.normals[0]).multiplyScalar(t.x), v.copy(m.binormals[0]).multiplyScalar(t.y), w.copy(g[0]).add(y).add(v), F(w.x, w.y, w.z)) : F(t.x, t.y, 0) } for (let e = 1; e <= a; e++)for (let t = 0; t < S; t++) { const n = c ? P(M[t], k[t], H) : M[t]; x ? (y.copy(m.normals[e]).multiplyScalar(n.x), v.copy(m.binormals[e]).multiplyScalar(n.y), w.copy(g[e]).add(y).add(v), F(w.x, w.y, w.z)) : F(n.x, n.y, l / a * e) } for (let e = d - 1; e >= 0; e--) { const t = e / d, n = A * Math.cos(t * Math.PI / 2), i = u * Math.sin(t * Math.PI / 2) + h; for (let e = 0, t = T.length; e < t; e++) { const t = P(T[e], R[e], i); F(t.x, t.y, l + n) } for (let e = 0, t = I.length; e < t; e++) { const t = I[e]; N = L[e]; for (let e = 0, r = t.length; e < r; e++) { const r = P(t[e], N[e], i); x ? F(r.x, r.y + g[a - 1].y, g[a - 1].x + n) : F(r.x, r.y, l + n) } } } function z(e, t) { let n = e.length; for (; --n >= 0;) { const i = n; let r = n - 1; r < 0 && (r = e.length - 1); for (let e = 0, n = a + 2 * d; e < n; e++) { const n = S * e, s = S * (e + 1); G(t + i + n, t + r + n, t + r + s, t + i + s) } } } function F(e, t, n) { s.push(e), s.push(t), s.push(n) } function Q(e, t, r) { j(e), j(t), j(r); const s = i.length / 3, o = f.generateTopUV(n, i, s - 3, s - 2, s - 1); U(o[0]), U(o[1]), U(o[2]) } function G(e, t, r, s) { j(e), j(t), j(s), j(t), j(r), j(s); const o = i.length / 3, a = f.generateSideWallUV(n, i, o - 6, o - 3, o - 2, o - 1); U(a[0]), U(a[1]), U(a[3]), U(a[1]), U(a[2]), U(a[3]) } function j(e) { i.push(s[3 * e + 0]), i.push(s[3 * e + 1]), i.push(s[3 * e + 2]) } function U(e) { r.push(e.x), r.push(e.y) } !function () { const e = i.length / 3; if (c) { let e = 0, t = S * e; for (let e = 0; e < B; e++) { const n = E[e]; Q(n[2] + t, n[1] + t, n[0] + t) } e = a + 2 * d, t = S * e; for (let e = 0; e < B; e++) { const n = E[e]; Q(n[0] + t, n[1] + t, n[2] + t) } } else { for (let e = 0; e < B; e++) { const t = E[e]; Q(t[2], t[1], t[0]) } for (let e = 0; e < B; e++) { const t = E[e]; Q(t[0] + S * a, t[1] + S * a, t[2] + S * a) } } n.addGroup(e, i.length / 3 - e, 0) }(), function () { const e = i.length / 3; let t = 0; z(T, t), t += T.length; for (let e = 0, n = I.length; e < n; e++) { const n = I[e]; z(n, t), t += n.length } n.addGroup(e, i.length / 3 - e, 1) }() } this.setAttribute("position", new ct(i, 3)), this.setAttribute("uv", new ct(r, 2)), this.computeVertexNormals() } toJSON() { const e = super.toJSON(); return function (e, t, n) { if (n.shapes = [], Array.isArray(e)) for (let t = 0, i = e.length; t < i; t++) { const i = e[t]; n.shapes.push(i.uuid) } else n.shapes.push(e.uuid); void 0 !== t.extrudePath && (n.options.extrudePath = t.extrudePath.toJSON()); return n }(this.parameters.shapes, this.parameters.options, e) } static fromJSON(e, t) { const n = []; for (let i = 0, r = e.shapes.length; i < r; i++) { const r = t[e.shapes[i]]; n.push(r) } const i = e.options.extrudePath; return void 0 !== i && (e.options.extrudePath = (new Qs[i.type]).fromJSON(i)), new go(n, e.options) } } const mo = { generateTopUV: function (e, t, n, i, r) { const s = t[3 * n], o = t[3 * n + 1], a = t[3 * i], l = t[3 * i + 1], c = t[3 * r], A = t[3 * r + 1]; return [new b(s, o), new b(a, l), new b(c, A)] }, generateSideWallUV: function (e, t, n, i, r, s) { const o = t[3 * n], a = t[3 * n + 1], l = t[3 * n + 2], c = t[3 * i], A = t[3 * i + 1], u = t[3 * i + 2], h = t[3 * r], d = t[3 * r + 1], p = t[3 * r + 2], f = t[3 * s], g = t[3 * s + 1], m = t[3 * s + 2]; return Math.abs(a - A) < Math.abs(o - c) ? [new b(o, 1 - l), new b(c, 1 - u), new b(h, 1 - p), new b(f, 1 - m)] : [new b(a, 1 - l), new b(A, 1 - u), new b(d, 1 - p), new b(g, 1 - m)] } }; class vo extends vt { constructor(e, t = 12) { super(), this.type = "ShapeGeometry", this.parameters = { shapes: e, curveSegments: t }; const n = [], i = [], r = [], s = []; let o = 0, a = 0; if (!1 === Array.isArray(e)) l(e); else for (let t = 0; t < e.length; t++)l(e[t]), this.addGroup(o, a, t), o += a, a = 0; function l(e) { const o = i.length / 3, l = e.extractPoints(t); let c = l.shape; const A = l.holes; !1 === ho.isClockWise(c) && (c = c.reverse()); for (let e = 0, t = A.length; e < t; e++) { const t = A[e]; !0 === ho.isClockWise(t) && (A[e] = t.reverse()) } const u = ho.triangulateShape(c, A); for (let e = 0, t = A.length; e < t; e++) { const t = A[e]; c = c.concat(t) } for (let e = 0, t = c.length; e < t; e++) { const t = c[e]; i.push(t.x, t.y, 0), r.push(0, 0, 1), s.push(t.x, t.y) } for (let e = 0, t = u.length; e < t; e++) { const t = u[e], i = t[0] + o, r = t[1] + o, s = t[2] + o; n.push(i, r, s), a += 3 } } this.setIndex(n), this.setAttribute("position", new ct(i, 3)), this.setAttribute("normal", new ct(r, 3)), this.setAttribute("uv", new ct(s, 2)) } toJSON() { const e = super.toJSON(); return function (e, t) { if (t.shapes = [], Array.isArray(e)) for (let n = 0, i = e.length; n < i; n++) { const i = e[n]; t.shapes.push(i.uuid) } else t.shapes.push(e.uuid); return t }(this.parameters.shapes, e) } static fromJSON(e, t) { const n = []; for (let i = 0, r = e.shapes.length; i < r; i++) { const r = t[e.shapes[i]]; n.push(r) } return new vo(n, e.curveSegments) } } class yo extends vt { constructor(e = 1, t = 8, n = 6, i = 0, r = 2 * Math.PI, s = 0, o = Math.PI) { super(), this.type = "SphereGeometry", this.parameters = { radius: e, widthSegments: t, heightSegments: n, phiStart: i, phiLength: r, thetaStart: s, thetaLength: o }, t = Math.max(3, Math.floor(t)), n = Math.max(2, Math.floor(n)); const a = Math.min(s + o, Math.PI); let l = 0; const c = [], A = new O, u = new O, h = [], d = [], p = [], f = []; for (let h = 0; h <= n; h++) { const g = [], m = h / n; let v = 0; 0 == h && 0 == s ? v = .5 / t : h == n && a == Math.PI && (v = -.5 / t); for (let n = 0; n <= t; n++) { const a = n / t; A.x = -e * Math.cos(i + a * r) * Math.sin(s + m * o), A.y = e * Math.cos(s + m * o), A.z = e * Math.sin(i + a * r) * Math.sin(s + m * o), d.push(A.x, A.y, A.z), u.copy(A).normalize(), p.push(u.x, u.y, u.z), f.push(a + v, 1 - m), g.push(l++) } c.push(g) } for (let e = 0; e < n; e++)for (let i = 0; i < t; i++) { const t = c[e][i + 1], r = c[e][i], o = c[e + 1][i], l = c[e + 1][i + 1]; (0 !== e || s > 0) && h.push(t, r, l), (e !== n - 1 || a < Math.PI) && h.push(r, o, l) } this.setIndex(h), this.setAttribute("position", new ct(d, 3)), this.setAttribute("normal", new ct(p, 3)), this.setAttribute("uv", new ct(f, 2)) } static fromJSON(e) { return new yo(e.radius, e.widthSegments, e.heightSegments, e.phiStart, e.phiLength, e.thetaStart, e.thetaLength) } } class wo extends Ke { constructor(e) { super(), this.type = "ShadowMaterial", this.color = new nt(0), this.transparent = !0, this.setValues(e) } copy(e) { return super.copy(e), this.color.copy(e.color), this } } wo.prototype.isShadowMaterial = !0; class xo extends jt { constructor(e) { super(e), this.type = "RawShaderMaterial" } } xo.prototype.isRawShaderMaterial = !0; class Co extends Ke { constructor(e) { super(), this.defines = { STANDARD: "" }, this.type = "MeshStandardMaterial", this.color = new nt(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new nt(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new b(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapIntensity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.morphTargets = !1, this.morphNormals = !1, this.flatShading = !1, this.vertexTangents = !1, this.setValues(e) } copy(e) { return super.copy(e), this.defines = { STANDARD: "" }, this.color.copy(e.color), this.roughness = e.roughness, this.metalness = e.metalness, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.roughnessMap = e.roughnessMap, this.metalnessMap = e.metalnessMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapIntensity = e.envMapIntensity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this.flatShading = e.flatShading, this.vertexTangents = e.vertexTangents, this } } Co.prototype.isMeshStandardMaterial = !0; class bo extends Co { constructor(e) { super(), this.defines = { STANDARD: "", PHYSICAL: "" }, this.type = "MeshPhysicalMaterial", this.clearcoat = 0, this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new b(1, 1), this.clearcoatNormalMap = null, this.reflectivity = .5, Object.defineProperty(this, "ior", { get: function () { return (1 + .4 * this.reflectivity) / (1 - .4 * this.reflectivity) }, set: function (e) { this.reflectivity = g(2.5 * (e - 1) / (e + 1), 0, 1) } }), this.sheen = null, this.transmission = 0, this.transmissionMap = null, this.thickness = .01, this.thicknessMap = null, this.attenuationDistance = 0, this.attenuationColor = new nt(1, 1, 1), this.setValues(e) } copy(e) { return super.copy(e), this.defines = { STANDARD: "", PHYSICAL: "" }, this.clearcoat = e.clearcoat, this.clearcoatMap = e.clearcoatMap, this.clearcoatRoughness = e.clearcoatRoughness, this.clearcoatRoughnessMap = e.clearcoatRoughnessMap, this.clearcoatNormalMap = e.clearcoatNormalMap, this.clearcoatNormalScale.copy(e.clearcoatNormalScale), this.reflectivity = e.reflectivity, e.sheen ? this.sheen = (this.sheen || new nt).copy(e.sheen) : this.sheen = null, this.transmission = e.transmission, this.transmissionMap = e.transmissionMap, this.thickness = e.thickness, this.thicknessMap = e.thicknessMap, this.attenuationDistance = e.attenuationDistance, this.attenuationColor.copy(e.attenuationColor), this } } bo.prototype.isMeshPhysicalMaterial = !0; class Mo extends Ke { constructor(e) { super(), this.type = "MeshPhongMaterial", this.color = new nt(16777215), this.specular = new nt(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new nt(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new b(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.morphTargets = !1, this.morphNormals = !1, this.flatShading = !1, this.setValues(e) } copy(e) { return super.copy(e), this.color.copy(e.color), this.specular.copy(e.specular), this.shininess = e.shininess, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this.flatShading = e.flatShading, this } } Mo.prototype.isMeshPhongMaterial = !0; class Io extends Ke { constructor(e) { super(), this.defines = { TOON: "" }, this.type = "MeshToonMaterial", this.color = new nt(16777215), this.map = null, this.gradientMap = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new nt(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new b(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.morphTargets = !1, this.morphNormals = !1, this.setValues(e) } copy(e) { return super.copy(e), this.color.copy(e.color), this.map = e.map, this.gradientMap = e.gradientMap, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.alphaMap = e.alphaMap, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this } } Io.prototype.isMeshToonMaterial = !0; class Eo extends Ke { constructor(e) { super(), this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new b(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.morphTargets = !1, this.morphNormals = !1, this.flatShading = !1, this.setValues(e) } copy(e) { return super.copy(e), this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this.flatShading = e.flatShading, this } } Eo.prototype.isMeshNormalMaterial = !0; class To extends Ke { constructor(e) { super(), this.type = "MeshLambertMaterial", this.color = new nt(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new nt(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.morphTargets = !1, this.morphNormals = !1, this.setValues(e) } copy(e) { return super.copy(e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this } } To.prototype.isMeshLambertMaterial = !0; class Po extends Ke { constructor(e) { super(), this.defines = { MATCAP: "" }, this.type = "MeshMatcapMaterial", this.color = new nt(16777215), this.matcap = null, this.map = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new b(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.morphTargets = !1, this.morphNormals = !1, this.flatShading = !1, this.setValues(e) } copy(e) { return super.copy(e), this.defines = { MATCAP: "" }, this.color.copy(e.color), this.matcap = e.matcap, this.map = e.map, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.alphaMap = e.alphaMap, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this.flatShading = e.flatShading, this } } Po.prototype.isMeshMatcapMaterial = !0; class So extends ts { constructor(e) { super(), this.type = "LineDashedMaterial", this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.setValues(e) } copy(e) { return super.copy(e), this.scale = e.scale, this.dashSize = e.dashSize, this.gapSize = e.gapSize, this } } So.prototype.isLineDashedMaterial = !0; const Bo = { arraySlice: function (e, t, n) { return Bo.isTypedArray(e) ? new e.constructor(e.subarray(t, void 0 !== n ? n : e.length)) : e.slice(t, n) }, convertArray: function (e, t, n) { return !e || !n && e.constructor === t ? e : "number" == typeof t.BYTES_PER_ELEMENT ? new t(e) : Array.prototype.slice.call(e) }, isTypedArray: function (e) { return ArrayBuffer.isView(e) && !(e instanceof DataView) }, getKeyframeOrder: function (e) { const t = e.length, n = new Array(t); for (let e = 0; e !== t; ++e)n[e] = e; return n.sort((function (t, n) { return e[t] - e[n] })), n }, sortedArray: function (e, t, n) { const i = e.length, r = new e.constructor(i); for (let s = 0, o = 0; o !== i; ++s) { const i = n[s] * t; for (let n = 0; n !== t; ++n)r[o++] = e[i + n] } return r }, flattenJSON: function (e, t, n, i) { let r = 1, s = e[0]; for (; void 0 !== s && void 0 === s[i];)s = e[r++]; if (void 0 === s) return; let o = s[i]; if (void 0 !== o) if (Array.isArray(o)) do { o = s[i], void 0 !== o && (t.push(s.time), n.push.apply(n, o)), s = e[r++] } while (void 0 !== s); else if (void 0 !== o.toArray) do { o = s[i], void 0 !== o && (t.push(s.time), o.toArray(n, n.length)), s = e[r++] } while (void 0 !== s); else do { o = s[i], void 0 !== o && (t.push(s.time), n.push(o)), s = e[r++] } while (void 0 !== s) }, subclip: function (e, t, n, i, r = 30) { const s = e.clone(); s.name = t; const o = []; for (let e = 0; e < s.tracks.length; ++e) { const t = s.tracks[e], a = t.getValueSize(), l = [], c = []; for (let e = 0; e < t.times.length; ++e) { const s = t.times[e] * r; if (!(s < n || s >= i)) { l.push(t.times[e]); for (let n = 0; n < a; ++n)c.push(t.values[e * a + n]) } } 0 !== l.length && (t.times = Bo.convertArray(l, t.times.constructor), t.values = Bo.convertArray(c, t.values.constructor), o.push(t)) } s.tracks = o; let a = 1 / 0; for (let e = 0; e < s.tracks.length; ++e)a > s.tracks[e].times[0] && (a = s.tracks[e].times[0]); for (let e = 0; e < s.tracks.length; ++e)s.tracks[e].shift(-1 * a); return s.resetDuration(), s }, makeClipAdditive: function (e, t = 0, n = e, i = 30) { i <= 0 && (i = 30); const r = n.tracks.length, s = t / i; for (let t = 0; t < r; ++t) { const i = n.tracks[t], r = i.ValueTypeName; if ("bool" === r || "string" === r) continue; const o = e.tracks.find((function (e) { return e.name === i.name && e.ValueTypeName === r })); if (void 0 === o) continue; let a = 0; const l = i.getValueSize(); i.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (a = l / 3); let c = 0; const A = o.getValueSize(); o.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (c = A / 3); const u = i.times.length - 1; let h; if (s <= i.times[0]) { const e = a, t = l - a; h = Bo.arraySlice(i.values, e, t) } else if (s >= i.times[u]) { const e = u * l + a, t = e + l - a; h = Bo.arraySlice(i.values, e, t) } else { const e = i.createInterpolant(), t = a, n = l - a; e.evaluate(s), h = Bo.arraySlice(e.resultBuffer, t, n) } if ("quaternion" === r) { (new L).fromArray(h).normalize().conjugate().toArray(h) } const d = o.times.length; for (let e = 0; e < d; ++e) { const t = e * A + c; if ("quaternion" === r) L.multiplyQuaternionsFlat(o.values, t, h, 0, o.values, t); else { const e = A - 2 * c; for (let n = 0; n < e; ++n)o.values[t + n] -= h[n] } } } return e.blendMode = 2501, e } }; class Do { constructor(e, t, n, i) { this.parameterPositions = e, this._cachedIndex = 0, this.resultBuffer = void 0 !== i ? i : new t.constructor(n), this.sampleValues = t, this.valueSize = n, this.settings = null, this.DefaultSettings_ = {} } evaluate(e) { const t = this.parameterPositions; let n = this._cachedIndex, i = t[n], r = t[n - 1]; e: { t: { let s; n: { i: if (!(e < i)) { for (let s = n + 2; ;) { if (void 0 === i) { if (e < r) break i; return n = t.length, this._cachedIndex = n, this.afterEnd_(n - 1, e, r) } if (n === s) break; if (r = i, i = t[++n], e < i) break t } s = t.length; break n } if (e >= r) break e; { const o = t[1]; e < o && (n = 2, r = o); for (let s = n - 2; ;) { if (void 0 === r) return this._cachedIndex = 0, this.beforeStart_(0, e, i); if (n === s) break; if (i = r, r = t[--n - 1], e >= r) break t } s = n, n = 0 } } for (; n < s;) { const i = n + s >>> 1; e < t[i] ? s = i : n = i + 1 } if (i = t[n], r = t[n - 1], void 0 === r) return this._cachedIndex = 0, this.beforeStart_(0, e, i); if (void 0 === i) return n = t.length, this._cachedIndex = n, this.afterEnd_(n - 1, r, e) } this._cachedIndex = n, this.intervalChanged_(n, r, i) } return this.interpolate_(n, r, e, i) } getSettings_() { return this.settings || this.DefaultSettings_ } copySampleValue_(e) { const t = this.resultBuffer, n = this.sampleValues, i = this.valueSize, r = e * i; for (let e = 0; e !== i; ++e)t[e] = n[r + e]; return t } interpolate_() { throw new Error("call to abstract method") } intervalChanged_() { } } Do.prototype.beforeStart_ = Do.prototype.copySampleValue_, Do.prototype.afterEnd_ = Do.prototype.copySampleValue_; class Ro extends Do { constructor(e, t, n, i) { super(e, t, n, i), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0, this.DefaultSettings_ = { endingStart: 2400, endingEnd: 2400 } } intervalChanged_(e, t, n) { const i = this.parameterPositions; let r = e - 2, s = e + 1, o = i[r], a = i[s]; if (void 0 === o) switch (this.getSettings_().endingStart) { case 2401: r = e, o = 2 * t - n; break; case 2402: r = i.length - 2, o = t + i[r] - i[r + 1]; break; default: r = e, o = n }if (void 0 === a) switch (this.getSettings_().endingEnd) { case 2401: s = e, a = 2 * n - t; break; case 2402: s = 1, a = n + i[1] - i[0]; break; default: s = e - 1, a = t }const l = .5 * (n - t), c = this.valueSize; this._weightPrev = l / (t - o), this._weightNext = l / (a - n), this._offsetPrev = r * c, this._offsetNext = s * c } interpolate_(e, t, n, i) { const r = this.resultBuffer, s = this.sampleValues, o = this.valueSize, a = e * o, l = a - o, c = this._offsetPrev, A = this._offsetNext, u = this._weightPrev, h = this._weightNext, d = (n - t) / (i - t), p = d * d, f = p * d, g = -u * f + 2 * u * p - u * d, m = (1 + u) * f + (-1.5 - 2 * u) * p + (-.5 + u) * d + 1, v = (-1 - h) * f + (1.5 + h) * p + .5 * d, y = h * f - h * p; for (let e = 0; e !== o; ++e)r[e] = g * s[c + e] + m * s[l + e] + v * s[a + e] + y * s[A + e]; return r } } class Lo extends Do { constructor(e, t, n, i) { super(e, t, n, i) } interpolate_(e, t, n, i) { const r = this.resultBuffer, s = this.sampleValues, o = this.valueSize, a = e * o, l = a - o, c = (n - t) / (i - t), A = 1 - c; for (let e = 0; e !== o; ++e)r[e] = s[l + e] * A + s[a + e] * c; return r } } class Oo extends Do { constructor(e, t, n, i) { super(e, t, n, i) } interpolate_(e) { return this.copySampleValue_(e - 1) } } class No { constructor(e, t, n, i) { if (void 0 === e) throw new Error("THREE.KeyframeTrack: track name is undefined"); if (void 0 === t || 0 === t.length) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + e); this.name = e, this.times = Bo.convertArray(t, this.TimeBufferType), this.values = Bo.convertArray(n, this.ValueBufferType), this.setInterpolation(i || this.DefaultInterpolation) } static toJSON(e) { const t = e.constructor; let n; if (t.toJSON !== this.toJSON) n = t.toJSON(e); else { n = { name: e.name, times: Bo.convertArray(e.times, Array), values: Bo.convertArray(e.values, Array) }; const t = e.getInterpolation(); t !== e.DefaultInterpolation && (n.interpolation = t) } return n.type = e.ValueTypeName, n } InterpolantFactoryMethodDiscrete(e) { return new Oo(this.times, this.values, this.getValueSize(), e) } InterpolantFactoryMethodLinear(e) { return new Lo(this.times, this.values, this.getValueSize(), e) } InterpolantFactoryMethodSmooth(e) { return new Ro(this.times, this.values, this.getValueSize(), e) } setInterpolation(e) { let t; switch (e) { case 2300: t = this.InterpolantFactoryMethodDiscrete; break; case 2301: t = this.InterpolantFactoryMethodLinear; break; case 2302: t = this.InterpolantFactoryMethodSmooth }if (void 0 === t) { const t = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name; if (void 0 === this.createInterpolant) { if (e === this.DefaultInterpolation) throw new Error(t); this.setInterpolation(this.DefaultInterpolation) } return console.warn("THREE.KeyframeTrack:", t), this } return this.createInterpolant = t, this } getInterpolation() { switch (this.createInterpolant) { case this.InterpolantFactoryMethodDiscrete: return 2300; case this.InterpolantFactoryMethodLinear: return 2301; case this.InterpolantFactoryMethodSmooth: return 2302 } } getValueSize() { return this.values.length / this.times.length } shift(e) { if (0 !== e) { const t = this.times; for (let n = 0, i = t.length; n !== i; ++n)t[n] += e } return this } scale(e) { if (1 !== e) { const t = this.times; for (let n = 0, i = t.length; n !== i; ++n)t[n] *= e } return this } trim(e, t) { const n = this.times, i = n.length; let r = 0, s = i - 1; for (; r !== i && n[r] < e;)++r; for (; -1 !== s && n[s] > t;)--s; if (++s, 0 !== r || s !== i) { r >= s && (s = Math.max(s, 1), r = s - 1); const e = this.getValueSize(); this.times = Bo.arraySlice(n, r, s), this.values = Bo.arraySlice(this.values, r * e, s * e) } return this } validate() { let e = !0; const t = this.getValueSize(); t - Math.floor(t) != 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), e = !1); const n = this.times, i = this.values, r = n.length; 0 === r && (console.error("THREE.KeyframeTrack: Track is empty.", this), e = !1); let s = null; for (let t = 0; t !== r; t++) { const i = n[t]; if ("number" == typeof i && isNaN(i)) { console.error("THREE.KeyframeTrack: Time is not a valid number.", this, t, i), e = !1; break } if (null !== s && s > i) { console.error("THREE.KeyframeTrack: Out of order keys.", this, t, i, s), e = !1; break } s = i } if (void 0 !== i && Bo.isTypedArray(i)) for (let t = 0, n = i.length; t !== n; ++t) { const n = i[t]; if (isNaN(n)) { console.error("THREE.KeyframeTrack: Value is not a valid number.", this, t, n), e = !1; break } } return e } optimize() { const e = Bo.arraySlice(this.times), t = Bo.arraySlice(this.values), n = this.getValueSize(), i = 2302 === this.getInterpolation(), r = e.length - 1; let s = 1; for (let o = 1; o < r; ++o) { let r = !1; const a = e[o]; if (a !== e[o + 1] && (1 !== o || a !== e[0])) if (i) r = !0; else { const e = o * n, i = e - n, s = e + n; for (let o = 0; o !== n; ++o) { const n = t[e + o]; if (n !== t[i + o] || n !== t[s + o]) { r = !0; break } } } if (r) { if (o !== s) { e[s] = e[o]; const i = o * n, r = s * n; for (let e = 0; e !== n; ++e)t[r + e] = t[i + e] } ++s } } if (r > 0) { e[s] = e[r]; for (let e = r * n, i = s * n, o = 0; o !== n; ++o)t[i + o] = t[e + o]; ++s } return s !== e.length ? (this.times = Bo.arraySlice(e, 0, s), this.values = Bo.arraySlice(t, 0, s * n)) : (this.times = e, this.values = t), this } clone() { const e = Bo.arraySlice(this.times, 0), t = Bo.arraySlice(this.values, 0), n = new (0, this.constructor)(this.name, e, t); return n.createInterpolant = this.createInterpolant, n } } No.prototype.TimeBufferType = Float32Array, No.prototype.ValueBufferType = Float32Array, No.prototype.DefaultInterpolation = 2301; class ko extends No { } ko.prototype.ValueTypeName = "bool", ko.prototype.ValueBufferType = Array, ko.prototype.DefaultInterpolation = 2300, ko.prototype.InterpolantFactoryMethodLinear = void 0, ko.prototype.InterpolantFactoryMethodSmooth = void 0; class Ho extends No { } Ho.prototype.ValueTypeName = "color"; class zo extends No { } zo.prototype.ValueTypeName = "number"; class Fo extends Do { constructor(e, t, n, i) { super(e, t, n, i) } interpolate_(e, t, n, i) { const r = this.resultBuffer, s = this.sampleValues, o = this.valueSize, a = (n - t) / (i - t); let l = e * o; for (let e = l + o; l !== e; l += 4)L.slerpFlat(r, 0, s, l - o, s, l, a); return r } } class Qo extends No { InterpolantFactoryMethodLinear(e) { return new Fo(this.times, this.values, this.getValueSize(), e) } } Qo.prototype.ValueTypeName = "quaternion", Qo.prototype.DefaultInterpolation = 2301, Qo.prototype.InterpolantFactoryMethodSmooth = void 0; class Go extends No { } Go.prototype.ValueTypeName = "string", Go.prototype.ValueBufferType = Array, Go.prototype.DefaultInterpolation = 2300, Go.prototype.InterpolantFactoryMethodLinear = void 0, Go.prototype.InterpolantFactoryMethodSmooth = void 0; class jo extends No { } jo.prototype.ValueTypeName = "vector"; class Uo { constructor(e, t = -1, n, i = 2500) { this.name = e, this.tracks = n, this.duration = t, this.blendMode = i, this.uuid = f(), this.duration < 0 && this.resetDuration() } static parse(e) { const t = [], n = e.tracks, i = 1 / (e.fps || 1); for (let e = 0, r = n.length; e !== r; ++e)t.push(Vo(n[e]).scale(i)); const r = new this(e.name, e.duration, t, e.blendMode); return r.uuid = e.uuid, r } static toJSON(e) { const t = [], n = e.tracks, i = { name: e.name, duration: e.duration, tracks: t, uuid: e.uuid, blendMode: e.blendMode }; for (let e = 0, i = n.length; e !== i; ++e)t.push(No.toJSON(n[e])); return i } static CreateFromMorphTargetSequence(e, t, n, i) { const r = t.length, s = []; for (let e = 0; e < r; e++) { let o = [], a = []; o.push((e + r - 1) % r, e, (e + 1) % r), a.push(0, 1, 0); const l = Bo.getKeyframeOrder(o); o = Bo.sortedArray(o, 1, l), a = Bo.sortedArray(a, 1, l), i || 0 !== o[0] || (o.push(r), a.push(a[0])), s.push(new zo(".morphTargetInfluences[" + t[e].name + "]", o, a).scale(1 / n)) } return new this(e, -1, s) } static findByName(e, t) { let n = e; if (!Array.isArray(e)) { const t = e; n = t.geometry && t.geometry.animations || t.animations } for (let e = 0; e < n.length; e++)if (n[e].name === t) return n[e]; return null } static CreateClipsFromMorphTargetSequences(e, t, n) { const i = {}, r = /^([\w-]*?)([\d]+)$/; for (let t = 0, n = e.length; t < n; t++) { const n = e[t], s = n.name.match(r); if (s && s.length > 1) { const e = s[1]; let t = i[e]; t || (i[e] = t = []), t.push(n) } } const s = []; for (const e in i) s.push(this.CreateFromMorphTargetSequence(e, i[e], t, n)); return s } static parseAnimation(e, t) { if (!e) return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null; const n = function (e, t, n, i, r) { if (0 !== n.length) { const s = [], o = []; Bo.flattenJSON(n, s, o, i), 0 !== s.length && r.push(new e(t, s, o)) } }, i = [], r = e.name || "default", s = e.fps || 30, o = e.blendMode; let a = e.length || -1; const l = e.hierarchy || []; for (let e = 0; e < l.length; e++) { const r = l[e].keys; if (r && 0 !== r.length) if (r[0].morphTargets) { const e = {}; let t; for (t = 0; t < r.length; t++)if (r[t].morphTargets) for (let n = 0; n < r[t].morphTargets.length; n++)e[r[t].morphTargets[n]] = -1; for (const n in e) { const e = [], s = []; for (let i = 0; i !== r[t].morphTargets.length; ++i) { const i = r[t]; e.push(i.time), s.push(i.morphTarget === n ? 1 : 0) } i.push(new zo(".morphTargetInfluence[" + n + "]", e, s)) } a = e.length * (s || 1) } else { const s = ".bones[" + t[e].name + "]"; n(jo, s + ".position", r, "pos", i), n(Qo, s + ".quaternion", r, "rot", i), n(jo, s + ".scale", r, "scl", i) } } if (0 === i.length) return null; return new this(r, a, i, o) } resetDuration() { let e = 0; for (let t = 0, n = this.tracks.length; t !== n; ++t) { const n = this.tracks[t]; e = Math.max(e, n.times[n.times.length - 1]) } return this.duration = e, this } trim() { for (let e = 0; e < this.tracks.length; e++)this.tracks[e].trim(0, this.duration); return this } validate() { let e = !0; for (let t = 0; t < this.tracks.length; t++)e = e && this.tracks[t].validate(); return e } optimize() { for (let e = 0; e < this.tracks.length; e++)this.tracks[e].optimize(); return this } clone() { const e = []; for (let t = 0; t < this.tracks.length; t++)e.push(this.tracks[t].clone()); return new this.constructor(this.name, this.duration, e, this.blendMode) } toJSON() { return this.constructor.toJSON(this) } } function Vo(e) { if (void 0 === e.type) throw new Error("THREE.KeyframeTrack: track type undefined, can not parse"); const t = function (e) { switch (e.toLowerCase()) { case "scalar": case "double": case "float": case "number": case "integer": return zo; case "vector": case "vector2": case "vector3": case "vector4": return jo; case "color": return Ho; case "quaternion": return Qo; case "bool": case "boolean": return ko; case "string": return Go }throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + e) }(e.type); if (void 0 === e.times) { const t = [], n = []; Bo.flattenJSON(e.keys, t, n, "value"), e.times = t, e.values = n } return void 0 !== t.parse ? t.parse(e) : new t(e.name, e.times, e.values, e.interpolation) } const Yo = { enabled: !1, files: {}, add: function (e, t) { !1 !== this.enabled && (this.files[e] = t) }, get: function (e) { if (!1 !== this.enabled) return this.files[e] }, remove: function (e) { delete this.files[e] }, clear: function () { this.files = {} } }; class Wo { constructor(e, t, n) { const i = this; let r = !1, s = 0, o = 0, a = void 0; const l = []; this.onStart = void 0, this.onLoad = e, this.onProgress = t, this.onError = n, this.itemStart = function (e) { o++, !1 === r && void 0 !== i.onStart && i.onStart(e, s, o), r = !0 }, this.itemEnd = function (e) { s++, void 0 !== i.onProgress && i.onProgress(e, s, o), s === o && (r = !1, void 0 !== i.onLoad && i.onLoad()) }, this.itemError = function (e) { void 0 !== i.onError && i.onError(e) }, this.resolveURL = function (e) { return a ? a(e) : e }, this.setURLModifier = function (e) { return a = e, this }, this.addHandler = function (e, t) { return l.push(e, t), this }, this.removeHandler = function (e) { const t = l.indexOf(e); return -1 !== t && l.splice(t, 2), this }, this.getHandler = function (e) { for (let t = 0, n = l.length; t < n; t += 2) { const n = l[t], i = l[t + 1]; if (n.global && (n.lastIndex = 0), n.test(e)) return i } return null } } } const Xo = new Wo; class Jo { constructor(e) { this.manager = void 0 !== e ? e : Xo, this.crossOrigin = "anonymous", this.withCredentials = !1, this.path = "", this.resourcePath = "", this.requestHeader = {} } load() { } loadAsync(e, t) { const n = this; return new Promise((function (i, r) { n.load(e, i, t, r) })) } parse() { } setCrossOrigin(e) { return this.crossOrigin = e, this } setWithCredentials(e) { return this.withCredentials = e, this } setPath(e) { return this.path = e, this } setResourcePath(e) { return this.resourcePath = e, this } setRequestHeader(e) { return this.requestHeader = e, this } } const Ko = {}; class Zo extends Jo { constructor(e) { super(e) } load(e, t, n, i) { void 0 === e && (e = ""), void 0 !== this.path && (e = this.path + e), e = this.manager.resolveURL(e); const r = this, s = Yo.get(e); if (void 0 !== s) return r.manager.itemStart(e), setTimeout((function () { t && t(s), r.manager.itemEnd(e) }), 0), s; if (void 0 !== Ko[e]) return void Ko[e].push({ onLoad: t, onProgress: n, onError: i }); const o = e.match(/^data:(.*?)(;base64)?,(.*)$/); let a; if (o) { const n = o[1], s = !!o[2]; let a = o[3]; a = decodeURIComponent(a), s && (a = atob(a)); try { let i; const s = (this.responseType || "").toLowerCase(); switch (s) { case "arraybuffer": case "blob": const e = new Uint8Array(a.length); for (let t = 0; t < a.length; t++)e[t] = a.charCodeAt(t); i = "blob" === s ? new Blob([e.buffer], { type: n }) : e.buffer; break; case "document": const t = new DOMParser; i = t.parseFromString(a, n); break; case "json": i = JSON.parse(a); break; default: i = a }setTimeout((function () { t && t(i), r.manager.itemEnd(e) }), 0) } catch (t) { setTimeout((function () { i && i(t), r.manager.itemError(e), r.manager.itemEnd(e) }), 0) } } else { Ko[e] = [], Ko[e].push({ onLoad: t, onProgress: n, onError: i }), a = new XMLHttpRequest, a.open("GET", e, !0), a.addEventListener("load", (function (t) { const n = this.response, i = Ko[e]; if (delete Ko[e], 200 === this.status || 0 === this.status) { 0 === this.status && console.warn("THREE.FileLoader: HTTP Status 0 received."), Yo.add(e, n); for (let e = 0, t = i.length; e < t; e++) { const t = i[e]; t.onLoad && t.onLoad(n) } r.manager.itemEnd(e) } else { for (let e = 0, n = i.length; e < n; e++) { const n = i[e]; n.onError && n.onError(t) } r.manager.itemError(e), r.manager.itemEnd(e) } }), !1), a.addEventListener("progress", (function (t) { const n = Ko[e]; for (let e = 0, i = n.length; e < i; e++) { const i = n[e]; i.onProgress && i.onProgress(t) } }), !1), a.addEventListener("error", (function (t) { const n = Ko[e]; delete Ko[e]; for (let e = 0, i = n.length; e < i; e++) { const i = n[e]; i.onError && i.onError(t) } r.manager.itemError(e), r.manager.itemEnd(e) }), !1), a.addEventListener("abort", (function (t) { const n = Ko[e]; delete Ko[e]; for (let e = 0, i = n.length; e < i; e++) { const i = n[e]; i.onError && i.onError(t) } r.manager.itemError(e), r.manager.itemEnd(e) }), !1), void 0 !== this.responseType && (a.responseType = this.responseType), void 0 !== this.withCredentials && (a.withCredentials = this.withCredentials), a.overrideMimeType && a.overrideMimeType(void 0 !== this.mimeType ? this.mimeType : "text/plain"); for (const e in this.requestHeader) a.setRequestHeader(e, this.requestHeader[e]); a.send(null) } return r.manager.itemStart(e), a } setResponseType(e) { return this.responseType = e, this } setMimeType(e) { return this.mimeType = e, this } } class qo extends Jo { constructor(e) { super(e) } load(e, t, n, i) { void 0 !== this.path && (e = this.path + e), e = this.manager.resolveURL(e); const r = this, s = Yo.get(e); if (void 0 !== s) return r.manager.itemStart(e), setTimeout((function () { t && t(s), r.manager.itemEnd(e) }), 0), s; const o = document.createElementNS("http://www.w3.org/1999/xhtml", "img"); function a() { o.removeEventListener("load", a, !1), o.removeEventListener("error", l, !1), Yo.add(e, this), t && t(this), r.manager.itemEnd(e) } function l(t) { o.removeEventListener("load", a, !1), o.removeEventListener("error", l, !1), i && i(t), r.manager.itemError(e), r.manager.itemEnd(e) } return o.addEventListener("load", a, !1), o.addEventListener("error", l, !1), "data:" !== e.substr(0, 5) && void 0 !== this.crossOrigin && (o.crossOrigin = this.crossOrigin), r.manager.itemStart(e), o.src = e, o } } class _o extends Jo { constructor(e) { super(e) } load(e, t, n, i) { const r = new Wt, s = new qo(this.manager); s.setCrossOrigin(this.crossOrigin), s.setPath(this.path); let o = 0; function a(n) { s.load(e[n], (function (e) { r.images[n] = e, o++, 6 === o && (r.needsUpdate = !0, t && t(r)) }), void 0, i) } for (let t = 0; t < e.length; ++t)a(t); return r } } class $o extends Jo { constructor(e) { super(e) } load(e, t, n, i) { const r = new P, s = new qo(this.manager); return s.setCrossOrigin(this.crossOrigin), s.setPath(this.path), s.load(e, (function (n) { r.image = n; const i = e.search(/\.jpe?g($|\?)/i) > 0 || 0 === e.search(/^data\:image\/jpeg/); r.format = i ? 1022 : 1023, r.needsUpdate = !0, void 0 !== t && t(r) }), n, i), r } } class ea extends Cs { constructor() { super(), this.type = "CurvePath", this.curves = [], this.autoClose = !1 } add(e) { this.curves.push(e) } closePath() { const e = this.curves[0].getPoint(0), t = this.curves[this.curves.length - 1].getPoint(1); e.equals(t) || this.curves.push(new ks(t, e)) } getPoint(e) { const t = e * this.getLength(), n = this.getCurveLengths(); let i = 0; for (; i < n.length;) { if (n[i] >= t) { const e = n[i] - t, r = this.curves[i], s = r.getLength(), o = 0 === s ? 0 : 1 - e / s; return r.getPointAt(o) } i++ } return null } getLength() { const e = this.getCurveLengths(); return e[e.length - 1] } updateArcLengths() { this.needsUpdate = !0, this.cacheLengths = null, this.getCurveLengths() } getCurveLengths() { if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths; const e = []; let t = 0; for (let n = 0, i = this.curves.length; n < i; n++)t += this.curves[n].getLength(), e.push(t); return this.cacheLengths = e, e } getSpacedPoints(e = 40) { const t = []; for (let n = 0; n <= e; n++)t.push(this.getPoint(n / e)); return this.autoClose && t.push(t[0]), t } getPoints(e = 12) { const t = []; let n; for (let i = 0, r = this.curves; i < r.length; i++) { const s = r[i], o = s && s.isEllipseCurve ? 2 * e : s && (s.isLineCurve || s.isLineCurve3) ? 1 : s && s.isSplineCurve ? e * s.points.length : e, a = s.getPoints(o); for (let e = 0; e < a.length; e++) { const i = a[e]; n && n.equals(i) || (t.push(i), n = i) } } return this.autoClose && t.length > 1 && !t[t.length - 1].equals(t[0]) && t.push(t[0]), t } copy(e) { super.copy(e), this.curves = []; for (let t = 0, n = e.curves.length; t < n; t++) { const n = e.curves[t]; this.curves.push(n.clone()) } return this.autoClose = e.autoClose, this } toJSON() { const e = super.toJSON(); e.autoClose = this.autoClose, e.curves = []; for (let t = 0, n = this.curves.length; t < n; t++) { const n = this.curves[t]; e.curves.push(n.toJSON()) } return e } fromJSON(e) { super.fromJSON(e), this.autoClose = e.autoClose, this.curves = []; for (let t = 0, n = e.curves.length; t < n; t++) { const n = e.curves[t]; this.curves.push((new Qs[n.type]).fromJSON(n)) } return this } } class ta extends ea { constructor(e) { super(), this.type = "Path", this.currentPoint = new b, e && this.setFromPoints(e) } setFromPoints(e) { this.moveTo(e[0].x, e[0].y); for (let t = 1, n = e.length; t < n; t++)this.lineTo(e[t].x, e[t].y); return this } moveTo(e, t) { return this.currentPoint.set(e, t), this } lineTo(e, t) { const n = new ks(this.currentPoint.clone(), new b(e, t)); return this.curves.push(n), this.currentPoint.set(e, t), this } quadraticCurveTo(e, t, n, i) { const r = new Hs(this.currentPoint.clone(), new b(e, t), new b(n, i)); return this.curves.push(r), this.currentPoint.set(n, i), this } bezierCurveTo(e, t, n, i, r, s) { const o = new Os(this.currentPoint.clone(), new b(e, t), new b(n, i), new b(r, s)); return this.curves.push(o), this.currentPoint.set(r, s), this } splineThru(e) { const t = [this.currentPoint.clone()].concat(e), n = new Fs(t); return this.curves.push(n), this.currentPoint.copy(e[e.length - 1]), this } arc(e, t, n, i, r, s) { const o = this.currentPoint.x, a = this.currentPoint.y; return this.absarc(e + o, t + a, n, i, r, s), this } absarc(e, t, n, i, r, s) { return this.absellipse(e, t, n, n, i, r, s), this } ellipse(e, t, n, i, r, s, o, a) { const l = this.currentPoint.x, c = this.currentPoint.y; return this.absellipse(e + l, t + c, n, i, r, s, o, a), this } absellipse(e, t, n, i, r, s, o, a) { const l = new bs(e, t, n, i, r, s, o, a); if (this.curves.length > 0) { const e = l.getPoint(0); e.equals(this.currentPoint) || this.lineTo(e.x, e.y) } this.curves.push(l); const c = l.getPoint(1); return this.currentPoint.copy(c), this } copy(e) { return super.copy(e), this.currentPoint.copy(e.currentPoint), this } toJSON() { const e = super.toJSON(); return e.currentPoint = this.currentPoint.toArray(), e } fromJSON(e) { return super.fromJSON(e), this.currentPoint.fromArray(e.currentPoint), this } } class na extends ta { constructor(e) { super(e), this.uuid = f(), this.type = "Shape", this.holes = [] } getPointsHoles(e) { const t = []; for (let n = 0, i = this.holes.length; n < i; n++)t[n] = this.holes[n].getPoints(e); return t } extractPoints(e) { return { shape: this.getPoints(e), holes: this.getPointsHoles(e) } } copy(e) { super.copy(e), this.holes = []; for (let t = 0, n = e.holes.length; t < n; t++) { const n = e.holes[t]; this.holes.push(n.clone()) } return this } toJSON() { const e = super.toJSON(); e.uuid = this.uuid, e.holes = []; for (let t = 0, n = this.holes.length; t < n; t++) { const n = this.holes[t]; e.holes.push(n.toJSON()) } return e } fromJSON(e) { super.fromJSON(e), this.uuid = e.uuid, this.holes = []; for (let t = 0, n = e.holes.length; t < n; t++) { const n = e.holes[t]; this.holes.push((new ta).fromJSON(n)) } return this } } class ia extends ke { constructor(e, t = 1) { super(), this.type = "Light", this.color = new nt(e), this.intensity = t } dispose() { } copy(e) { return super.copy(e), this.color.copy(e.color), this.intensity = e.intensity, this } toJSON(e) { const t = super.toJSON(e); return t.object.color = this.color.getHex(), t.object.intensity = this.intensity, void 0 !== this.groundColor && (t.object.groundColor = this.groundColor.getHex()), void 0 !== this.distance && (t.object.distance = this.distance), void 0 !== this.angle && (t.object.angle = this.angle), void 0 !== this.decay && (t.object.decay = this.decay), void 0 !== this.penumbra && (t.object.penumbra = this.penumbra), void 0 !== this.shadow && (t.object.shadow = this.shadow.toJSON()), t } } ia.prototype.isLight = !0; class ra extends ia { constructor(e, t, n) { super(e, n), this.type = "HemisphereLight", this.position.copy(ke.DefaultUp), this.updateMatrix(), this.groundColor = new nt(t) } copy(e) { return ia.prototype.copy.call(this, e), this.groundColor.copy(e.groundColor), this } } ra.prototype.isHemisphereLight = !0; const sa = new ue, oa = new O, aa = new O; class la { constructor(e) { this.camera = e, this.bias = 0, this.normalBias = 0, this.radius = 1, this.mapSize = new b(512, 512), this.map = null, this.mapPass = null, this.matrix = new ue, this.autoUpdate = !0, this.needsUpdate = !1, this._frustum = new en, this._frameExtents = new b(1, 1), this._viewportCount = 1, this._viewports = [new B(0, 0, 1, 1)] } getViewportCount() { return this._viewportCount } getFrustum() { return this._frustum } updateMatrices(e) { const t = this.camera, n = this.matrix; oa.setFromMatrixPosition(e.matrixWorld), t.position.copy(oa), aa.setFromMatrixPosition(e.target.matrixWorld), t.lookAt(aa), t.updateMatrixWorld(), sa.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse), this._frustum.setFromProjectionMatrix(sa), n.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), n.multiply(t.projectionMatrix), n.multiply(t.matrixWorldInverse) } getViewport(e) { return this._viewports[e] } getFrameExtents() { return this._frameExtents } dispose() { this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose() } copy(e) { return this.camera = e.camera.clone(), this.bias = e.bias, this.radius = e.radius, this.mapSize.copy(e.mapSize), this } clone() { return (new this.constructor).copy(this) } toJSON() { const e = {}; return 0 !== this.bias && (e.bias = this.bias), 0 !== this.normalBias && (e.normalBias = this.normalBias), 1 !== this.radius && (e.radius = this.radius), 512 === this.mapSize.x && 512 === this.mapSize.y || (e.mapSize = this.mapSize.toArray()), e.camera = this.camera.toJSON(!1).object, delete e.camera.matrix, e } } class ca extends la { constructor() { super(new Vt(50, 1, .5, 500)), this.focus = 1 } updateMatrices(e) { const t = this.camera, n = 2 * p * e.angle * this.focus, i = this.mapSize.width / this.mapSize.height, r = e.distance || t.far; n === t.fov && i === t.aspect && r === t.far || (t.fov = n, t.aspect = i, t.far = r, t.updateProjectionMatrix()), super.updateMatrices(e) } copy(e) { return super.copy(e), this.focus = e.focus, this } } ca.prototype.isSpotLightShadow = !0; class Aa extends ia { constructor(e, t, n = 0, i = Math.PI / 3, r = 0, s = 1) { super(e, t), this.type = "SpotLight", this.position.copy(ke.DefaultUp), this.updateMatrix(), this.target = new ke, this.distance = n, this.angle = i, this.penumbra = r, this.decay = s, this.shadow = new ca } get power() { return this.intensity * Math.PI } set power(e) { this.intensity = e / Math.PI } dispose() { this.shadow.dispose() } copy(e) { return super.copy(e), this.distance = e.distance, this.angle = e.angle, this.penumbra = e.penumbra, this.decay = e.decay, this.target = e.target.clone(), this.shadow = e.shadow.clone(), this } } Aa.prototype.isSpotLight = !0; const ua = new ue, ha = new O, da = new O; class pa extends la { constructor() { super(new Vt(90, 1, .5, 500)), this._frameExtents = new b(4, 2), this._viewportCount = 6, this._viewports = [new B(2, 1, 1, 1), new B(0, 1, 1, 1), new B(3, 1, 1, 1), new B(1, 1, 1, 1), new B(3, 0, 1, 1), new B(1, 0, 1, 1)], this._cubeDirections = [new O(1, 0, 0), new O(-1, 0, 0), new O(0, 0, 1), new O(0, 0, -1), new O(0, 1, 0), new O(0, -1, 0)], this._cubeUps = [new O(0, 1, 0), new O(0, 1, 0), new O(0, 1, 0), new O(0, 1, 0), new O(0, 0, 1), new O(0, 0, -1)] } updateMatrices(e, t = 0) { const n = this.camera, i = this.matrix, r = e.distance || n.far; r !== n.far && (n.far = r, n.updateProjectionMatrix()), ha.setFromMatrixPosition(e.matrixWorld), n.position.copy(ha), da.copy(n.position), da.add(this._cubeDirections[t]), n.up.copy(this._cubeUps[t]), n.lookAt(da), n.updateMatrixWorld(), i.makeTranslation(-ha.x, -ha.y, -ha.z), ua.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse), this._frustum.setFromProjectionMatrix(ua) } } pa.prototype.isPointLightShadow = !0; class fa extends ia { constructor(e, t, n = 0, i = 1) { super(e, t), this.type = "PointLight", this.distance = n, this.decay = i, this.shadow = new pa } get power() { return 4 * this.intensity * Math.PI } set power(e) { this.intensity = e / (4 * Math.PI) } dispose() { this.shadow.dispose() } copy(e) { return super.copy(e), this.distance = e.distance, this.decay = e.decay, this.shadow = e.shadow.clone(), this } } fa.prototype.isPointLight = !0; class ga extends Ut { constructor(e = -1, t = 1, n = 1, i = -1, r = .1, s = 2e3) { super(), this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = e, this.right = t, this.top = n, this.bottom = i, this.near = r, this.far = s, this.updateProjectionMatrix() } copy(e, t) { return super.copy(e, t), this.left = e.left, this.right = e.right, this.top = e.top, this.bottom = e.bottom, this.near = e.near, this.far = e.far, this.zoom = e.zoom, this.view = null === e.view ? null : Object.assign({}, e.view), this } setViewOffset(e, t, n, i, r, s) { null === this.view && (this.view = { enabled: !0, fullWidth: 1, fullHeight: 1, offsetX: 0, offsetY: 0, width: 1, height: 1 }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = n, this.view.offsetY = i, this.view.width = r, this.view.height = s, this.updateProjectionMatrix() } clearViewOffset() { null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix() } updateProjectionMatrix() { const e = (this.right - this.left) / (2 * this.zoom), t = (this.top - this.bottom) / (2 * this.zoom), n = (this.right + this.left) / 2, i = (this.top + this.bottom) / 2; let r = n - e, s = n + e, o = i + t, a = i - t; if (null !== this.view && this.view.enabled) { const e = (this.right - this.left) / this.view.fullWidth / this.zoom, t = (this.top - this.bottom) / this.view.fullHeight / this.zoom; r += e * this.view.offsetX, s = r + e * this.view.width, o -= t * this.view.offsetY, a = o - t * this.view.height } this.projectionMatrix.makeOrthographic(r, s, o, a, this.near, this.far), this.projectionMatrixInverse.copy(this.projectionMatrix).invert() } toJSON(e) { const t = super.toJSON(e); return t.object.zoom = this.zoom, t.object.left = this.left, t.object.right = this.right, t.object.top = this.top, t.object.bottom = this.bottom, t.object.near = this.near, t.object.far = this.far, null !== this.view && (t.object.view = Object.assign({}, this.view)), t } } ga.prototype.isOrthographicCamera = !0; class ma extends la { constructor() { super(new ga(-5, 5, 5, -5, .5, 500)) } } ma.prototype.isDirectionalLightShadow = !0; class va extends ia { constructor(e, t) { super(e, t), this.type = "DirectionalLight", this.position.copy(ke.DefaultUp), this.updateMatrix(), this.target = new ke, this.shadow = new ma } dispose() { this.shadow.dispose() } copy(e) { return super.copy(e), this.target = e.target.clone(), this.shadow = e.shadow.clone(), this } } va.prototype.isDirectionalLight = !0; class ya extends ia { constructor(e, t) { super(e, t), this.type = "AmbientLight" } } ya.prototype.isAmbientLight = !0; class wa extends ia { constructor(e, t, n = 10, i = 10) { super(e, t), this.type = "RectAreaLight", this.width = n, this.height = i } copy(e) { return super.copy(e), this.width = e.width, this.height = e.height, this } toJSON(e) { const t = super.toJSON(e); return t.object.width = this.width, t.object.height = this.height, t } } wa.prototype.isRectAreaLight = !0; class xa { constructor() { this.coefficients = []; for (let e = 0; e < 9; e++)this.coefficients.push(new O) } set(e) { for (let t = 0; t < 9; t++)this.coefficients[t].copy(e[t]); return this } zero() { for (let e = 0; e < 9; e++)this.coefficients[e].set(0, 0, 0); return this } getAt(e, t) { const n = e.x, i = e.y, r = e.z, s = this.coefficients; return t.copy(s[0]).multiplyScalar(.282095), t.addScaledVector(s[1], .488603 * i), t.addScaledVector(s[2], .488603 * r), t.addScaledVector(s[3], .488603 * n), t.addScaledVector(s[4], n * i * 1.092548), t.addScaledVector(s[5], i * r * 1.092548), t.addScaledVector(s[6], .315392 * (3 * r * r - 1)), t.addScaledVector(s[7], n * r * 1.092548), t.addScaledVector(s[8], .546274 * (n * n - i * i)), t } getIrradianceAt(e, t) { const n = e.x, i = e.y, r = e.z, s = this.coefficients; return t.copy(s[0]).multiplyScalar(.886227), t.addScaledVector(s[1], 1.023328 * i), t.addScaledVector(s[2], 1.023328 * r), t.addScaledVector(s[3], 1.023328 * n), t.addScaledVector(s[4], .858086 * n * i), t.addScaledVector(s[5], .858086 * i * r), t.addScaledVector(s[6], .743125 * r * r - .247708), t.addScaledVector(s[7], .858086 * n * r), t.addScaledVector(s[8], .429043 * (n * n - i * i)), t } add(e) { for (let t = 0; t < 9; t++)this.coefficients[t].add(e.coefficients[t]); return this } addScaledSH(e, t) { for (let n = 0; n < 9; n++)this.coefficients[n].addScaledVector(e.coefficients[n], t); return this } scale(e) { for (let t = 0; t < 9; t++)this.coefficients[t].multiplyScalar(e); return this } lerp(e, t) { for (let n = 0; n < 9; n++)this.coefficients[n].lerp(e.coefficients[n], t); return this } equals(e) { for (let t = 0; t < 9; t++)if (!this.coefficients[t].equals(e.coefficients[t])) return !1; return !0 } copy(e) { return this.set(e.coefficients) } clone() { return (new this.constructor).copy(this) } fromArray(e, t = 0) { const n = this.coefficients; for (let i = 0; i < 9; i++)n[i].fromArray(e, t + 3 * i); return this } toArray(e = [], t = 0) { const n = this.coefficients; for (let i = 0; i < 9; i++)n[i].toArray(e, t + 3 * i); return e } static getBasisAt(e, t) { const n = e.x, i = e.y, r = e.z; t[0] = .282095, t[1] = .488603 * i, t[2] = .488603 * r, t[3] = .488603 * n, t[4] = 1.092548 * n * i, t[5] = 1.092548 * i * r, t[6] = .315392 * (3 * r * r - 1), t[7] = 1.092548 * n * r, t[8] = .546274 * (n * n - i * i) } } xa.prototype.isSphericalHarmonics3 = !0; class Ca extends ia { constructor(e = new xa, t = 1) { super(void 0, t), this.sh = e } copy(e) { return super.copy(e), this.sh.copy(e.sh), this } fromJSON(e) { return this.intensity = e.intensity, this.sh.fromArray(e.sh), this } toJSON(e) { const t = super.toJSON(e); return t.object.sh = this.sh.toArray(), t } } Ca.prototype.isLightProbe = !0; class ba { static decodeText(e) { if ("undefined" != typeof TextDecoder) return (new TextDecoder).decode(e); let t = ""; for (let n = 0, i = e.length; n < i; n++)t += String.fromCharCode(e[n]); try { return decodeURIComponent(escape(t)) } catch (e) { return t } } static extractUrlBase(e) { const t = e.lastIndexOf("/"); return -1 === t ? "./" : e.substr(0, t + 1) } } class Ma extends vt { constructor() { super(), this.type = "InstancedBufferGeometry", this.instanceCount = 1 / 0 } copy(e) { return super.copy(e), this.instanceCount = e.instanceCount, this } clone() { return (new this.constructor).copy(this) } toJSON() { const e = super.toJSON(this); return e.instanceCount = this.instanceCount, e.isInstancedBufferGeometry = !0, e } } Ma.prototype.isInstancedBufferGeometry = !0; class Ia extends ot { constructor(e, t, n, i = 1) { "number" == typeof n && (i = n, n = !1, console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.")), super(e, t, n), this.meshPerAttribute = i } copy(e) { return super.copy(e), this.meshPerAttribute = e.meshPerAttribute, this } toJSON() { const e = super.toJSON(); return e.meshPerAttribute = this.meshPerAttribute, e.isInstancedBufferAttribute = !0, e } } Ia.prototype.isInstancedBufferAttribute = !0; class Ea extends Jo { constructor(e) { super(e), "undefined" == typeof createImageBitmap && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), "undefined" == typeof fetch && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), this.options = { premultiplyAlpha: "none" } } setOptions(e) { return this.options = e, this } load(e, t, n, i) { void 0 === e && (e = ""), void 0 !== this.path && (e = this.path + e), e = this.manager.resolveURL(e); const r = this, s = Yo.get(e); if (void 0 !== s) return r.manager.itemStart(e), setTimeout((function () { t && t(s), r.manager.itemEnd(e) }), 0), s; const o = {}; o.credentials = "anonymous" === this.crossOrigin ? "same-origin" : "include", o.headers = this.requestHeader, fetch(e, o).then((function (e) { return e.blob() })).then((function (e) { return createImageBitmap(e, Object.assign(r.options, { colorSpaceConversion: "none" })) })).then((function (n) { Yo.add(e, n), t && t(n), r.manager.itemEnd(e) })).catch((function (t) { i && i(t), r.manager.itemError(e), r.manager.itemEnd(e) })), r.manager.itemStart(e) } } Ea.prototype.isImageBitmapLoader = !0; class Ta { constructor() { this.type = "ShapePath", this.color = new nt, this.subPaths = [], this.currentPath = null } moveTo(e, t) { return this.currentPath = new ta, this.subPaths.push(this.currentPath), this.currentPath.moveTo(e, t), this } lineTo(e, t) { return this.currentPath.lineTo(e, t), this } quadraticCurveTo(e, t, n, i) { return this.currentPath.quadraticCurveTo(e, t, n, i), this } bezierCurveTo(e, t, n, i, r, s) { return this.currentPath.bezierCurveTo(e, t, n, i, r, s), this } splineThru(e) { return this.currentPath.splineThru(e), this } toShapes(e, t) { function n(e) { const t = []; for (let n = 0, i = e.length; n < i; n++) { const i = e[n], r = new na; r.curves = i.curves, t.push(r) } return t } function i(e, t) { const n = t.length; let i = !1; for (let r = n - 1, s = 0; s < n; r = s++) { let n = t[r], o = t[s], a = o.x - n.x, l = o.y - n.y; if (Math.abs(l) > Number.EPSILON) { if (l < 0 && (n = t[s], a = -a, o = t[r], l = -l), e.y < n.y || e.y > o.y) continue; if (e.y === n.y) { if (e.x === n.x) return !0 } else { const t = l * (e.x - n.x) - a * (e.y - n.y); if (0 === t) return !0; if (t < 0) continue; i = !i } } else { if (e.y !== n.y) continue; if (o.x <= e.x && e.x <= n.x || n.x <= e.x && e.x <= o.x) return !0 } } return i } const r = ho.isClockWise, s = this.subPaths; if (0 === s.length) return []; if (!0 === t) return n(s); let o, a, l; const c = []; if (1 === s.length) return a = s[0], l = new na, l.curves = a.curves, c.push(l), c; let A = !r(s[0].getPoints()); A = e ? !A : A; const u = [], h = []; let d, p, f = [], g = 0; h[g] = void 0, f[g] = []; for (let t = 0, n = s.length; t < n; t++)a = s[t], d = a.getPoints(), o = r(d), o = e ? !o : o, o ? (!A && h[g] && g++, h[g] = { s: new na, p: d }, h[g].s.curves = a.curves, A && g++, f[g] = []) : f[g].push({ h: a, p: d[0] }); if (!h[0]) return n(s); if (h.length > 1) { let e = !1; const t = []; for (let e = 0, t = h.length; e < t; e++)u[e] = []; for (let n = 0, r = h.length; n < r; n++) { const r = f[n]; for (let s = 0; s < r.length; s++) { const o = r[s]; let a = !0; for (let r = 0; r < h.length; r++)i(o.p, h[r].p) && (n !== r && t.push({ froms: n, tos: r, hole: s }), a ? (a = !1, u[r].push(o)) : e = !0); a && u[n].push(o) } } t.length > 0 && (e || (f = u)) } for (let e = 0, t = h.length; e < t; e++) { l = h[e].s, c.push(l), p = f[e]; for (let e = 0, t = p.length; e < t; e++)l.holes.push(p[e].h) } return c } } class Pa { constructor(e) { this.type = "Font", this.data = e } generateShapes(e, t = 100) { const n = [], i = function (e, t, n) { const i = Array.from(e), r = t / n.resolution, s = (n.boundingBox.yMax - n.boundingBox.yMin + n.underlineThickness) * r, o = []; let a = 0, l = 0; for (let e = 0; e < i.length; e++) { const t = i[e]; if ("\n" === t) a = 0, l -= s; else { const e = Sa(t, r, a, l, n); a += e.offsetX, o.push(e.path) } } return o }(e, t, this.data); for (let e = 0, t = i.length; e < t; e++)Array.prototype.push.apply(n, i[e].toShapes()); return n } } function Sa(e, t, n, i, r) { const s = r.glyphs[e] || r.glyphs["?"]; if (!s) return void console.error('THREE.Font: character "' + e + '" does not exists in font family ' + r.familyName + "."); const o = new Ta; let a, l, c, A, u, h, d, p; if (s.o) { const e = s._cachedOutline || (s._cachedOutline = s.o.split(" ")); for (let r = 0, s = e.length; r < s;) { switch (e[r++]) { case "m": a = e[r++] * t + n, l = e[r++] * t + i, o.moveTo(a, l); break; case "l": a = e[r++] * t + n, l = e[r++] * t + i, o.lineTo(a, l); break; case "q": c = e[r++] * t + n, A = e[r++] * t + i, u = e[r++] * t + n, h = e[r++] * t + i, o.quadraticCurveTo(u, h, c, A); break; case "b": c = e[r++] * t + n, A = e[r++] * t + i, u = e[r++] * t + n, h = e[r++] * t + i, d = e[r++] * t + n, p = e[r++] * t + i, o.bezierCurveTo(u, h, d, p, c, A) } } } return { offsetX: s.ha * t, path: o } } Pa.prototype.isFont = !0; let Ba; const Da = function () { return void 0 === Ba && (Ba = new (window.AudioContext || window.webkitAudioContext)), Ba }; class Ra extends Jo { constructor(e) { super(e) } load(e, t, n, i) { const r = this, s = new Zo(this.manager); s.setResponseType("arraybuffer"), s.setPath(this.path), s.setRequestHeader(this.requestHeader), s.setWithCredentials(this.withCredentials), s.load(e, (function (n) { try { const e = n.slice(0); Da().decodeAudioData(e, (function (e) { t(e) })) } catch (t) { i ? i(t) : console.error(t), r.manager.itemError(e) } }), n, i) } } (class extends Ca { constructor(e, t, n = 1) { super(void 0, n); const i = (new nt).set(e), r = (new nt).set(t), s = new O(i.r, i.g, i.b), o = new O(r.r, r.g, r.b), a = Math.sqrt(Math.PI), l = a * Math.sqrt(.75); this.sh.coefficients[0].copy(s).add(o).multiplyScalar(a), this.sh.coefficients[1].copy(s).sub(o).multiplyScalar(l) } }).prototype.isHemisphereLightProbe = !0; (class extends Ca { constructor(e, t = 1) { super(void 0, t); const n = (new nt).set(e); this.sh.coefficients[0].set(n.r, n.g, n.b).multiplyScalar(2 * Math.sqrt(Math.PI)) } }).prototype.isAmbientLightProbe = !0; class La { constructor(e = !0) { this.autoStart = e, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = !1 } start() { this.startTime = Oa(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = !0 } stop() { this.getElapsedTime(), this.running = !1, this.autoStart = !1 } getElapsedTime() { return this.getDelta(), this.elapsedTime } getDelta() { let e = 0; if (this.autoStart && !this.running) return this.start(), 0; if (this.running) { const t = Oa(); e = (t - this.oldTime) / 1e3, this.oldTime = t, this.elapsedTime += e } return e } } function Oa() { return ("undefined" == typeof performance ? Date : performance).now() } class Na extends ke { constructor(e) { super(), this.type = "Audio", this.listener = e, this.context = e.context, this.gain = this.context.createGain(), this.gain.connect(e.getInput()), this.autoplay = !1, this.buffer = null, this.detune = 0, this.loop = !1, this.loopStart = 0, this.loopEnd = 0, this.offset = 0, this.duration = void 0, this.playbackRate = 1, this.isPlaying = !1, this.hasPlaybackControl = !0, this.source = null, this.sourceType = "empty", this._startedAt = 0, this._progress = 0, this._connected = !1, this.filters = [] } getOutput() { return this.gain } setNodeSource(e) { return this.hasPlaybackControl = !1, this.sourceType = "audioNode", this.source = e, this.connect(), this } setMediaElementSource(e) { return this.hasPlaybackControl = !1, this.sourceType = "mediaNode", this.source = this.context.createMediaElementSource(e), this.connect(), this } setMediaStreamSource(e) { return this.hasPlaybackControl = !1, this.sourceType = "mediaStreamNode", this.source = this.context.createMediaStreamSource(e), this.connect(), this } setBuffer(e) { return this.buffer = e, this.sourceType = "buffer", this.autoplay && this.play(), this } play(e = 0) { if (!0 === this.isPlaying) return void console.warn("THREE.Audio: Audio is already playing."); if (!1 === this.hasPlaybackControl) return void console.warn("THREE.Audio: this Audio has no playback control."); this._startedAt = this.context.currentTime + e; const t = this.context.createBufferSource(); return t.buffer = this.buffer, t.loop = this.loop, t.loopStart = this.loopStart, t.loopEnd = this.loopEnd, t.onended = this.onEnded.bind(this), t.start(this._startedAt, this._progress + this.offset, this.duration), this.isPlaying = !0, this.source = t, this.setDetune(this.detune), this.setPlaybackRate(this.playbackRate), this.connect() } pause() { if (!1 !== this.hasPlaybackControl) return !0 === this.isPlaying && (this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate, !0 === this.loop && (this._progress = this._progress % (this.duration || this.buffer.duration)), this.source.stop(), this.source.onended = null, this.isPlaying = !1), this; console.warn("THREE.Audio: this Audio has no playback control.") } stop() { if (!1 !== this.hasPlaybackControl) return this._progress = 0, this.source.stop(), this.source.onended = null, this.isPlaying = !1, this; console.warn("THREE.Audio: this Audio has no playback control.") } connect() { if (this.filters.length > 0) { this.source.connect(this.filters[0]); for (let e = 1, t = this.filters.length; e < t; e++)this.filters[e - 1].connect(this.filters[e]); this.filters[this.filters.length - 1].connect(this.getOutput()) } else this.source.connect(this.getOutput()); return this._connected = !0, this } disconnect() { if (this.filters.length > 0) { this.source.disconnect(this.filters[0]); for (let e = 1, t = this.filters.length; e < t; e++)this.filters[e - 1].disconnect(this.filters[e]); this.filters[this.filters.length - 1].disconnect(this.getOutput()) } else this.source.disconnect(this.getOutput()); return this._connected = !1, this } getFilters() { return this.filters } setFilters(e) { return e || (e = []), !0 === this._connected ? (this.disconnect(), this.filters = e.slice(), this.connect()) : this.filters = e.slice(), this } setDetune(e) { if (this.detune = e, void 0 !== this.source.detune) return !0 === this.isPlaying && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, .01), this } getDetune() { return this.detune } getFilter() { return this.getFilters()[0] } setFilter(e) { return this.setFilters(e ? [e] : []) } setPlaybackRate(e) { if (!1 !== this.hasPlaybackControl) return this.playbackRate = e, !0 === this.isPlaying && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, .01), this; console.warn("THREE.Audio: this Audio has no playback control.") } getPlaybackRate() { return this.playbackRate } onEnded() { this.isPlaying = !1 } getLoop() { return !1 === this.hasPlaybackControl ? (console.warn("THREE.Audio: this Audio has no playback control."), !1) : this.loop } setLoop(e) { if (!1 !== this.hasPlaybackControl) return this.loop = e, !0 === this.isPlaying && (this.source.loop = this.loop), this; console.warn("THREE.Audio: this Audio has no playback control.") } setLoopStart(e) { return this.loopStart = e, this } setLoopEnd(e) { return this.loopEnd = e, this } getVolume() { return this.gain.gain.value } setVolume(e) { return this.gain.gain.setTargetAtTime(e, this.context.currentTime, .01), this } } class ka { constructor(e, t, n) { let i, r, s; switch (this.binding = e, this.valueSize = n, t) { case "quaternion": i = this._slerp, r = this._slerpAdditive, s = this._setAdditiveIdentityQuaternion, this.buffer = new Float64Array(6 * n), this._workIndex = 5; break; case "string": case "bool": i = this._select, r = this._select, s = this._setAdditiveIdentityOther, this.buffer = new Array(5 * n); break; default: i = this._lerp, r = this._lerpAdditive, s = this._setAdditiveIdentityNumeric, this.buffer = new Float64Array(5 * n) }this._mixBufferRegion = i, this._mixBufferRegionAdditive = r, this._setIdentity = s, this._origIndex = 3, this._addIndex = 4, this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, this.useCount = 0, this.referenceCount = 0 } accumulate(e, t) { const n = this.buffer, i = this.valueSize, r = e * i + i; let s = this.cumulativeWeight; if (0 === s) { for (let e = 0; e !== i; ++e)n[r + e] = n[e]; s = t } else { s += t; const e = t / s; this._mixBufferRegion(n, r, 0, e, i) } this.cumulativeWeight = s } accumulateAdditive(e) { const t = this.buffer, n = this.valueSize, i = n * this._addIndex; 0 === this.cumulativeWeightAdditive && this._setIdentity(), this._mixBufferRegionAdditive(t, i, 0, e, n), this.cumulativeWeightAdditive += e } apply(e) { const t = this.valueSize, n = this.buffer, i = e * t + t, r = this.cumulativeWeight, s = this.cumulativeWeightAdditive, o = this.binding; if (this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, r < 1) { const e = t * this._origIndex; this._mixBufferRegion(n, i, e, 1 - r, t) } s > 0 && this._mixBufferRegionAdditive(n, i, this._addIndex * t, 1, t); for (let e = t, r = t + t; e !== r; ++e)if (n[e] !== n[e + t]) { o.setValue(n, i); break } } saveOriginalState() { const e = this.binding, t = this.buffer, n = this.valueSize, i = n * this._origIndex; e.getValue(t, i); for (let e = n, r = i; e !== r; ++e)t[e] = t[i + e % n]; this._setIdentity(), this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0 } restoreOriginalState() { const e = 3 * this.valueSize; this.binding.setValue(this.buffer, e) } _setAdditiveIdentityNumeric() { const e = this._addIndex * this.valueSize, t = e + this.valueSize; for (let n = e; n < t; n++)this.buffer[n] = 0 } _setAdditiveIdentityQuaternion() { this._setAdditiveIdentityNumeric(), this.buffer[this._addIndex * this.valueSize + 3] = 1 } _setAdditiveIdentityOther() { const e = this._origIndex * this.valueSize, t = this._addIndex * this.valueSize; for (let n = 0; n < this.valueSize; n++)this.buffer[t + n] = this.buffer[e + n] } _select(e, t, n, i, r) { if (i >= .5) for (let i = 0; i !== r; ++i)e[t + i] = e[n + i] } _slerp(e, t, n, i) { L.slerpFlat(e, t, e, t, e, n, i) } _slerpAdditive(e, t, n, i, r) { const s = this._workIndex * r; L.multiplyQuaternionsFlat(e, s, e, t, e, n), L.slerpFlat(e, t, e, t, e, s, i) } _lerp(e, t, n, i, r) { const s = 1 - i; for (let o = 0; o !== r; ++o) { const r = t + o; e[r] = e[r] * s + e[n + o] * i } } _lerpAdditive(e, t, n, i, r) { for (let s = 0; s !== r; ++s) { const r = t + s; e[r] = e[r] + e[n + s] * i } } } const Ha = new RegExp("[\\[\\]\\.:\\/]", "g"), za = "[^" + "\\[\\]\\.:\\/".replace("\\.", "") + "]", Fa = /((?:WC+[\/:])*)/.source.replace("WC", "[^\\[\\]\\.:\\/]"), Qa = /(WCOD+)?/.source.replace("WCOD", za), Ga = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", "[^\\[\\]\\.:\\/]"), ja = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", "[^\\[\\]\\.:\\/]"), Ua = new RegExp("^" + Fa + Qa + Ga + ja + "$"), Va = ["material", "materials", "bones"]; class Ya { constructor(e, t, n) { this.path = t, this.parsedPath = n || Ya.parseTrackName(t), this.node = Ya.findNode(e, this.parsedPath.nodeName) || e, this.rootNode = e, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound } static create(e, t, n) { return e && e.isAnimationObjectGroup ? new Ya.Composite(e, t, n) : new Ya(e, t, n) } static sanitizeNodeName(e) { return e.replace(/\s/g, "_").replace(Ha, "") } static parseTrackName(e) { const t = Ua.exec(e); if (!t) throw new Error("PropertyBinding: Cannot parse trackName: " + e); const n = { nodeName: t[2], objectName: t[3], objectIndex: t[4], propertyName: t[5], propertyIndex: t[6] }, i = n.nodeName && n.nodeName.lastIndexOf("."); if (void 0 !== i && -1 !== i) { const e = n.nodeName.substring(i + 1); -1 !== Va.indexOf(e) && (n.nodeName = n.nodeName.substring(0, i), n.objectName = e) } if (null === n.propertyName || 0 === n.propertyName.length) throw new Error("PropertyBinding: can not parse propertyName from trackName: " + e); return n } static findNode(e, t) { if (!t || "" === t || "." === t || -1 === t || t === e.name || t === e.uuid) return e; if (e.skeleton) { const n = e.skeleton.getBoneByName(t); if (void 0 !== n) return n } if (e.children) { const n = function (e) { for (let i = 0; i < e.length; i++) { const r = e[i]; if (r.name === t || r.uuid === t) return r; const s = n(r.children); if (s) return s } return null }, i = n(e.children); if (i) return i } return null } _getValue_unavailable() { } _setValue_unavailable() { } _getValue_direct(e, t) { e[t] = this.node[this.propertyName] } _getValue_array(e, t) { const n = this.resolvedProperty; for (let i = 0, r = n.length; i !== r; ++i)e[t++] = n[i] } _getValue_arrayElement(e, t) { e[t] = this.resolvedProperty[this.propertyIndex] } _getValue_toArray(e, t) { this.resolvedProperty.toArray(e, t) } _setValue_direct(e, t) { this.targetObject[this.propertyName] = e[t] } _setValue_direct_setNeedsUpdate(e, t) { this.targetObject[this.propertyName] = e[t], this.targetObject.needsUpdate = !0 } _setValue_direct_setMatrixWorldNeedsUpdate(e, t) { this.targetObject[this.propertyName] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0 } _setValue_array(e, t) { const n = this.resolvedProperty; for (let i = 0, r = n.length; i !== r; ++i)n[i] = e[t++] } _setValue_array_setNeedsUpdate(e, t) { const n = this.resolvedProperty; for (let i = 0, r = n.length; i !== r; ++i)n[i] = e[t++]; this.targetObject.needsUpdate = !0 } _setValue_array_setMatrixWorldNeedsUpdate(e, t) { const n = this.resolvedProperty; for (let i = 0, r = n.length; i !== r; ++i)n[i] = e[t++]; this.targetObject.matrixWorldNeedsUpdate = !0 } _setValue_arrayElement(e, t) { this.resolvedProperty[this.propertyIndex] = e[t] } _setValue_arrayElement_setNeedsUpdate(e, t) { this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.needsUpdate = !0 } _setValue_arrayElement_setMatrixWorldNeedsUpdate(e, t) { this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0 } _setValue_fromArray(e, t) { this.resolvedProperty.fromArray(e, t) } _setValue_fromArray_setNeedsUpdate(e, t) { this.resolvedProperty.fromArray(e, t), this.targetObject.needsUpdate = !0 } _setValue_fromArray_setMatrixWorldNeedsUpdate(e, t) { this.resolvedProperty.fromArray(e, t), this.targetObject.matrixWorldNeedsUpdate = !0 } _getValue_unbound(e, t) { this.bind(), this.getValue(e, t) } _setValue_unbound(e, t) { this.bind(), this.setValue(e, t) } bind() { let e = this.node; const t = this.parsedPath, n = t.objectName, i = t.propertyName; let r = t.propertyIndex; if (e || (e = Ya.findNode(this.rootNode, t.nodeName) || this.rootNode, this.node = e), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !e) return void console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found."); if (n) { let i = t.objectIndex; switch (n) { case "materials": if (!e.material) return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this); if (!e.material.materials) return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this); e = e.material.materials; break; case "bones": if (!e.skeleton) return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this); e = e.skeleton.bones; for (let t = 0; t < e.length; t++)if (e[t].name === i) { i = t; break } break; default: if (void 0 === e[n]) return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this); e = e[n] }if (void 0 !== i) { if (void 0 === e[i]) return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, e); e = e[i] } } const s = e[i]; if (void 0 === s) { const n = t.nodeName; return void console.error("THREE.PropertyBinding: Trying to update property for track: " + n + "." + i + " but it wasn't found.", e) } let o = this.Versioning.None; this.targetObject = e, void 0 !== e.needsUpdate ? o = this.Versioning.NeedsUpdate : void 0 !== e.matrixWorldNeedsUpdate && (o = this.Versioning.MatrixWorldNeedsUpdate); let a = this.BindingType.Direct; if (void 0 !== r) { if ("morphTargetInfluences" === i) { if (!e.geometry) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this); if (!e.geometry.isBufferGeometry) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.", this); if (!e.geometry.morphAttributes) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this); void 0 !== e.morphTargetDictionary[r] && (r = e.morphTargetDictionary[r]) } a = this.BindingType.ArrayElement, this.resolvedProperty = s, this.propertyIndex = r } else void 0 !== s.fromArray && void 0 !== s.toArray ? (a = this.BindingType.HasFromToArray, this.resolvedProperty = s) : Array.isArray(s) ? (a = this.BindingType.EntireArray, this.resolvedProperty = s) : this.propertyName = i; this.getValue = this.GetterByBindingType[a], this.setValue = this.SetterByBindingTypeAndVersioning[a][o] } unbind() { this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound } } Ya.Composite = class { constructor(e, t, n) { const i = n || Ya.parseTrackName(t); this._targetGroup = e, this._bindings = e.subscribe_(t, i) } getValue(e, t) { this.bind(); const n = this._targetGroup.nCachedObjects_, i = this._bindings[n]; void 0 !== i && i.getValue(e, t) } setValue(e, t) { const n = this._bindings; for (let i = this._targetGroup.nCachedObjects_, r = n.length; i !== r; ++i)n[i].setValue(e, t) } bind() { const e = this._bindings; for (let t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t)e[t].bind() } unbind() { const e = this._bindings; for (let t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t)e[t].unbind() } }, Ya.prototype.BindingType = { Direct: 0, EntireArray: 1, ArrayElement: 2, HasFromToArray: 3 }, Ya.prototype.Versioning = { None: 0, NeedsUpdate: 1, MatrixWorldNeedsUpdate: 2 }, Ya.prototype.GetterByBindingType = [Ya.prototype._getValue_direct, Ya.prototype._getValue_array, Ya.prototype._getValue_arrayElement, Ya.prototype._getValue_toArray], Ya.prototype.SetterByBindingTypeAndVersioning = [[Ya.prototype._setValue_direct, Ya.prototype._setValue_direct_setNeedsUpdate, Ya.prototype._setValue_direct_setMatrixWorldNeedsUpdate], [Ya.prototype._setValue_array, Ya.prototype._setValue_array_setNeedsUpdate, Ya.prototype._setValue_array_setMatrixWorldNeedsUpdate], [Ya.prototype._setValue_arrayElement, Ya.prototype._setValue_arrayElement_setNeedsUpdate, Ya.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate], [Ya.prototype._setValue_fromArray, Ya.prototype._setValue_fromArray_setNeedsUpdate, Ya.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]]; (class { constructor() { this.uuid = f(), this._objects = Array.prototype.slice.call(arguments), this.nCachedObjects_ = 0; const e = {}; this._indicesByUUID = e; for (let t = 0, n = arguments.length; t !== n; ++t)e[arguments[t].uuid] = t; this._paths = [], this._parsedPaths = [], this._bindings = [], this._bindingsIndicesByPath = {}; const t = this; this.stats = { objects: { get total() { return t._objects.length }, get inUse() { return this.total - t.nCachedObjects_ } }, get bindingsPerObject() { return t._bindings.length } } } add() { const e = this._objects, t = this._indicesByUUID, n = this._paths, i = this._parsedPaths, r = this._bindings, s = r.length; let o = void 0, a = e.length, l = this.nCachedObjects_; for (let c = 0, A = arguments.length; c !== A; ++c) { const A = arguments[c], u = A.uuid; let h = t[u]; if (void 0 === h) { h = a++, t[u] = h, e.push(A); for (let e = 0, t = s; e !== t; ++e)r[e].push(new Ya(A, n[e], i[e])) } else if (h < l) { o = e[h]; const a = --l, c = e[a]; t[c.uuid] = h, e[h] = c, t[u] = a, e[a] = A; for (let e = 0, t = s; e !== t; ++e) { const t = r[e], s = t[a]; let o = t[h]; t[h] = s, void 0 === o && (o = new Ya(A, n[e], i[e])), t[a] = o } } else e[h] !== o && console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.") } this.nCachedObjects_ = l } remove() { const e = this._objects, t = this._indicesByUUID, n = this._bindings, i = n.length; let r = this.nCachedObjects_; for (let s = 0, o = arguments.length; s !== o; ++s) { const o = arguments[s], a = o.uuid, l = t[a]; if (void 0 !== l && l >= r) { const s = r++, c = e[s]; t[c.uuid] = l, e[l] = c, t[a] = s, e[s] = o; for (let e = 0, t = i; e !== t; ++e) { const t = n[e], i = t[s], r = t[l]; t[l] = i, t[s] = r } } } this.nCachedObjects_ = r } uncache() { const e = this._objects, t = this._indicesByUUID, n = this._bindings, i = n.length; let r = this.nCachedObjects_, s = e.length; for (let o = 0, a = arguments.length; o !== a; ++o) { const a = arguments[o].uuid, l = t[a]; if (void 0 !== l) if (delete t[a], l < r) { const o = --r, a = e[o], c = --s, A = e[c]; t[a.uuid] = l, e[l] = a, t[A.uuid] = o, e[o] = A, e.pop(); for (let e = 0, t = i; e !== t; ++e) { const t = n[e], i = t[o], r = t[c]; t[l] = i, t[o] = r, t.pop() } } else { const r = --s, o = e[r]; r > 0 && (t[o.uuid] = l), e[l] = o, e.pop(); for (let e = 0, t = i; e !== t; ++e) { const t = n[e]; t[l] = t[r], t.pop() } } } this.nCachedObjects_ = r } subscribe_(e, t) { const n = this._bindingsIndicesByPath; let i = n[e]; const r = this._bindings; if (void 0 !== i) return r[i]; const s = this._paths, o = this._parsedPaths, a = this._objects, l = a.length, c = this.nCachedObjects_, A = new Array(l); i = r.length, n[e] = i, s.push(e), o.push(t), r.push(A); for (let n = c, i = a.length; n !== i; ++n) { const i = a[n]; A[n] = new Ya(i, e, t) } return A } unsubscribe_(e) { const t = this._bindingsIndicesByPath, n = t[e]; if (void 0 !== n) { const i = this._paths, r = this._parsedPaths, s = this._bindings, o = s.length - 1, a = s[o]; t[e[o]] = n, s[n] = a, s.pop(), r[n] = r[o], r.pop(), i[n] = i[o], i.pop() } } }).prototype.isAnimationObjectGroup = !0; class Wa { constructor(e, t, n = null, i = t.blendMode) { this._mixer = e, this._clip = t, this._localRoot = n, this.blendMode = i; const r = t.tracks, s = r.length, o = new Array(s), a = { endingStart: 2400, endingEnd: 2400 }; for (let e = 0; e !== s; ++e) { const t = r[e].createInterpolant(null); o[e] = t, t.settings = a } this._interpolantSettings = a, this._interpolants = o, this._propertyBindings = new Array(s), this._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = 2201, this._loopCount = -1, this._startTime = null, this.time = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = 1 / 0, this.paused = !1, this.enabled = !0, this.clampWhenFinished = !1, this.zeroSlopeAtStart = !0, this.zeroSlopeAtEnd = !0 } play() { return this._mixer._activateAction(this), this } stop() { return this._mixer._deactivateAction(this), this.reset() } reset() { return this.paused = !1, this.enabled = !0, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping() } isRunning() { return this.enabled && !this.paused && 0 !== this.timeScale && null === this._startTime && this._mixer._isActiveAction(this) } isScheduled() { return this._mixer._isActiveAction(this) } startAt(e) { return this._startTime = e, this } setLoop(e, t) { return this.loop = e, this.repetitions = t, this } setEffectiveWeight(e) { return this.weight = e, this._effectiveWeight = this.enabled ? e : 0, this.stopFading() } getEffectiveWeight() { return this._effectiveWeight } fadeIn(e) { return this._scheduleFading(e, 0, 1) } fadeOut(e) { return this._scheduleFading(e, 1, 0) } crossFadeFrom(e, t, n) { if (e.fadeOut(t), this.fadeIn(t), n) { const n = this._clip.duration, i = e._clip.duration, r = i / n, s = n / i; e.warp(1, r, t), this.warp(s, 1, t) } return this } crossFadeTo(e, t, n) { return e.crossFadeFrom(this, t, n) } stopFading() { const e = this._weightInterpolant; return null !== e && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this } setEffectiveTimeScale(e) { return this.timeScale = e, this._effectiveTimeScale = this.paused ? 0 : e, this.stopWarping() } getEffectiveTimeScale() { return this._effectiveTimeScale } setDuration(e) { return this.timeScale = this._clip.duration / e, this.stopWarping() } syncWith(e) { return this.time = e.time, this.timeScale = e.timeScale, this.stopWarping() } halt(e) { return this.warp(this._effectiveTimeScale, 0, e) } warp(e, t, n) { const i = this._mixer, r = i.time, s = this.timeScale; let o = this._timeScaleInterpolant; null === o && (o = i._lendControlInterpolant(), this._timeScaleInterpolant = o); const a = o.parameterPositions, l = o.sampleValues; return a[0] = r, a[1] = r + n, l[0] = e / s, l[1] = t / s, this } stopWarping() { const e = this._timeScaleInterpolant; return null !== e && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this } getMixer() { return this._mixer } getClip() { return this._clip } getRoot() { return this._localRoot || this._mixer._root } _update(e, t, n, i) { if (!this.enabled) return void this._updateWeight(e); const r = this._startTime; if (null !== r) { const i = (e - r) * n; if (i < 0 || 0 === n) return; this._startTime = null, t = n * i } t *= this._updateTimeScale(e); const s = this._updateTime(t), o = this._updateWeight(e); if (o > 0) { const e = this._interpolants, t = this._propertyBindings; switch (this.blendMode) { case 2501: for (let n = 0, i = e.length; n !== i; ++n)e[n].evaluate(s), t[n].accumulateAdditive(o); break; case 2500: default: for (let n = 0, r = e.length; n !== r; ++n)e[n].evaluate(s), t[n].accumulate(i, o) } } } _updateWeight(e) { let t = 0; if (this.enabled) { t = this.weight; const n = this._weightInterpolant; if (null !== n) { const i = n.evaluate(e)[0]; t *= i, e > n.parameterPositions[1] && (this.stopFading(), 0 === i && (this.enabled = !1)) } } return this._effectiveWeight = t, t } _updateTimeScale(e) { let t = 0; if (!this.paused) { t = this.timeScale; const n = this._timeScaleInterpolant; if (null !== n) { t *= n.evaluate(e)[0], e > n.parameterPositions[1] && (this.stopWarping(), 0 === t ? this.paused = !0 : this.timeScale = t) } } return this._effectiveTimeScale = t, t } _updateTime(e) { const t = this._clip.duration, n = this.loop; let i = this.time + e, r = this._loopCount; const s = 2202 === n; if (0 === e) return -1 === r ? i : s && 1 == (1 & r) ? t - i : i; if (2200 === n) { -1 === r && (this._loopCount = 0, this._setEndings(!0, !0, !1)); e: { if (i >= t) i = t; else { if (!(i < 0)) { this.time = i; break e } i = 0 } this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, this.time = i, this._mixer.dispatchEvent({ type: "finished", action: this, direction: e < 0 ? -1 : 1 }) } } else { if (-1 === r && (e >= 0 ? (r = 0, this._setEndings(!0, 0 === this.repetitions, s)) : this._setEndings(0 === this.repetitions, !0, s)), i >= t || i < 0) { const n = Math.floor(i / t); i -= t * n, r += Math.abs(n); const o = this.repetitions - r; if (o <= 0) this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, i = e > 0 ? t : 0, this.time = i, this._mixer.dispatchEvent({ type: "finished", action: this, direction: e > 0 ? 1 : -1 }); else { if (1 === o) { const t = e < 0; this._setEndings(t, !t, s) } else this._setEndings(!1, !1, s); this._loopCount = r, this.time = i, this._mixer.dispatchEvent({ type: "loop", action: this, loopDelta: n }) } } else this.time = i; if (s && 1 == (1 & r)) return t - i } return i } _setEndings(e, t, n) { const i = this._interpolantSettings; n ? (i.endingStart = 2401, i.endingEnd = 2401) : (i.endingStart = e ? this.zeroSlopeAtStart ? 2401 : 2400 : 2402, i.endingEnd = t ? this.zeroSlopeAtEnd ? 2401 : 2400 : 2402) } _scheduleFading(e, t, n) { const i = this._mixer, r = i.time; let s = this._weightInterpolant; null === s && (s = i._lendControlInterpolant(), this._weightInterpolant = s); const o = s.parameterPositions, a = s.sampleValues; return o[0] = r, a[0] = t, o[1] = r + e, a[1] = n, this } } class Xa extends A { constructor(e) { super(), this._root = e, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, this.timeScale = 1 } _bindAction(e, t) { const n = e._localRoot || this._root, i = e._clip.tracks, r = i.length, s = e._propertyBindings, o = e._interpolants, a = n.uuid, l = this._bindingsByRootAndName; let c = l[a]; void 0 === c && (c = {}, l[a] = c); for (let e = 0; e !== r; ++e) { const r = i[e], l = r.name; let A = c[l]; if (void 0 !== A) s[e] = A; else { if (A = s[e], void 0 !== A) { null === A._cacheIndex && (++A.referenceCount, this._addInactiveBinding(A, a, l)); continue } const i = t && t._propertyBindings[e].binding.parsedPath; A = new ka(Ya.create(n, l, i), r.ValueTypeName, r.getValueSize()), ++A.referenceCount, this._addInactiveBinding(A, a, l), s[e] = A } o[e].resultBuffer = A.buffer } } _activateAction(e) { if (!this._isActiveAction(e)) { if (null === e._cacheIndex) { const t = (e._localRoot || this._root).uuid, n = e._clip.uuid, i = this._actionsByClip[n]; this._bindAction(e, i && i.knownActions[0]), this._addInactiveAction(e, n, t) } const t = e._propertyBindings; for (let e = 0, n = t.length; e !== n; ++e) { const n = t[e]; 0 == n.useCount++ && (this._lendBinding(n), n.saveOriginalState()) } this._lendAction(e) } } _deactivateAction(e) { if (this._isActiveAction(e)) { const t = e._propertyBindings; for (let e = 0, n = t.length; e !== n; ++e) { const n = t[e]; 0 == --n.useCount && (n.restoreOriginalState(), this._takeBackBinding(n)) } this._takeBackAction(e) } } _initMemoryManager() { this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0; const e = this; this.stats = { actions: { get total() { return e._actions.length }, get inUse() { return e._nActiveActions } }, bindings: { get total() { return e._bindings.length }, get inUse() { return e._nActiveBindings } }, controlInterpolants: { get total() { return e._controlInterpolants.length }, get inUse() { return e._nActiveControlInterpolants } } } } _isActiveAction(e) { const t = e._cacheIndex; return null !== t && t < this._nActiveActions } _addInactiveAction(e, t, n) { const i = this._actions, r = this._actionsByClip; let s = r[t]; if (void 0 === s) s = { knownActions: [e], actionByRoot: {} }, e._byClipCacheIndex = 0, r[t] = s; else { const t = s.knownActions; e._byClipCacheIndex = t.length, t.push(e) } e._cacheIndex = i.length, i.push(e), s.actionByRoot[n] = e } _removeInactiveAction(e) { const t = this._actions, n = t[t.length - 1], i = e._cacheIndex; n._cacheIndex = i, t[i] = n, t.pop(), e._cacheIndex = null; const r = e._clip.uuid, s = this._actionsByClip, o = s[r], a = o.knownActions, l = a[a.length - 1], c = e._byClipCacheIndex; l._byClipCacheIndex = c, a[c] = l, a.pop(), e._byClipCacheIndex = null; delete o.actionByRoot[(e._localRoot || this._root).uuid], 0 === a.length && delete s[r], this._removeInactiveBindingsForAction(e) } _removeInactiveBindingsForAction(e) { const t = e._propertyBindings; for (let e = 0, n = t.length; e !== n; ++e) { const n = t[e]; 0 == --n.referenceCount && this._removeInactiveBinding(n) } } _lendAction(e) { const t = this._actions, n = e._cacheIndex, i = this._nActiveActions++, r = t[i]; e._cacheIndex = i, t[i] = e, r._cacheIndex = n, t[n] = r } _takeBackAction(e) { const t = this._actions, n = e._cacheIndex, i = --this._nActiveActions, r = t[i]; e._cacheIndex = i, t[i] = e, r._cacheIndex = n, t[n] = r } _addInactiveBinding(e, t, n) { const i = this._bindingsByRootAndName, r = this._bindings; let s = i[t]; void 0 === s && (s = {}, i[t] = s), s[n] = e, e._cacheIndex = r.length, r.push(e) } _removeInactiveBinding(e) { const t = this._bindings, n = e.binding, i = n.rootNode.uuid, r = n.path, s = this._bindingsByRootAndName, o = s[i], a = t[t.length - 1], l = e._cacheIndex; a._cacheIndex = l, t[l] = a, t.pop(), delete o[r], 0 === Object.keys(o).length && delete s[i] } _lendBinding(e) { const t = this._bindings, n = e._cacheIndex, i = this._nActiveBindings++, r = t[i]; e._cacheIndex = i, t[i] = e, r._cacheIndex = n, t[n] = r } _takeBackBinding(e) { const t = this._bindings, n = e._cacheIndex, i = --this._nActiveBindings, r = t[i]; e._cacheIndex = i, t[i] = e, r._cacheIndex = n, t[n] = r } _lendControlInterpolant() { const e = this._controlInterpolants, t = this._nActiveControlInterpolants++; let n = e[t]; return void 0 === n && (n = new Lo(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer), n.__cacheIndex = t, e[t] = n), n } _takeBackControlInterpolant(e) { const t = this._controlInterpolants, n = e.__cacheIndex, i = --this._nActiveControlInterpolants, r = t[i]; e.__cacheIndex = i, t[i] = e, r.__cacheIndex = n, t[n] = r } clipAction(e, t, n) { const i = t || this._root, r = i.uuid; let s = "string" == typeof e ? Uo.findByName(i, e) : e; const o = null !== s ? s.uuid : e, a = this._actionsByClip[o]; let l = null; if (void 0 === n && (n = null !== s ? s.blendMode : 2500), void 0 !== a) { const e = a.actionByRoot[r]; if (void 0 !== e && e.blendMode === n) return e; l = a.knownActions[0], null === s && (s = l._clip) } if (null === s) return null; const c = new Wa(this, s, t, n); return this._bindAction(c, l), this._addInactiveAction(c, o, r), c } existingAction(e, t) { const n = t || this._root, i = n.uuid, r = "string" == typeof e ? Uo.findByName(n, e) : e, s = r ? r.uuid : e, o = this._actionsByClip[s]; return void 0 !== o && o.actionByRoot[i] || null } stopAllAction() { const e = this._actions; for (let t = this._nActiveActions - 1; t >= 0; --t)e[t].stop(); return this } update(e) { e *= this.timeScale; const t = this._actions, n = this._nActiveActions, i = this.time += e, r = Math.sign(e), s = this._accuIndex ^= 1; for (let o = 0; o !== n; ++o) { t[o]._update(i, e, r, s) } const o = this._bindings, a = this._nActiveBindings; for (let e = 0; e !== a; ++e)o[e].apply(s); return this } setTime(e) { this.time = 0; for (let e = 0; e < this._actions.length; e++)this._actions[e].time = 0; return this.update(e) } getRoot() { return this._root } uncacheClip(e) { const t = this._actions, n = e.uuid, i = this._actionsByClip, r = i[n]; if (void 0 !== r) { const e = r.knownActions; for (let n = 0, i = e.length; n !== i; ++n) { const i = e[n]; this._deactivateAction(i); const r = i._cacheIndex, s = t[t.length - 1]; i._cacheIndex = null, i._byClipCacheIndex = null, s._cacheIndex = r, t[r] = s, t.pop(), this._removeInactiveBindingsForAction(i) } delete i[n] } } uncacheRoot(e) { const t = e.uuid, n = this._actionsByClip; for (const e in n) { const i = n[e].actionByRoot[t]; void 0 !== i && (this._deactivateAction(i), this._removeInactiveAction(i)) } const i = this._bindingsByRootAndName[t]; if (void 0 !== i) for (const e in i) { const t = i[e]; t.restoreOriginalState(), this._removeInactiveBinding(t) } } uncacheAction(e, t) { const n = this.existingAction(e, t); null !== n && (this._deactivateAction(n), this._removeInactiveAction(n)) } } Xa.prototype._controlInterpolantsResultBuffer = new Float32Array(1); class Ja { constructor(e) { "string" == typeof e && (console.warn("THREE.Uniform: Type parameter is no longer needed."), e = arguments[1]), this.value = e } clone() { return new Ja(void 0 === this.value.clone ? this.value : this.value.clone()) } } (class extends wr { constructor(e, t, n = 1) { super(e, t), this.meshPerAttribute = n } copy(e) { return super.copy(e), this.meshPerAttribute = e.meshPerAttribute, this } clone(e) { const t = super.clone(e); return t.meshPerAttribute = this.meshPerAttribute, t } toJSON(e) { const t = super.toJSON(e); return t.isInstancedInterleavedBuffer = !0, t.meshPerAttribute = this.meshPerAttribute, t } }).prototype.isInstancedInterleavedBuffer = !0; (class { constructor(e, t, n, i, r) { this.buffer = e, this.type = t, this.itemSize = n, this.elementSize = i, this.count = r, this.version = 0 } set needsUpdate(e) { !0 === e && this.version++ } setBuffer(e) { return this.buffer = e, this } setType(e, t) { return this.type = e, this.elementSize = t, this } setItemSize(e) { return this.itemSize = e, this } setCount(e) { return this.count = e, this } }).prototype.isGLBufferAttribute = !0; class Ka { constructor(e = 1, t = 0, n = 0) { return this.radius = e, this.phi = t, this.theta = n, this } set(e, t, n) { return this.radius = e, this.phi = t, this.theta = n, this } copy(e) { return this.radius = e.radius, this.phi = e.phi, this.theta = e.theta, this } makeSafe() { return this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi)), this } setFromVector3(e) { return this.setFromCartesianCoords(e.x, e.y, e.z) } setFromCartesianCoords(e, t, n) { return this.radius = Math.sqrt(e * e + t * t + n * n), 0 === this.radius ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(e, n), this.phi = Math.acos(g(t / this.radius, -1, 1))), this } clone() { return (new this.constructor).copy(this) } } const Za = new b; class qa { constructor(e = new b(1 / 0, 1 / 0), t = new b(-1 / 0, -1 / 0)) { this.min = e, this.max = t } set(e, t) { return this.min.copy(e), this.max.copy(t), this } setFromPoints(e) { this.makeEmpty(); for (let t = 0, n = e.length; t < n; t++)this.expandByPoint(e[t]); return this } setFromCenterAndSize(e, t) { const n = Za.copy(t).multiplyScalar(.5); return this.min.copy(e).sub(n), this.max.copy(e).add(n), this } clone() { return (new this.constructor).copy(this) } copy(e) { return this.min.copy(e.min), this.max.copy(e.max), this } makeEmpty() { return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -1 / 0, this } isEmpty() { return this.max.x < this.min.x || this.max.y < this.min.y } getCenter(e) { return this.isEmpty() ? e.set(0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5) } getSize(e) { return this.isEmpty() ? e.set(0, 0) : e.subVectors(this.max, this.min) } expandByPoint(e) { return this.min.min(e), this.max.max(e), this } expandByVector(e) { return this.min.sub(e), this.max.add(e), this } expandByScalar(e) { return this.min.addScalar(-e), this.max.addScalar(e), this } containsPoint(e) { return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y) } containsBox(e) { return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y } getParameter(e, t) { return t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y)) } intersectsBox(e) { return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y) } clampPoint(e, t) { return t.copy(e).clamp(this.min, this.max) } distanceToPoint(e) { return Za.copy(e).clamp(this.min, this.max).sub(e).length() } intersect(e) { return this.min.max(e.min), this.max.min(e.max), this } union(e) { return this.min.min(e.min), this.max.max(e.max), this } translate(e) { return this.min.add(e), this.max.add(e), this } equals(e) { return e.min.equals(this.min) && e.max.equals(this.max) } } qa.prototype.isBox2 = !0; const _a = new O, $a = new O; (class extends ke { constructor(e) { super(), this.material = e, this.render = function () { }, this.hasPositions = !1, this.hasNormals = !1, this.hasColors = !1, this.hasUvs = !1, this.positionArray = null, this.normalArray = null, this.colorArray = null, this.uvArray = null, this.count = 0 } }).prototype.isImmediateRenderObject = !0; const el = new O, tl = new ue, nl = new ue; const il = new Float32Array(1); new Int32Array(il.buffer); Math.pow(2, 8); const rl = [.125, .215, .35, .446, .526, .582], sl = 5 + rl.length, ol = new it({ side: 1, depthWrite: !1, depthTest: !1 }), { _lodPlanes: al, _sizeLods: ll, _sigmas: cl } = (new kt(new zt, ol), Al()); Math.sqrt(5); function Al() { const e = [], t = [], n = []; let i = 8; for (let r = 0; r < sl; r++) { const s = Math.pow(2, i); t.push(s); let o = 1 / s; r > 4 ? o = rl[r - 8 + 4 - 1] : 0 == r && (o = 0), n.push(o); const a = 1 / (s - 1), l = -a / 2, c = 1 + a / 2, A = [l, l, c, l, c, c, l, l, c, c, l, c], u = 6, h = 6, d = 3, p = 2, f = 1, g = new Float32Array(d * h * u), m = new Float32Array(p * h * u), v = new Float32Array(f * h * u); for (let e = 0; e < u; e++) { const t = e % 3 * 2 / 3 - 1, n = e > 2 ? 0 : -1, i = [t, n, 0, t + 2 / 3, n, 0, t + 2 / 3, n + 1, 0, t, n, 0, t + 2 / 3, n + 1, 0, t, n + 1, 0]; g.set(i, d * h * e), m.set(A, p * h * e); const r = [e, e, e, e, e, e]; v.set(r, f * h * e) } const y = new vt; y.setAttribute("position", new ot(g, d)), y.setAttribute("uv", new ot(m, p)), y.setAttribute("faceIndex", new ot(v, f)), e.push(y), i > 4 && i-- } return { _lodPlanes: e, _sizeLods: t, _sigmas: n } } Cs.create = function (e, t) { return console.log("THREE.Curve.create() has been deprecated"), e.prototype = Object.create(Cs.prototype), e.prototype.constructor = e, e.prototype.getPoint = t, e }, ta.prototype.fromPoints = function (e) { return console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints()."), this.setFromPoints(e) }, class extends As { constructor(e = 10, t = 10, n = 4473924, i = 8947848) { n = new nt(n), i = new nt(i); const r = t / 2, s = e / t, o = e / 2, a = [], l = []; for (let e = 0, c = 0, A = -o; e <= t; e++, A += s) { a.push(-o, 0, A, o, 0, A), a.push(A, 0, -o, A, 0, o); const t = e === r ? n : i; t.toArray(l, c), c += 3, t.toArray(l, c), c += 3, t.toArray(l, c), c += 3, t.toArray(l, c), c += 3 } const c = new vt; c.setAttribute("position", new ct(a, 3)), c.setAttribute("color", new ct(l, 3)); super(c, new ts({ vertexColors: !0, toneMapped: !1 })), this.type = "GridHelper" } }.prototype.setColors = function () { console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.") }, class extends As { constructor(e) { const t = function e(t) { const n = []; t && t.isBone && n.push(t); for (let i = 0; i < t.children.length; i++)n.push.apply(n, e(t.children[i])); return n }(e), n = new vt, i = [], r = [], s = new nt(0, 0, 1), o = new nt(0, 1, 0); for (let e = 0; e < t.length; e++) { const n = t[e]; n.parent && n.parent.isBone && (i.push(0, 0, 0), i.push(0, 0, 0), r.push(s.r, s.g, s.b), r.push(o.r, o.g, o.b)) } n.setAttribute("position", new ct(i, 3)), n.setAttribute("color", new ct(r, 3)); super(n, new ts({ vertexColors: !0, depthTest: !1, depthWrite: !1, toneMapped: !1, transparent: !0 })), this.type = "SkeletonHelper", this.isSkeletonHelper = !0, this.root = e, this.bones = t, this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1 } updateMatrixWorld(e) { const t = this.bones, n = this.geometry, i = n.getAttribute("position"); nl.copy(this.root.matrixWorld).invert(); for (let e = 0, n = 0; e < t.length; e++) { const r = t[e]; r.parent && r.parent.isBone && (tl.multiplyMatrices(nl, r.matrixWorld), el.setFromMatrixPosition(tl), i.setXYZ(n, el.x, el.y, el.z), tl.multiplyMatrices(nl, r.parent.matrixWorld), el.setFromMatrixPosition(tl), i.setXYZ(n + 1, el.x, el.y, el.z), n += 2) } n.getAttribute("position").needsUpdate = !0, super.updateMatrixWorld(e) } }.prototype.update = function () { console.error("THREE.SkeletonHelper: update() no longer needs to be called.") }, Jo.prototype.extractUrlBase = function (e) { return console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."), ba.extractUrlBase(e) }, Jo.Handlers = { add: function () { console.error("THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.") }, get: function () { console.error("THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.") } }, qa.prototype.center = function (e) { return console.warn("THREE.Box2: .center() has been renamed to .getCenter()."), this.getCenter(e) }, qa.prototype.empty = function () { return console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."), this.isEmpty() }, qa.prototype.isIntersectionBox = function (e) { return console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(e) }, qa.prototype.size = function (e) { return console.warn("THREE.Box2: .size() has been renamed to .getSize()."), this.getSize(e) }, H.prototype.center = function (e) { return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."), this.getCenter(e) }, H.prototype.empty = function () { return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."), this.isEmpty() }, H.prototype.isIntersectionBox = function (e) { return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(e) }, H.prototype.isIntersectionSphere = function (e) { return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(e) }, H.prototype.size = function (e) { return console.warn("THREE.Box3: .size() has been renamed to .getSize()."), this.getSize(e) }, ne.prototype.empty = function () { return console.warn("THREE.Sphere: .empty() has been renamed to .isEmpty()."), this.isEmpty() }, en.prototype.setFromMatrix = function (e) { return console.warn("THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix()."), this.setFromProjectionMatrix(e) }, class { constructor(e = new O, t = new O) { this.start = e, this.end = t } set(e, t) { return this.start.copy(e), this.end.copy(t), this } copy(e) { return this.start.copy(e.start), this.end.copy(e.end), this } getCenter(e) { return e.addVectors(this.start, this.end).multiplyScalar(.5) } delta(e) { return e.subVectors(this.end, this.start) } distanceSq() { return this.start.distanceToSquared(this.end) } distance() { return this.start.distanceTo(this.end) } at(e, t) { return this.delta(t).multiplyScalar(e).add(this.start) } closestPointToPointParameter(e, t) { _a.subVectors(e, this.start), $a.subVectors(this.end, this.start); const n = $a.dot($a); let i = $a.dot(_a) / n; return t && (i = g(i, 0, 1)), i } closestPointToPoint(e, t, n) { const i = this.closestPointToPointParameter(e, t); return this.delta(n).multiplyScalar(i).add(this.start) } applyMatrix4(e) { return this.start.applyMatrix4(e), this.end.applyMatrix4(e), this } equals(e) { return e.start.equals(this.start) && e.end.equals(this.end) } clone() { return (new this.constructor).copy(this) } }.prototype.center = function (e) { return console.warn("THREE.Line3: .center() has been renamed to .getCenter()."), this.getCenter(e) }, M.prototype.flattenToArrayOffset = function (e, t) { return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(e, t) }, M.prototype.multiplyVector3 = function (e) { return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."), e.applyMatrix3(this) }, M.prototype.multiplyVector3Array = function () { console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.") }, M.prototype.applyToBufferAttribute = function (e) { return console.warn("THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead."), e.applyMatrix3(this) }, M.prototype.applyToVector3Array = function () { console.error("THREE.Matrix3: .applyToVector3Array() has been removed.") }, M.prototype.getInverse = function (e) { return console.warn("THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."), this.copy(e).invert() }, ue.prototype.extractPosition = function (e) { return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."), this.copyPosition(e) }, ue.prototype.flattenToArrayOffset = function (e, t) { return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(e, t) }, ue.prototype.getPosition = function () { return console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."), (new O).setFromMatrixColumn(this, 3) }, ue.prototype.setRotationFromQuaternion = function (e) { return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."), this.makeRotationFromQuaternion(e) }, ue.prototype.multiplyToArray = function () { console.warn("THREE.Matrix4: .multiplyToArray() has been removed.") }, ue.prototype.multiplyVector3 = function (e) { return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."), e.applyMatrix4(this) }, ue.prototype.multiplyVector4 = function (e) { return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."), e.applyMatrix4(this) }, ue.prototype.multiplyVector3Array = function () { console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.") }, ue.prototype.rotateAxis = function (e) { console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."), e.transformDirection(this) }, ue.prototype.crossVector = function (e) { return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."), e.applyMatrix4(this) }, ue.prototype.translate = function () { console.error("THREE.Matrix4: .translate() has been removed.") }, ue.prototype.rotateX = function () { console.error("THREE.Matrix4: .rotateX() has been removed.") }, ue.prototype.rotateY = function () { console.error("THREE.Matrix4: .rotateY() has been removed.") }, ue.prototype.rotateZ = function () { console.error("THREE.Matrix4: .rotateZ() has been removed.") }, ue.prototype.rotateByAxis = function () { console.error("THREE.Matrix4: .rotateByAxis() has been removed.") }, ue.prototype.applyToBufferAttribute = function (e) { return console.warn("THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead."), e.applyMatrix4(this) }, ue.prototype.applyToVector3Array = function () { console.error("THREE.Matrix4: .applyToVector3Array() has been removed.") }, ue.prototype.makeFrustum = function (e, t, n, i, r, s) { return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."), this.makePerspective(e, t, i, n, r, s) }, ue.prototype.getInverse = function (e) { return console.warn("THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."), this.copy(e).invert() }, qt.prototype.isIntersectionLine = function (e) { return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."), this.intersectsLine(e) }, L.prototype.multiplyVector3 = function (e) { return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."), e.applyQuaternion(this) }, L.prototype.inverse = function () { return console.warn("THREE.Quaternion: .inverse() has been renamed to invert()."), this.invert() }, Ae.prototype.isIntersectionBox = function (e) { return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(e) }, Ae.prototype.isIntersectionPlane = function (e) { return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."), this.intersectsPlane(e) }, Ae.prototype.isIntersectionSphere = function (e) { return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(e) }, Xe.prototype.area = function () { return console.warn("THREE.Triangle: .area() has been renamed to .getArea()."), this.getArea() }, Xe.prototype.barycoordFromPoint = function (e, t) { return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), this.getBarycoord(e, t) }, Xe.prototype.midpoint = function (e) { return console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."), this.getMidpoint(e) }, Xe.prototypenormal = function (e) { return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), this.getNormal(e) }, Xe.prototype.plane = function (e) { return console.warn("THREE.Triangle: .plane() has been renamed to .getPlane()."), this.getPlane(e) }, Xe.barycoordFromPoint = function (e, t, n, i, r) { return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), Xe.getBarycoord(e, t, n, i, r) }, Xe.normal = function (e, t, n, i) { return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), Xe.getNormal(e, t, n, i) }, na.prototype.extractAllPoints = function (e) { return console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."), this.extractPoints(e) }, na.prototype.extrude = function (e) { return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."), new go(this, e) }, na.prototype.makeGeometry = function (e) { return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."), new vo(this, e) }, b.prototype.fromAttribute = function (e, t, n) { return console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(e, t, n) }, b.prototype.distanceToManhattan = function (e) { return console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(e) }, b.prototype.lengthManhattan = function () { return console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength() }, O.prototype.setEulerFromRotationMatrix = function () { console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.") }, O.prototype.setEulerFromQuaternion = function () { console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.") }, O.prototype.getPositionFromMatrix = function (e) { return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."), this.setFromMatrixPosition(e) }, O.prototype.getScaleFromMatrix = function (e) { return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."), this.setFromMatrixScale(e) }, O.prototype.getColumnFromMatrix = function (e, t) { return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."), this.setFromMatrixColumn(t, e) }, O.prototype.applyProjection = function (e) { return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."), this.applyMatrix4(e) }, O.prototype.fromAttribute = function (e, t, n) { return console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(e, t, n) }, O.prototype.distanceToManhattan = function (e) { return console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(e) }, O.prototype.lengthManhattan = function () { return console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength() }, B.prototype.fromAttribute = function (e, t, n) { return console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(e, t, n) }, B.prototype.lengthManhattan = function () { return console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength() }, ke.prototype.getChildByName = function (e) { return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."), this.getObjectByName(e) }, ke.prototype.renderDepth = function () { console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.") }, ke.prototype.translate = function (e, t) { return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."), this.translateOnAxis(t, e) }, ke.prototype.getWorldRotation = function () { console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.") }, ke.prototype.applyMatrix = function (e) { return console.warn("THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4()."), this.applyMatrix4(e) }, Object.defineProperties(ke.prototype, { eulerOrder: { get: function () { return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order }, set: function (e) { console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order = e } }, useQuaternion: { get: function () { console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.") }, set: function () { console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.") } } }), kt.prototype.setDrawMode = function () { console.error("THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.") }, Object.defineProperties(kt.prototype, { drawMode: { get: function () { return console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode."), 0 }, set: function () { console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.") } } }), Vr.prototype.initBones = function () { console.error("THREE.SkinnedMesh: initBones() has been removed.") }, Vt.prototype.setLens = function (e, t) { console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."), void 0 !== t && (this.filmGauge = t), this.setFocalLength(e) }, Object.defineProperties(ia.prototype, { onlyShadow: { set: function () { console.warn("THREE.Light: .onlyShadow has been removed.") } }, shadowCameraFov: { set: function (e) { console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."), this.shadow.camera.fov = e } }, shadowCameraLeft: { set: function (e) { console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."), this.shadow.camera.left = e } }, shadowCameraRight: { set: function (e) { console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."), this.shadow.camera.right = e } }, shadowCameraTop: { set: function (e) { console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."), this.shadow.camera.top = e } }, shadowCameraBottom: { set: function (e) { console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."), this.shadow.camera.bottom = e } }, shadowCameraNear: { set: function (e) { console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."), this.shadow.camera.near = e } }, shadowCameraFar: { set: function (e) { console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."), this.shadow.camera.far = e } }, shadowCameraVisible: { set: function () { console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.") } }, shadowBias: { set: function (e) { console.warn("THREE.Light: .shadowBias is now .shadow.bias."), this.shadow.bias = e } }, shadowDarkness: { set: function () { console.warn("THREE.Light: .shadowDarkness has been removed.") } }, shadowMapWidth: { set: function (e) { console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."), this.shadow.mapSize.width = e } }, shadowMapHeight: { set: function (e) { console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."), this.shadow.mapSize.height = e } } }), Object.defineProperties(ot.prototype, { length: { get: function () { return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."), this.array.length } }, dynamic: { get: function () { return console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."), 35048 === this.usage }, set: function () { console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."), this.setUsage(35048) } } }), ot.prototype.setDynamic = function (e) { return console.warn("THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead."), this.setUsage(!0 === e ? 35048 : 35044), this }, ot.prototype.copyIndicesArray = function () { console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.") }, ot.prototype.setArray = function () { console.error("THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers") }, vt.prototype.addIndex = function (e) { console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."), this.setIndex(e) }, vt.prototype.addAttribute = function (e, t) { return console.warn("THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute()."), t && t.isBufferAttribute || t && t.isInterleavedBufferAttribute ? "index" === e ? (console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."), this.setIndex(t), this) : this.setAttribute(e, t) : (console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."), this.setAttribute(e, new ot(arguments[1], arguments[2]))) }, vt.prototype.addDrawCall = function (e, t, n) { void 0 !== n && console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."), console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."), this.addGroup(e, t) }, vt.prototype.clearDrawCalls = function () { console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."), this.clearGroups() }, vt.prototype.computeOffsets = function () { console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.") }, vt.prototype.removeAttribute = function (e) { return console.warn("THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute()."), this.deleteAttribute(e) }, vt.prototype.applyMatrix = function (e) { return console.warn("THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4()."), this.applyMatrix4(e) }, Object.defineProperties(vt.prototype, { drawcalls: { get: function () { return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."), this.groups } }, offsets: { get: function () { return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."), this.groups } } }), wr.prototype.setDynamic = function (e) { return console.warn("THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead."), this.setUsage(!0 === e ? 35048 : 35044), this }, wr.prototype.setArray = function () { console.error("THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers") }, go.prototype.getArrays = function () { console.error("THREE.ExtrudeGeometry: .getArrays() has been removed.") }, go.prototype.addShapeList = function () { console.error("THREE.ExtrudeGeometry: .addShapeList() has been removed.") }, go.prototype.addShape = function () { console.error("THREE.ExtrudeGeometry: .addShape() has been removed.") }, yr.prototype.dispose = function () { console.error("THREE.Scene: .dispose() has been removed.") }, Ja.prototype.onUpdate = function () { return console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."), this }, Object.defineProperties(Ke.prototype, { wrapAround: { get: function () { console.warn("THREE.Material: .wrapAround has been removed.") }, set: function () { console.warn("THREE.Material: .wrapAround has been removed.") } }, overdraw: { get: function () { console.warn("THREE.Material: .overdraw has been removed.") }, set: function () { console.warn("THREE.Material: .overdraw has been removed.") } }, wrapRGB: { get: function () { return console.warn("THREE.Material: .wrapRGB has been removed."), new nt } }, shading: { get: function () { console.error("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.") }, set: function (e) { console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = 1 === e } }, stencilMask: { get: function () { return console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead."), this.stencilFuncMask }, set: function (e) { console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead."), this.stencilFuncMask = e } } }), Object.defineProperties(jt.prototype, { derivatives: { get: function () { return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives }, set: function (e) { console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives = e } } }), gr.prototype.clearTarget = function (e, t, n, i) { console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."), this.setRenderTarget(e), this.clear(t, n, i) }, gr.prototype.animate = function (e) { console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."), this.setAnimationLoop(e) }, gr.prototype.getCurrentRenderTarget = function () { return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."), this.getRenderTarget() }, gr.prototype.getMaxAnisotropy = function () { return console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."), this.capabilities.getMaxAnisotropy() }, gr.prototype.getPrecision = function () { return console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."), this.capabilities.precision }, gr.prototype.resetGLState = function () { return console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset()."), this.state.reset() }, gr.prototype.supportsFloatTextures = function () { return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."), this.extensions.get("OES_texture_float") }, gr.prototype.supportsHalfFloatTextures = function () { return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."), this.extensions.get("OES_texture_half_float") }, gr.prototype.supportsStandardDerivatives = function () { return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."), this.extensions.get("OES_standard_derivatives") }, gr.prototype.supportsCompressedTextureS3TC = function () { return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."), this.extensions.get("WEBGL_compressed_texture_s3tc") }, gr.prototype.supportsCompressedTexturePVRTC = function () { return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."), this.extensions.get("WEBGL_compressed_texture_pvrtc") }, gr.prototype.supportsBlendMinMax = function () { return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."), this.extensions.get("EXT_blend_minmax") }, gr.prototype.supportsVertexTextures = function () { return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."), this.capabilities.vertexTextures }, gr.prototype.supportsInstancedArrays = function () { return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."), this.extensions.get("ANGLE_instanced_arrays") }, gr.prototype.enableScissorTest = function (e) { console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."), this.setScissorTest(e) }, gr.prototype.initMaterial = function () { console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.") }, gr.prototype.addPrePlugin = function () { console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.") }, gr.prototype.addPostPlugin = function () { console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.") }, gr.prototype.updateShadowMap = function () { console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.") }, gr.prototype.setFaceCulling = function () { console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.") }, gr.prototype.allocTextureUnit = function () { console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.") }, gr.prototype.setTexture = function () { console.warn("THREE.WebGLRenderer: .setTexture() has been removed.") }, gr.prototype.setTexture2D = function () { console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.") }, gr.prototype.setTextureCube = function () { console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.") }, gr.prototype.getActiveMipMapLevel = function () { return console.warn("THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel()."), this.getActiveMipmapLevel() }, Object.defineProperties(gr.prototype, { shadowMapEnabled: { get: function () { return this.shadowMap.enabled }, set: function (e) { console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."), this.shadowMap.enabled = e } }, shadowMapType: { get: function () { return this.shadowMap.type }, set: function (e) { console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."), this.shadowMap.type = e } }, shadowMapCullFace: { get: function () { console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.") }, set: function () { console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.") } }, context: { get: function () { return console.warn("THREE.WebGLRenderer: .context has been removed. Use .getContext() instead."), this.getContext() } }, vr: { get: function () { return console.warn("THREE.WebGLRenderer: .vr has been renamed to .xr"), this.xr } }, gammaInput: { get: function () { return console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."), !1 }, set: function () { console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.") } }, gammaOutput: { get: function () { return console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."), !1 }, set: function (e) { console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."), this.outputEncoding = !0 === e ? 3001 : 3e3 } }, toneMappingWhitePoint: { get: function () { return console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."), 1 }, set: function () { console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.") } } }), Object.defineProperties(or.prototype, { cullFace: { get: function () { console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.") }, set: function () { console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.") } }, renderReverseSided: { get: function () { console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.") }, set: function () { console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.") } }, renderSingleSided: { get: function () { console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.") }, set: function () { console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.") } } }), Object.defineProperties(D.prototype, { wrapS: { get: function () { return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS }, set: function (e) { console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS = e } }, wrapT: { get: function () { return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT }, set: function (e) { console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT = e } }, magFilter: { get: function () { return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter }, set: function (e) { console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter = e } }, minFilter: { get: function () { return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter }, set: function (e) { console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter = e } }, anisotropy: { get: function () { return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy }, set: function (e) { console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy = e } }, offset: { get: function () { return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset }, set: function (e) { console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset = e } }, repeat: { get: function () { return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat }, set: function (e) { console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat = e } }, format: { get: function () { return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format }, set: function (e) { console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format = e } }, type: { get: function () { return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type }, set: function (e) { console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type = e } }, generateMipmaps: { get: function () { return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps }, set: function (e) { console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps = e } } }), Na.prototype.load = function (e) { console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead."); const t = this; return (new Ra).load(e, (function (e) { t.setBuffer(e) })), this }, class { constructor(e, t = 2048) { this.analyser = e.context.createAnalyser(), this.analyser.fftSize = t, this.data = new Uint8Array(this.analyser.frequencyBinCount), e.getOutput().connect(this.analyser) } getFrequencyData() { return this.analyser.getByteFrequencyData(this.data), this.data } getAverageFrequency() { let e = 0; const t = this.getFrequencyData(); for (let n = 0; n < t.length; n++)e += t[n]; return e / t.length } }.prototype.getData = function () { return console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData()."), this.getFrequencyData() }, Yt.prototype.updateCubeMap = function (e, t) { return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."), this.update(e, t) }, Yt.prototype.clear = function (e, t, n, i) { return console.warn("THREE.CubeCamera: .clear() is now .renderTarget.clear()."), this.renderTarget.clear(e, t, n, i) }, E.crossOrigin = void 0, E.loadTexture = function (e, t, n, i) { console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead."); const r = new $o; r.setCrossOrigin(this.crossOrigin); const s = r.load(e, n, void 0, i); return t && (s.mapping = t), s }, E.loadTextureCube = function (e, t, n, i) { console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead."); const r = new _o; r.setCrossOrigin(this.crossOrigin); const s = r.load(e, n, void 0, i); return t && (s.mapping = t), s }, E.loadCompressedTexture = function () { console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.") }, E.loadCompressedTextureCube = function () { console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.") }; "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", { detail: { revision: "130" } })), "undefined" != typeof window && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = "130"); class ul extends Jo { constructor(e) { super(e), this.dracoLoader = null, this.ktx2Loader = null, this.meshoptDecoder = null, this.pluginCallbacks = [], this.register((function (e) { return new gl(e) })), this.register((function (e) { return new vl(e) })), this.register((function (e) { return new yl(e) })), this.register((function (e) { return new ml(e) })), this.register((function (e) { return new pl(e) })), this.register((function (e) { return new wl(e) })) } load(e, t, n, i) { const r = this; let s; s = "" !== this.resourcePath ? this.resourcePath : "" !== this.path ? this.path : ba.extractUrlBase(e), this.manager.itemStart(e); const o = function (t) { i ? i(t) : console.error(t), r.manager.itemError(e), r.manager.itemEnd(e) }, a = new Zo(this.manager); a.setPath(this.path), a.setResponseType("arraybuffer"), a.setRequestHeader(this.requestHeader), a.setWithCredentials(this.withCredentials), a.load(e, (function (n) { try { r.parse(n, s, (function (n) { t(n), r.manager.itemEnd(e) }), o) } catch (e) { o(e) } }), n, o) } setDRACOLoader(e) { return this.dracoLoader = e, this } setDDSLoader() { throw new Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".') } setKTX2Loader(e) { return this.ktx2Loader = e, this } setMeshoptDecoder(e) { return this.meshoptDecoder = e, this } register(e) { return -1 === this.pluginCallbacks.indexOf(e) && this.pluginCallbacks.push(e), this } unregister(e) { return -1 !== this.pluginCallbacks.indexOf(e) && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e), 1), this } parse(e, t, n, i) { let r; const s = {}, o = {}; if ("string" == typeof e) r = e; else { if (ba.decodeText(new Uint8Array(e, 0, 4)) === xl) { try { s[dl.KHR_BINARY_GLTF] = new Ml(e) } catch (e) { return void (i && i(e)) } r = s[dl.KHR_BINARY_GLTF].content } else r = ba.decodeText(new Uint8Array(e)) } const a = JSON.parse(r); if (void 0 === a.asset || a.asset.version[0] < 2) return void (i && i(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."))); const l = new tc(a, { path: t || this.resourcePath || "", crossOrigin: this.crossOrigin, requestHeader: this.requestHeader, manager: this.manager, ktx2Loader: this.ktx2Loader, meshoptDecoder: this.meshoptDecoder }); l.fileLoader.setRequestHeader(this.requestHeader); for (let e = 0; e < this.pluginCallbacks.length; e++) { const t = this.pluginCallbacks[e](l); o[t.name] = t, s[t.name] = !0 } if (a.extensionsUsed) for (let e = 0; e < a.extensionsUsed.length; ++e) { const t = a.extensionsUsed[e], n = a.extensionsRequired || []; switch (t) { case dl.KHR_MATERIALS_UNLIT: s[t] = new fl; break; case dl.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: s[t] = new Pl; break; case dl.KHR_DRACO_MESH_COMPRESSION: s[t] = new Il(a, this.dracoLoader); break; case dl.KHR_TEXTURE_TRANSFORM: s[t] = new El; break; case dl.KHR_MESH_QUANTIZATION: s[t] = new Sl; break; default: n.indexOf(t) >= 0 && void 0 === o[t] && console.warn('THREE.GLTFLoader: Unknown extension "' + t + '".') } } l.setExtensions(s), l.setPlugins(o), l.parse(n, i) } } function hl() { let e = {}; return { get: function (t) { return e[t] }, add: function (t, n) { e[t] = n }, remove: function (t) { delete e[t] }, removeAll: function () { e = {} } } } const dl = { KHR_BINARY_GLTF: "KHR_binary_glTF", KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression", KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual", KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat", KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: "KHR_materials_pbrSpecularGlossiness", KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission", KHR_MATERIALS_UNLIT: "KHR_materials_unlit", KHR_TEXTURE_BASISU: "KHR_texture_basisu", KHR_TEXTURE_TRANSFORM: "KHR_texture_transform", KHR_MESH_QUANTIZATION: "KHR_mesh_quantization", EXT_TEXTURE_WEBP: "EXT_texture_webp", EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression" }; class pl { constructor(e) { this.parser = e, this.name = dl.KHR_LIGHTS_PUNCTUAL, this.cache = { refs: {}, uses: {} } } _markDefs() { const e = this.parser, t = this.parser.json.nodes || []; for (let n = 0, i = t.length; n < i; n++) { const i = t[n]; i.extensions && i.extensions[this.name] && void 0 !== i.extensions[this.name].light && e._addNodeRef(this.cache, i.extensions[this.name].light) } } _loadLight(e) { const t = this.parser, n = "light:" + e; let i = t.cache.get(n); if (i) return i; const r = t.json, s = ((r.extensions && r.extensions[this.name] || {}).lights || [])[e]; let o; const a = new nt(16777215); void 0 !== s.color && a.fromArray(s.color); const l = void 0 !== s.range ? s.range : 0; switch (s.type) { case "directional": o = new va(a), o.target.position.set(0, 0, -1), o.add(o.target); break; case "point": o = new fa(a), o.distance = l; break; case "spot": o = new Aa(a), o.distance = l, s.spot = s.spot || {}, s.spot.innerConeAngle = void 0 !== s.spot.innerConeAngle ? s.spot.innerConeAngle : 0, s.spot.outerConeAngle = void 0 !== s.spot.outerConeAngle ? s.spot.outerConeAngle : Math.PI / 4, o.angle = s.spot.outerConeAngle, o.penumbra = 1 - s.spot.innerConeAngle / s.spot.outerConeAngle, o.target.position.set(0, 0, -1), o.add(o.target); break; default: throw new Error("THREE.GLTFLoader: Unexpected light type: " + s.type) }return o.position.set(0, 0, 0), o.decay = 2, void 0 !== s.intensity && (o.intensity = s.intensity), o.name = t.createUniqueName(s.name || "light_" + e), i = Promise.resolve(o), t.cache.add(n, i), i } createNodeAttachment(e) { const t = this, n = this.parser, i = n.json.nodes[e], r = (i.extensions && i.extensions[this.name] || {}).light; return void 0 === r ? null : this._loadLight(r).then((function (e) { return n._getNodeRef(t.cache, r, e) })) } } class fl { constructor() { this.name = dl.KHR_MATERIALS_UNLIT } getMaterialType() { return it } extendParams(e, t, n) { const i = []; e.color = new nt(1, 1, 1), e.opacity = 1; const r = t.pbrMetallicRoughness; if (r) { if (Array.isArray(r.baseColorFactor)) { const t = r.baseColorFactor; e.color.fromArray(t), e.opacity = t[3] } void 0 !== r.baseColorTexture && i.push(n.assignTexture(e, "map", r.baseColorTexture)) } return Promise.all(i) } } class gl { constructor(e) { this.parser = e, this.name = dl.KHR_MATERIALS_CLEARCOAT } getMaterialType(e) { const t = this.parser.json.materials[e]; return t.extensions && t.extensions[this.name] ? bo : null } extendMaterialParams(e, t) { const n = this.parser, i = n.json.materials[e]; if (!i.extensions || !i.extensions[this.name]) return Promise.resolve(); const r = [], s = i.extensions[this.name]; if (void 0 !== s.clearcoatFactor && (t.clearcoat = s.clearcoatFactor), void 0 !== s.clearcoatTexture && r.push(n.assignTexture(t, "clearcoatMap", s.clearcoatTexture)), void 0 !== s.clearcoatRoughnessFactor && (t.clearcoatRoughness = s.clearcoatRoughnessFactor), void 0 !== s.clearcoatRoughnessTexture && r.push(n.assignTexture(t, "clearcoatRoughnessMap", s.clearcoatRoughnessTexture)), void 0 !== s.clearcoatNormalTexture && (r.push(n.assignTexture(t, "clearcoatNormalMap", s.clearcoatNormalTexture)), void 0 !== s.clearcoatNormalTexture.scale)) { const e = s.clearcoatNormalTexture.scale; t.clearcoatNormalScale = new b(e, -e) } return Promise.all(r) } } class ml { constructor(e) { this.parser = e, this.name = dl.KHR_MATERIALS_TRANSMISSION } getMaterialType(e) { const t = this.parser.json.materials[e]; return t.extensions && t.extensions[this.name] ? bo : null } extendMaterialParams(e, t) { const n = this.parser, i = n.json.materials[e]; if (!i.extensions || !i.extensions[this.name]) return Promise.resolve(); const r = [], s = i.extensions[this.name]; return void 0 !== s.transmissionFactor && (t.transmission = s.transmissionFactor), void 0 !== s.transmissionTexture && r.push(n.assignTexture(t, "transmissionMap", s.transmissionTexture)), Promise.all(r) } } class vl { constructor(e) { this.parser = e, this.name = dl.KHR_TEXTURE_BASISU } loadTexture(e) { const t = this.parser, n = t.json, i = n.textures[e]; if (!i.extensions || !i.extensions[this.name]) return null; const r = i.extensions[this.name], s = n.images[r.source], o = t.options.ktx2Loader; if (!o) { if (n.extensionsRequired && n.extensionsRequired.indexOf(this.name) >= 0) throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures"); return null } return t.loadTextureImage(e, s, o) } } class yl { constructor(e) { this.parser = e, this.name = dl.EXT_TEXTURE_WEBP, this.isSupported = null } loadTexture(e) { const t = this.name, n = this.parser, i = n.json, r = i.textures[e]; if (!r.extensions || !r.extensions[t]) return null; const s = r.extensions[t], o = i.images[s.source]; let a = n.textureLoader; if (o.uri) { const e = n.options.manager.getHandler(o.uri); null !== e && (a = e) } return this.detectSupport().then((function (r) { if (r) return n.loadTextureImage(e, o, a); if (i.extensionsRequired && i.extensionsRequired.indexOf(t) >= 0) throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported."); return n.loadTexture(e) })) } detectSupport() { return this.isSupported || (this.isSupported = new Promise((function (e) { const t = new Image; t.src = "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA", t.onload = t.onerror = function () { e(1 === t.height) } }))), this.isSupported } } class wl { constructor(e) { this.name = dl.EXT_MESHOPT_COMPRESSION, this.parser = e } loadBufferView(e) { const t = this.parser.json, n = t.bufferViews[e]; if (n.extensions && n.extensions[this.name]) { const e = n.extensions[this.name], i = this.parser.getDependency("buffer", e.buffer), r = this.parser.options.meshoptDecoder; if (!r || !r.supported) { if (t.extensionsRequired && t.extensionsRequired.indexOf(this.name) >= 0) throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files"); return null } return Promise.all([i, r.ready]).then((function (t) { const n = e.byteOffset || 0, i = e.byteLength || 0, s = e.count, o = e.byteStride, a = new ArrayBuffer(s * o), l = new Uint8Array(t[0], n, i); return r.decodeGltfBuffer(new Uint8Array(a), s, o, l, e.mode, e.filter), a })) } return null } } const xl = "glTF", Cl = 1313821514, bl = 5130562; class Ml { constructor(e) { this.name = dl.KHR_BINARY_GLTF, this.content = null, this.body = null; const t = new DataView(e, 0, 12); if (this.header = { magic: ba.decodeText(new Uint8Array(e.slice(0, 4))), version: t.getUint32(4, !0), length: t.getUint32(8, !0) }, this.header.magic !== xl) throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header."); if (this.header.version < 2) throw new Error("THREE.GLTFLoader: Legacy binary file detected."); const n = this.header.length - 12, i = new DataView(e, 12); let r = 0; for (; r < n;) { const t = i.getUint32(r, !0); r += 4; const n = i.getUint32(r, !0); if (r += 4, n === Cl) { const n = new Uint8Array(e, 12 + r, t); this.content = ba.decodeText(n) } else if (n === bl) { const n = 12 + r; this.body = e.slice(n, n + t) } r += t } if (null === this.content) throw new Error("THREE.GLTFLoader: JSON content not found.") } } class Il { constructor(e, t) { if (!t) throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided."); this.name = dl.KHR_DRACO_MESH_COMPRESSION, this.json = e, this.dracoLoader = t, this.dracoLoader.preload() } decodePrimitive(e, t) { const n = this.json, i = this.dracoLoader, r = e.extensions[this.name].bufferView, s = e.extensions[this.name].attributes, o = {}, a = {}, l = {}; for (const e in s) { const t = jl[e] || e.toLowerCase(); o[t] = s[e] } for (const t in e.attributes) { const i = jl[t] || t.toLowerCase(); if (void 0 !== s[t]) { const r = n.accessors[e.attributes[t]], s = zl[r.componentType]; l[i] = s, a[i] = !0 === r.normalized } } return t.getDependency("bufferView", r).then((function (e) { return new Promise((function (t) { i.decodeDracoFile(e, (function (e) { for (const t in e.attributes) { const n = e.attributes[t], i = a[t]; void 0 !== i && (n.normalized = i) } t(e) }), o, l) })) })) } } class El { constructor() { this.name = dl.KHR_TEXTURE_TRANSFORM } extendTexture(e, t) { return void 0 !== t.texCoord && console.warn('THREE.GLTFLoader: Custom UV sets in "' + this.name + '" extension not yet supported.'), void 0 === t.offset && void 0 === t.rotation && void 0 === t.scale || (e = e.clone(), void 0 !== t.offset && e.offset.fromArray(t.offset), void 0 !== t.rotation && (e.rotation = t.rotation), void 0 !== t.scale && e.repeat.fromArray(t.scale), e.needsUpdate = !0), e } } class Tl extends Co { constructor(e) { super(), this.isGLTFSpecularGlossinessMaterial = !0; const t = ["#ifdef USE_SPECULARMAP", "\tuniform sampler2D specularMap;", "#endif"].join("\n"), n = ["#ifdef USE_GLOSSINESSMAP", "\tuniform sampler2D glossinessMap;", "#endif"].join("\n"), i = ["vec3 specularFactor = specular;", "#ifdef USE_SPECULARMAP", "\tvec4 texelSpecular = texture2D( specularMap, vUv );", "\ttexelSpecular = sRGBToLinear( texelSpecular );", "\t// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture", "\tspecularFactor *= texelSpecular.rgb;", "#endif"].join("\n"), r = ["float glossinessFactor = glossiness;", "#ifdef USE_GLOSSINESSMAP", "\tvec4 texelGlossiness = texture2D( glossinessMap, vUv );", "\t// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture", "\tglossinessFactor *= texelGlossiness.a;", "#endif"].join("\n"), s = ["PhysicalMaterial material;", "material.diffuseColor = diffuseColor.rgb * ( 1. - max( specularFactor.r, max( specularFactor.g, specularFactor.b ) ) );", "vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );", "float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );", "material.specularRoughness = max( 1.0 - glossinessFactor, 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.", "material.specularRoughness += geometryRoughness;", "material.specularRoughness = min( material.specularRoughness, 1.0 );", "material.specularColor = specularFactor;"].join("\n"), o = { specular: { value: (new nt).setHex(16777215) }, glossiness: { value: 1 }, specularMap: { value: null }, glossinessMap: { value: null } }; this._extraUniforms = o, this.onBeforeCompile = function (e) { for (const t in o) e.uniforms[t] = o[t]; e.fragmentShader = e.fragmentShader.replace("uniform float roughness;", "uniform vec3 specular;").replace("uniform float metalness;", "uniform float glossiness;").replace("#include <roughnessmap_pars_fragment>", t).replace("#include <metalnessmap_pars_fragment>", n).replace("#include <roughnessmap_fragment>", i).replace("#include <metalnessmap_fragment>", r).replace("#include <lights_physical_fragment>", s) }, Object.defineProperties(this, { specular: { get: function () { return o.specular.value }, set: function (e) { o.specular.value = e } }, specularMap: { get: function () { return o.specularMap.value }, set: function (e) { o.specularMap.value = e, e ? this.defines.USE_SPECULARMAP = "" : delete this.defines.USE_SPECULARMAP } }, glossiness: { get: function () { return o.glossiness.value }, set: function (e) { o.glossiness.value = e } }, glossinessMap: { get: function () { return o.glossinessMap.value }, set: function (e) { o.glossinessMap.value = e, e ? (this.defines.USE_GLOSSINESSMAP = "", this.defines.USE_UV = "") : (delete this.defines.USE_GLOSSINESSMAP, delete this.defines.USE_UV) } } }), delete this.metalness, delete this.roughness, delete this.metalnessMap, delete this.roughnessMap, this.setValues(e) } copy(e) { return super.copy(e), this.specularMap = e.specularMap, this.specular.copy(e.specular), this.glossinessMap = e.glossinessMap, this.glossiness = e.glossiness, delete this.metalness, delete this.roughness, delete this.metalnessMap, delete this.roughnessMap, this } } class Pl { constructor() { this.name = dl.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS, this.specularGlossinessParams = ["color", "map", "lightMap", "lightMapIntensity", "aoMap", "aoMapIntensity", "emissive", "emissiveIntensity", "emissiveMap", "bumpMap", "bumpScale", "normalMap", "normalMapType", "displacementMap", "displacementScale", "displacementBias", "specularMap", "specular", "glossinessMap", "glossiness", "alphaMap", "envMap", "envMapIntensity", "refractionRatio"] } getMaterialType() { return Tl } extendParams(e, t, n) { const i = t.extensions[this.name]; e.color = new nt(1, 1, 1), e.opacity = 1; const r = []; if (Array.isArray(i.diffuseFactor)) { const t = i.diffuseFactor; e.color.fromArray(t), e.opacity = t[3] } if (void 0 !== i.diffuseTexture && r.push(n.assignTexture(e, "map", i.diffuseTexture)), e.emissive = new nt(0, 0, 0), e.glossiness = void 0 !== i.glossinessFactor ? i.glossinessFactor : 1, e.specular = new nt(1, 1, 1), Array.isArray(i.specularFactor) && e.specular.fromArray(i.specularFactor), void 0 !== i.specularGlossinessTexture) { const t = i.specularGlossinessTexture; r.push(n.assignTexture(e, "glossinessMap", t)), r.push(n.assignTexture(e, "specularMap", t)) } return Promise.all(r) } createMaterial(e) { const t = new Tl(e); return t.fog = !0, t.color = e.color, t.map = void 0 === e.map ? null : e.map, t.lightMap = null, t.lightMapIntensity = 1, t.aoMap = void 0 === e.aoMap ? null : e.aoMap, t.aoMapIntensity = 1, t.emissive = e.emissive, t.emissiveIntensity = 1, t.emissiveMap = void 0 === e.emissiveMap ? null : e.emissiveMap, t.bumpMap = void 0 === e.bumpMap ? null : e.bumpMap, t.bumpScale = 1, t.normalMap = void 0 === e.normalMap ? null : e.normalMap, t.normalMapType = 0, e.normalScale && (t.normalScale = e.normalScale), t.displacementMap = null, t.displacementScale = 1, t.displacementBias = 0, t.specularMap = void 0 === e.specularMap ? null : e.specularMap, t.specular = e.specular, t.glossinessMap = void 0 === e.glossinessMap ? null : e.glossinessMap, t.glossiness = e.glossiness, t.alphaMap = null, t.envMap = void 0 === e.envMap ? null : e.envMap, t.envMapIntensity = 1, t.refractionRatio = .98, t } } class Sl { constructor() { this.name = dl.KHR_MESH_QUANTIZATION } } class Bl extends Do { constructor(e, t, n, i) { super(e, t, n, i) } copySampleValue_(e) { const t = this.resultBuffer, n = this.sampleValues, i = this.valueSize, r = e * i * 3 + i; for (let e = 0; e !== i; e++)t[e] = n[r + e]; return t } } Bl.prototype.beforeStart_ = Bl.prototype.copySampleValue_, Bl.prototype.afterEnd_ = Bl.prototype.copySampleValue_, Bl.prototype.interpolate_ = function (e, t, n, i) { const r = this.resultBuffer, s = this.sampleValues, o = this.valueSize, a = 2 * o, l = 3 * o, c = i - t, A = (n - t) / c, u = A * A, h = u * A, d = e * l, p = d - l, f = -2 * h + 3 * u, g = h - u, m = 1 - f, v = g - u + A; for (let e = 0; e !== o; e++) { const t = s[p + e + o], n = s[p + e + a] * c, i = s[d + e + o], l = s[d + e] * c; r[e] = m * t + v * n + f * i + g * l } return r }; const Dl = 0, Rl = 1, Ll = 2, Ol = 3, Nl = 4, kl = 5, Hl = 6, zl = { 5120: Int8Array, 5121: Uint8Array, 5122: Int16Array, 5123: Uint16Array, 5125: Uint32Array, 5126: Float32Array }, Fl = { 9728: 1003, 9729: 1006, 9984: 1004, 9985: 1007, 9986: 1005, 9987: 1008 }, Ql = { 33071: 1001, 33648: 1002, 10497: 1e3 }, Gl = { SCALAR: 1, VEC2: 2, VEC3: 3, VEC4: 4, MAT2: 4, MAT3: 9, MAT4: 16 }, jl = { POSITION: "position", NORMAL: "normal", TANGENT: "tangent", TEXCOORD_0: "uv", TEXCOORD_1: "uv2", COLOR_0: "color", WEIGHTS_0: "skinWeight", JOINTS_0: "skinIndex" }, Ul = { scale: "scale", translation: "position", rotation: "quaternion", weights: "morphTargetInfluences" }, Vl = { CUBICSPLINE: void 0, LINEAR: 2301, STEP: 2300 }, Yl = "OPAQUE", Wl = "MASK", Xl = "BLEND"; function Jl(e, t) { return "string" != typeof e || "" === e ? "" : (/^https?:\/\//i.test(t) && /^\//.test(e) && (t = t.replace(/(^https?:\/\/[^\/]+).*/i, "$1")), /^(https?:)?\/\//i.test(e) || /^data:.*,.*$/i.test(e) || /^blob:.*$/i.test(e) ? e : t + e) } function Kl(e, t, n) { for (const i in n.extensions) void 0 === e[i] && (t.userData.gltfExtensions = t.userData.gltfExtensions || {}, t.userData.gltfExtensions[i] = n.extensions[i]) } function Zl(e, t) { void 0 !== t.extras && ("object" == typeof t.extras ? Object.assign(e.userData, t.extras) : console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + t.extras)) } function ql(e, t) { if (e.updateMorphTargets(), void 0 !== t.weights) for (let n = 0, i = t.weights.length; n < i; n++)e.morphTargetInfluences[n] = t.weights[n]; if (t.extras && Array.isArray(t.extras.targetNames)) { const n = t.extras.targetNames; if (e.morphTargetInfluences.length === n.length) { e.morphTargetDictionary = {}; for (let t = 0, i = n.length; t < i; t++)e.morphTargetDictionary[n[t]] = t } else console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.") } } function _l(e) { const t = e.extensions && e.extensions[dl.KHR_DRACO_MESH_COMPRESSION]; let n; return n = t ? "draco:" + t.bufferView + ":" + t.indices + ":" + $l(t.attributes) : e.indices + ":" + $l(e.attributes) + ":" + e.mode, n } function $l(e) { let t = ""; const n = Object.keys(e).sort(); for (let i = 0, r = n.length; i < r; i++)t += n[i] + ":" + e[n[i]] + ";"; return t } function ec(e) { switch (e) { case Int8Array: return 1 / 127; case Uint8Array: return 1 / 255; case Int16Array: return 1 / 32767; case Uint16Array: return 1 / 65535; default: throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.") } } class tc { constructor(e = {}, t = {}) { this.json = e, this.extensions = {}, this.plugins = {}, this.options = t, this.cache = new hl, this.associations = new Map, this.primitiveCache = {}, this.meshCache = { refs: {}, uses: {} }, this.cameraCache = { refs: {}, uses: {} }, this.lightCache = { refs: {}, uses: {} }, this.textureCache = {}, this.nodeNamesUsed = {}, "undefined" != typeof createImageBitmap && !1 === /Firefox/.test(navigator.userAgent) ? this.textureLoader = new Ea(this.options.manager) : this.textureLoader = new $o(this.options.manager), this.textureLoader.setCrossOrigin(this.options.crossOrigin), this.textureLoader.setRequestHeader(this.options.requestHeader), this.fileLoader = new Zo(this.options.manager), this.fileLoader.setResponseType("arraybuffer"), "use-credentials" === this.options.crossOrigin && this.fileLoader.setWithCredentials(!0) } setExtensions(e) { this.extensions = e } setPlugins(e) { this.plugins = e } parse(e, t) { const n = this, i = this.json, r = this.extensions; this.cache.removeAll(), this._invokeAll((function (e) { return e._markDefs && e._markDefs() })), Promise.all(this._invokeAll((function (e) { return e.beforeRoot && e.beforeRoot() }))).then((function () { return Promise.all([n.getDependencies("scene"), n.getDependencies("animation"), n.getDependencies("camera")]) })).then((function (t) { const s = { scene: t[0][i.scene || 0], scenes: t[0], animations: t[1], cameras: t[2], asset: i.asset, parser: n, userData: {} }; Kl(r, s, i), Zl(s, i), Promise.all(n._invokeAll((function (e) { return e.afterRoot && e.afterRoot(s) }))).then((function () { e(s) })) })).catch(t) } _markDefs() { const e = this.json.nodes || [], t = this.json.skins || [], n = this.json.meshes || []; for (let n = 0, i = t.length; n < i; n++) { const i = t[n].joints; for (let t = 0, n = i.length; t < n; t++)e[i[t]].isBone = !0 } for (let t = 0, i = e.length; t < i; t++) { const i = e[t]; void 0 !== i.mesh && (this._addNodeRef(this.meshCache, i.mesh), void 0 !== i.skin && (n[i.mesh].isSkinnedMesh = !0)), void 0 !== i.camera && this._addNodeRef(this.cameraCache, i.camera) } } _addNodeRef(e, t) { void 0 !== t && (void 0 === e.refs[t] && (e.refs[t] = e.uses[t] = 0), e.refs[t]++) } _getNodeRef(e, t, n) { if (e.refs[t] <= 1) return n; const i = n.clone(); return i.name += "_instance_" + e.uses[t]++, i } _invokeOne(e) { const t = Object.values(this.plugins); t.push(this); for (let n = 0; n < t.length; n++) { const i = e(t[n]); if (i) return i } return null } _invokeAll(e) { const t = Object.values(this.plugins); t.unshift(this); const n = []; for (let i = 0; i < t.length; i++) { const r = e(t[i]); r && n.push(r) } return n } getDependency(e, t) { const n = e + ":" + t; let i = this.cache.get(n); if (!i) { switch (e) { case "scene": i = this.loadScene(t); break; case "node": i = this.loadNode(t); break; case "mesh": i = this._invokeOne((function (e) { return e.loadMesh && e.loadMesh(t) })); break; case "accessor": i = this.loadAccessor(t); break; case "bufferView": i = this._invokeOne((function (e) { return e.loadBufferView && e.loadBufferView(t) })); break; case "buffer": i = this.loadBuffer(t); break; case "material": i = this._invokeOne((function (e) { return e.loadMaterial && e.loadMaterial(t) })); break; case "texture": i = this._invokeOne((function (e) { return e.loadTexture && e.loadTexture(t) })); break; case "skin": i = this.loadSkin(t); break; case "animation": i = this.loadAnimation(t); break; case "camera": i = this.loadCamera(t); break; default: throw new Error("Unknown type: " + e) }this.cache.add(n, i) } return i } getDependencies(e) { let t = this.cache.get(e); if (!t) { const n = this, i = this.json[e + ("mesh" === e ? "es" : "s")] || []; t = Promise.all(i.map((function (t, i) { return n.getDependency(e, i) }))), this.cache.add(e, t) } return t } loadBuffer(e) { const t = this.json.buffers[e], n = this.fileLoader; if (t.type && "arraybuffer" !== t.type) throw new Error("THREE.GLTFLoader: " + t.type + " buffer type is not supported."); if (void 0 === t.uri && 0 === e) return Promise.resolve(this.extensions[dl.KHR_BINARY_GLTF].body); const i = this.options; return new Promise((function (e, r) { n.load(Jl(t.uri, i.path), e, void 0, (function () { r(new Error('THREE.GLTFLoader: Failed to load buffer "' + t.uri + '".')) })) })) } loadBufferView(e) { const t = this.json.bufferViews[e]; return this.getDependency("buffer", t.buffer).then((function (e) { const n = t.byteLength || 0, i = t.byteOffset || 0; return e.slice(i, i + n) })) } loadAccessor(e) { const t = this, n = this.json, i = this.json.accessors[e]; if (void 0 === i.bufferView && void 0 === i.sparse) return Promise.resolve(null); const r = []; return void 0 !== i.bufferView ? r.push(this.getDependency("bufferView", i.bufferView)) : r.push(null), void 0 !== i.sparse && (r.push(this.getDependency("bufferView", i.sparse.indices.bufferView)), r.push(this.getDependency("bufferView", i.sparse.values.bufferView))), Promise.all(r).then((function (e) { const r = e[0], s = Gl[i.type], o = zl[i.componentType], a = o.BYTES_PER_ELEMENT, l = a * s, c = i.byteOffset || 0, A = void 0 !== i.bufferView ? n.bufferViews[i.bufferView].byteStride : void 0, u = !0 === i.normalized; let h, d; if (A && A !== l) { const e = Math.floor(c / A), n = "InterleavedBuffer:" + i.bufferView + ":" + i.componentType + ":" + e + ":" + i.count; let l = t.cache.get(n); l || (h = new o(r, e * A, i.count * A / a), l = new wr(h, A / a), t.cache.add(n, l)), d = new Cr(l, s, c % A / a, u) } else h = null === r ? new o(i.count * s) : new o(r, c, i.count * s), d = new ot(h, s, u); if (void 0 !== i.sparse) { const t = Gl.SCALAR, n = zl[i.sparse.indices.componentType], a = i.sparse.indices.byteOffset || 0, l = i.sparse.values.byteOffset || 0, c = new n(e[1], a, i.sparse.count * t), A = new o(e[2], l, i.sparse.count * s); null !== r && (d = new ot(d.array.slice(), d.itemSize, d.normalized)); for (let e = 0, t = c.length; e < t; e++) { const t = c[e]; if (d.setX(t, A[e * s]), s >= 2 && d.setY(t, A[e * s + 1]), s >= 3 && d.setZ(t, A[e * s + 2]), s >= 4 && d.setW(t, A[e * s + 3]), s >= 5) throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.") } } return d })) } loadTexture(e) { const t = this.json, n = this.options, i = t.textures[e], r = t.images[i.source]; let s = this.textureLoader; if (r.uri) { const e = n.manager.getHandler(r.uri); null !== e && (s = e) } return this.loadTextureImage(e, r, s) } loadTextureImage(e, t, n) { const i = this, r = this.json, s = this.options, o = r.textures[e], a = (t.uri || t.bufferView) + ":" + o.sampler; if (this.textureCache[a]) return this.textureCache[a]; const l = self.URL || self.webkitURL; let c = t.uri || "", A = !1, u = !0; const h = c.search(/\.jpe?g($|\?)/i) > 0 || 0 === c.search(/^data\:image\/jpeg/); if (("image/jpeg" === t.mimeType || h) && (u = !1), void 0 !== t.bufferView) c = i.getDependency("bufferView", t.bufferView).then((function (e) { if ("image/png" === t.mimeType) { const t = new DataView(e, 25, 1).getUint8(0, !1); u = 6 === t || 4 === t || 3 === t } A = !0; const n = new Blob([e], { type: t.mimeType }); return c = l.createObjectURL(n), c })); else if (void 0 === t.uri) throw new Error("THREE.GLTFLoader: Image " + e + " is missing URI and bufferView"); const d = Promise.resolve(c).then((function (e) { return new Promise((function (t, i) { let r = t; !0 === n.isImageBitmapLoader && (r = function (e) { const n = new P(e); n.needsUpdate = !0, t(n) }), n.load(Jl(e, s.path), r, void 0, i) })) })).then((function (t) { !0 === A && l.revokeObjectURL(c), t.flipY = !1, o.name && (t.name = o.name), u || (t.format = 1022); const n = (r.samplers || {})[o.sampler] || {}; return t.magFilter = Fl[n.magFilter] || 1006, t.minFilter = Fl[n.minFilter] || 1008, t.wrapS = Ql[n.wrapS] || 1e3, t.wrapT = Ql[n.wrapT] || 1e3, i.associations.set(t, { type: "textures", index: e }), t })).catch((function () { return console.error("THREE.GLTFLoader: Couldn't load texture", c), null })); return this.textureCache[a] = d, d } assignTexture(e, t, n) { const i = this; return this.getDependency("texture", n.index).then((function (r) { if (void 0 === n.texCoord || 0 == n.texCoord || "aoMap" === t && 1 == n.texCoord || console.warn("THREE.GLTFLoader: Custom UV set " + n.texCoord + " for texture " + t + " not yet supported."), i.extensions[dl.KHR_TEXTURE_TRANSFORM]) { const e = void 0 !== n.extensions ? n.extensions[dl.KHR_TEXTURE_TRANSFORM] : void 0; if (e) { const t = i.associations.get(r); r = i.extensions[dl.KHR_TEXTURE_TRANSFORM].extendTexture(r, e), i.associations.set(r, t) } } e[t] = r })) } assignFinalMaterial(e) { const t = e.geometry; let n = e.material; const i = void 0 !== t.attributes.tangent, r = void 0 !== t.attributes.color, s = void 0 === t.attributes.normal, o = Object.keys(t.morphAttributes).length > 0, a = o && void 0 !== t.morphAttributes.normal; if (e.isPoints) { const e = "PointsMaterial:" + n.uuid; let t = this.cache.get(e); t || (t = new hs, Ke.prototype.copy.call(t, n), t.color.copy(n.color), t.map = n.map, t.sizeAttenuation = !1, this.cache.add(e, t)), n = t } else if (e.isLine) { const e = "LineBasicMaterial:" + n.uuid; let t = this.cache.get(e); t || (t = new ts, Ke.prototype.copy.call(t, n), t.color.copy(n.color), this.cache.add(e, t)), n = t } if (i || r || s || o) { let e = "ClonedMaterial:" + n.uuid + ":"; n.isGLTFSpecularGlossinessMaterial && (e += "specular-glossiness:"), i && (e += "vertex-tangents:"), r && (e += "vertex-colors:"), s && (e += "flat-shading:"), o && (e += "morph-targets:"), a && (e += "morph-normals:"); let t = this.cache.get(e); t || (t = n.clone(), r && (t.vertexColors = !0), s && (t.flatShading = !0), o && (t.morphTargets = !0), a && (t.morphNormals = !0), i && (t.vertexTangents = !0, t.normalScale && (t.normalScale.y *= -1), t.clearcoatNormalScale && (t.clearcoatNormalScale.y *= -1)), this.cache.add(e, t), this.associations.set(t, this.associations.get(n))), n = t } n.aoMap && void 0 === t.attributes.uv2 && void 0 !== t.attributes.uv && t.setAttribute("uv2", t.attributes.uv), e.material = n } getMaterialType() { return Co } loadMaterial(e) { const t = this, n = this.json, i = this.extensions, r = n.materials[e]; let s; const o = {}, a = r.extensions || {}, l = []; if (a[dl.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]) { const e = i[dl.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]; s = e.getMaterialType(), l.push(e.extendParams(o, r, t)) } else if (a[dl.KHR_MATERIALS_UNLIT]) { const e = i[dl.KHR_MATERIALS_UNLIT]; s = e.getMaterialType(), l.push(e.extendParams(o, r, t)) } else { const n = r.pbrMetallicRoughness || {}; if (o.color = new nt(1, 1, 1), o.opacity = 1, Array.isArray(n.baseColorFactor)) { const e = n.baseColorFactor; o.color.fromArray(e), o.opacity = e[3] } void 0 !== n.baseColorTexture && l.push(t.assignTexture(o, "map", n.baseColorTexture)), o.metalness = void 0 !== n.metallicFactor ? n.metallicFactor : 1, o.roughness = void 0 !== n.roughnessFactor ? n.roughnessFactor : 1, void 0 !== n.metallicRoughnessTexture && (l.push(t.assignTexture(o, "metalnessMap", n.metallicRoughnessTexture)), l.push(t.assignTexture(o, "roughnessMap", n.metallicRoughnessTexture))), s = this._invokeOne((function (t) { return t.getMaterialType && t.getMaterialType(e) })), l.push(Promise.all(this._invokeAll((function (t) { return t.extendMaterialParams && t.extendMaterialParams(e, o) })))) } !0 === r.doubleSided && (o.side = 2); const c = r.alphaMode || Yl; return c === Xl ? (o.transparent = !0, o.depthWrite = !1) : (o.transparent = !1, c === Wl && (o.alphaTest = void 0 !== r.alphaCutoff ? r.alphaCutoff : .5)), void 0 !== r.normalTexture && s !== it && (l.push(t.assignTexture(o, "normalMap", r.normalTexture)), o.normalScale = new b(1, -1), void 0 !== r.normalTexture.scale && o.normalScale.set(r.normalTexture.scale, -r.normalTexture.scale)), void 0 !== r.occlusionTexture && s !== it && (l.push(t.assignTexture(o, "aoMap", r.occlusionTexture)), void 0 !== r.occlusionTexture.strength && (o.aoMapIntensity = r.occlusionTexture.strength)), void 0 !== r.emissiveFactor && s !== it && (o.emissive = (new nt).fromArray(r.emissiveFactor)), void 0 !== r.emissiveTexture && s !== it && l.push(t.assignTexture(o, "emissiveMap", r.emissiveTexture)), Promise.all(l).then((function () { let n; return n = s === Tl ? i[dl.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].createMaterial(o) : new s(o), r.name && (n.name = r.name), n.map && (n.map.encoding = 3001), n.emissiveMap && (n.emissiveMap.encoding = 3001), Zl(n, r), t.associations.set(n, { type: "materials", index: e }), r.extensions && Kl(i, n, r), n })) } createUniqueName(e) { const t = Ya.sanitizeNodeName(e || ""); let n = t; for (let e = 1; this.nodeNamesUsed[n]; ++e)n = t + "_" + e; return this.nodeNamesUsed[n] = !0, n } loadGeometries(e) { const t = this, n = this.extensions, i = this.primitiveCache; function r(e) { return n[dl.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(e, t).then((function (n) { return ic(n, e, t) })) } const s = []; for (let n = 0, o = e.length; n < o; n++) { const o = e[n], a = _l(o), l = i[a]; if (l) s.push(l.promise); else { let e; e = o.extensions && o.extensions[dl.KHR_DRACO_MESH_COMPRESSION] ? r(o) : ic(new vt, o, t), i[a] = { primitive: o, promise: e }, s.push(e) } } return Promise.all(s) } loadMesh(e) { const t = this, n = this.json, i = this.extensions, r = n.meshes[e], s = r.primitives, o = []; for (let e = 0, t = s.length; e < t; e++) { const t = void 0 === s[e].material ? (void 0 === (a = this.cache).DefaultMaterial && (a.DefaultMaterial = new Co({ color: 16777215, emissive: 0, metalness: 1, roughness: 1, transparent: !1, depthTest: !0, side: 0 })), a.DefaultMaterial) : this.getDependency("material", s[e].material); o.push(t) } var a; return o.push(t.loadGeometries(s)), Promise.all(o).then((function (n) { const o = n.slice(0, n.length - 1), a = n[n.length - 1], l = []; for (let n = 0, c = a.length; n < c; n++) { const c = a[n], A = s[n]; let u; const h = o[n]; if (A.mode === Nl || A.mode === kl || A.mode === Hl || void 0 === A.mode) u = !0 === r.isSkinnedMesh ? new Vr(c, h) : new kt(c, h), !0 !== u.isSkinnedMesh || u.geometry.attributes.skinWeight.normalized || u.normalizeSkinWeights(), A.mode === kl ? u.geometry = rc(u.geometry, 1) : A.mode === Hl && (u.geometry = rc(u.geometry, 2)); else if (A.mode === Rl) u = new As(c, h); else if (A.mode === Ol) u = new as(c, h); else if (A.mode === Ll) u = new us(c, h); else { if (A.mode !== Dl) throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + A.mode); u = new ms(c, h) } Object.keys(u.geometry.morphAttributes).length > 0 && ql(u, r), u.name = t.createUniqueName(r.name || "mesh_" + e), Zl(u, r), A.extensions && Kl(i, u, A), t.assignFinalMaterial(u), l.push(u) } if (1 === l.length) return l[0]; const c = new ur; for (let e = 0, t = l.length; e < t; e++)c.add(l[e]); return c })) } loadCamera(e) { let t; const n = this.json.cameras[e], i = n[n.type]; if (i) return "perspective" === n.type ? t = new Vt(C.radToDeg(i.yfov), i.aspectRatio || 1, i.znear || 1, i.zfar || 2e6) : "orthographic" === n.type && (t = new ga(-i.xmag, i.xmag, i.ymag, -i.ymag, i.znear, i.zfar)), n.name && (t.name = this.createUniqueName(n.name)), Zl(t, n), Promise.resolve(t); console.warn("THREE.GLTFLoader: Missing camera parameters.") } loadSkin(e) { const t = this.json.skins[e], n = { joints: t.joints }; return void 0 === t.inverseBindMatrices ? Promise.resolve(n) : this.getDependency("accessor", t.inverseBindMatrices).then((function (e) { return n.inverseBindMatrices = e, n })) } loadAnimation(e) { const t = this.json.animations[e], n = [], i = [], r = [], s = [], o = []; for (let e = 0, a = t.channels.length; e < a; e++) { const a = t.channels[e], l = t.samplers[a.sampler], c = a.target, A = void 0 !== c.node ? c.node : c.id, u = void 0 !== t.parameters ? t.parameters[l.input] : l.input, h = void 0 !== t.parameters ? t.parameters[l.output] : l.output; n.push(this.getDependency("node", A)), i.push(this.getDependency("accessor", u)), r.push(this.getDependency("accessor", h)), s.push(l), o.push(c) } return Promise.all([Promise.all(n), Promise.all(i), Promise.all(r), Promise.all(s), Promise.all(o)]).then((function (n) { const i = n[0], r = n[1], s = n[2], o = n[3], a = n[4], l = []; for (let e = 0, t = i.length; e < t; e++) { const t = i[e], n = r[e], c = s[e], A = o[e], u = a[e]; if (void 0 === t) continue; let h; switch (t.updateMatrix(), t.matrixAutoUpdate = !0, Ul[u.path]) { case Ul.weights: h = zo; break; case Ul.rotation: h = Qo; break; case Ul.position: case Ul.scale: default: h = jo }const d = t.name ? t.name : t.uuid, p = void 0 !== A.interpolation ? Vl[A.interpolation] : 2301, f = []; Ul[u.path] === Ul.weights ? t.traverse((function (e) { !0 === e.isMesh && e.morphTargetInfluences && f.push(e.name ? e.name : e.uuid) })) : f.push(d); let g = c.array; if (c.normalized) { const e = ec(g.constructor), t = new Float32Array(g.length); for (let n = 0, i = g.length; n < i; n++)t[n] = g[n] * e; g = t } for (let e = 0, t = f.length; e < t; e++) { const t = new h(f[e] + "." + Ul[u.path], n.array, g, p); "CUBICSPLINE" === A.interpolation && (t.createInterpolant = function (e) { return new Bl(this.times, this.values, this.getValueSize() / 3, e) }, t.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = !0), l.push(t) } } const c = t.name ? t.name : "animation_" + e; return new Uo(c, void 0, l) })) } createNodeMesh(e) { const t = this.json, n = this, i = t.nodes[e]; return void 0 === i.mesh ? null : n.getDependency("mesh", i.mesh).then((function (e) { const t = n._getNodeRef(n.meshCache, i.mesh, e); return void 0 !== i.weights && t.traverse((function (e) { if (e.isMesh) for (let t = 0, n = i.weights.length; t < n; t++)e.morphTargetInfluences[t] = i.weights[t] })), t })) } loadNode(e) { const t = this.json, n = this.extensions, i = this, r = t.nodes[e], s = r.name ? i.createUniqueName(r.name) : ""; return function () { const t = [], n = i._invokeOne((function (t) { return t.createNodeMesh && t.createNodeMesh(e) })); return n && t.push(n), void 0 !== r.camera && t.push(i.getDependency("camera", r.camera).then((function (e) { return i._getNodeRef(i.cameraCache, r.camera, e) }))), i._invokeAll((function (t) { return t.createNodeAttachment && t.createNodeAttachment(e) })).forEach((function (e) { t.push(e) })), Promise.all(t) }().then((function (t) { let o; if (o = !0 === r.isBone ? new Yr : t.length > 1 ? new ur : 1 === t.length ? t[0] : new ke, o !== t[0]) for (let e = 0, n = t.length; e < n; e++)o.add(t[e]); if (r.name && (o.userData.name = r.name, o.name = s), Zl(o, r), r.extensions && Kl(n, o, r), void 0 !== r.matrix) { const e = new ue; e.fromArray(r.matrix), o.applyMatrix4(e) } else void 0 !== r.translation && o.position.fromArray(r.translation), void 0 !== r.rotation && o.quaternion.fromArray(r.rotation), void 0 !== r.scale && o.scale.fromArray(r.scale); return i.associations.set(o, { type: "nodes", index: e }), o })) } loadScene(e) { const t = this.json, n = this.extensions, i = this.json.scenes[e], r = this, s = new ur; i.name && (s.name = r.createUniqueName(i.name)), Zl(s, i), i.extensions && Kl(n, s, i); const o = i.nodes || [], a = []; for (let e = 0, n = o.length; e < n; e++)a.push(nc(o[e], s, t, r)); return Promise.all(a).then((function () { return s })) } } function nc(e, t, n, i) { const r = n.nodes[e]; return i.getDependency("node", e).then((function (e) { if (void 0 === r.skin) return e; let t; return i.getDependency("skin", r.skin).then((function (e) { t = e; const n = []; for (let e = 0, r = t.joints.length; e < r; e++)n.push(i.getDependency("node", t.joints[e])); return Promise.all(n) })).then((function (n) { return e.traverse((function (e) { if (!e.isMesh) return; const i = [], r = []; for (let e = 0, s = n.length; e < s; e++) { const s = n[e]; if (s) { i.push(s); const n = new ue; void 0 !== t.inverseBindMatrices && n.fromArray(t.inverseBindMatrices.array, 16 * e), r.push(n) } else console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', t.joints[e]) } e.bind(new Kr(i, r), e.matrixWorld) })), e })) })).then((function (e) { t.add(e); const s = []; if (r.children) { const t = r.children; for (let r = 0, o = t.length; r < o; r++) { const o = t[r]; s.push(nc(o, e, n, i)) } } return Promise.all(s) })) } function ic(e, t, n) { const i = t.attributes, r = []; function s(t, i) { return n.getDependency("accessor", t).then((function (t) { e.setAttribute(i, t) })) } for (const t in i) { const n = jl[t] || t.toLowerCase(); n in e.attributes || r.push(s(i[t], n)) } if (void 0 !== t.indices && !e.index) { const i = n.getDependency("accessor", t.indices).then((function (t) { e.setIndex(t) })); r.push(i) } return Zl(e, t), function (e, t, n) { const i = t.attributes, r = new H; if (void 0 === i.POSITION) return; { const e = n.json.accessors[i.POSITION], t = e.min, s = e.max; if (void 0 === t || void 0 === s) return void console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION."); if (r.set(new O(t[0], t[1], t[2]), new O(s[0], s[1], s[2])), e.normalized) { const t = ec(zl[e.componentType]); r.min.multiplyScalar(t), r.max.multiplyScalar(t) } } const s = t.targets; if (void 0 !== s) { const e = new O, t = new O; for (let i = 0, r = s.length; i < r; i++) { const r = s[i]; if (void 0 !== r.POSITION) { const i = n.json.accessors[r.POSITION], s = i.min, o = i.max; if (void 0 !== s && void 0 !== o) { if (t.setX(Math.max(Math.abs(s[0]), Math.abs(o[0]))), t.setY(Math.max(Math.abs(s[1]), Math.abs(o[1]))), t.setZ(Math.max(Math.abs(s[2]), Math.abs(o[2]))), i.normalized) { const e = ec(zl[i.componentType]); t.multiplyScalar(e) } e.max(t) } else console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.") } } r.expandByVector(e) } e.boundingBox = r; const o = new ne; r.getCenter(o.center), o.radius = r.min.distanceTo(r.max) / 2, e.boundingSphere = o }(e, t, n), Promise.all(r).then((function () { return void 0 !== t.targets ? function (e, t, n) { let i = !1, r = !1; for (let e = 0, n = t.length; e < n; e++) { const n = t[e]; if (void 0 !== n.POSITION && (i = !0), void 0 !== n.NORMAL && (r = !0), i && r) break } if (!i && !r) return Promise.resolve(e); const s = [], o = []; for (let a = 0, l = t.length; a < l; a++) { const l = t[a]; if (i) { const t = void 0 !== l.POSITION ? n.getDependency("accessor", l.POSITION) : e.attributes.position; s.push(t) } if (r) { const t = void 0 !== l.NORMAL ? n.getDependency("accessor", l.NORMAL) : e.attributes.normal; o.push(t) } } return Promise.all([Promise.all(s), Promise.all(o)]).then((function (t) { const n = t[0], s = t[1]; return i && (e.morphAttributes.position = n), r && (e.morphAttributes.normal = s), e.morphTargetsRelative = !0, e })) }(e, t.targets, n) : e })) } function rc(e, t) { let n = e.getIndex(); if (null === n) { const t = [], i = e.getAttribute("position"); if (void 0 === i) return console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."), e; for (let e = 0; e < i.count; e++)t.push(e); e.setIndex(t), n = e.getIndex() } const i = n.count - 2, r = []; if (2 === t) for (let e = 1; e <= i; e++)r.push(n.getX(0)), r.push(n.getX(e)), r.push(n.getX(e + 1)); else for (let e = 0; e < i; e++)e % 2 == 0 ? (r.push(n.getX(e)), r.push(n.getX(e + 1)), r.push(n.getX(e + 2))) : (r.push(n.getX(e + 2)), r.push(n.getX(e + 1)), r.push(n.getX(e))); r.length / 3 !== i && console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles."); const s = e.clone(); return s.setIndex(r), s } function sc(e, t) { for (var n = 0; n < t.length; n++) { var i = t[n]; i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i) } } var oc = new (function () { function e() { !function (e, t) { if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function") }(this, e) } var t, n, i; return t = e, (n = [{ key: "rand", value: function (e, t) { return Math.random() * (t - e) + e } }, { key: "mod", value: function (e, t) { return (e % t + t) % t } }, { key: "clamp", value: function (e, t, n) { return Math.min(Math.max(e, t), n) } }, { key: "getClonedModel", value: function (e) { var t = this.cloneGltf(e), n = this.isModelAnimated ? t.scene.getObjectByName("ctrl_catapult") : t.scene.children[0]; return { clonedGltf: t, clonedMesh: n } } }, { key: "cloneGltf", value: function (e) { var t = { animations: e.animations, scene: e.scene.clone(!0) }, n = {}; e.scene.traverse((function (e) { e.isSkinnedMesh && (n[e.name] = e) })); var i = {}, r = {}; for (var s in t.scene.traverse((function (e) { e.isBone && (i[e.name] = e), e.isSkinnedMesh && (r[e.name] = e) })), n) { for (var o = n[s].skeleton, a = r[s], l = [], c = 0; c < o.bones.length; ++c) { var A = i[o.bones[c].name]; l.push(A) } a.bind(new Skeleton(l, o.boneInverses), a.matrixWorld) } return t } }, { key: "isFunc", value: function (e) { return void 0 !== e } }, { key: "clean", value: function (e) { if (e) if (e.isMesh) e.parent && e.parent.remove(e), e.geometry.dispose(), e.material.dispose(); else for (; e.children.length > 0;) { var t = e.children[0]; t.isMesh ? (e.remove(t), t.geometry.dispose(), t.material.dispose()) : t.children && t.children.length > 0 ? this.clean(t) : e.remove(t) } } }]) && sc(t.prototype, n), i && sc(t, i), e }()); function ac(e, t) { var n = e.__state.conversionName.toString(), i = Math.round(e.r), r = Math.round(e.g), s = Math.round(e.b), o = e.a, a = Math.round(e.h), l = e.s.toFixed(1), c = e.v.toFixed(1); if (t || "THREE_CHAR_HEX" === n || "SIX_CHAR_HEX" === n) { for (var A = e.hex.toString(16); A.length < 6;)A = "0" + A; return "#" + A } return "CSS_RGB" === n ? "rgb(" + i + "," + r + "," + s + ")" : "CSS_RGBA" === n ? "rgba(" + i + "," + r + "," + s + "," + o + ")" : "HEX" === n ? "0x" + e.hex.toString(16) : "RGB_ARRAY" === n ? "[" + i + "," + r + "," + s + "]" : "RGBA_ARRAY" === n ? "[" + i + "," + r + "," + s + "," + o + "]" : "RGB_OBJ" === n ? "{r:" + i + ",g:" + r + ",b:" + s + "}" : "RGBA_OBJ" === n ? "{r:" + i + ",g:" + r + ",b:" + s + ",a:" + o + "}" : "HSV_OBJ" === n ? "{h:" + a + ",s:" + l + ",v:" + c + "}" : "HSVA_OBJ" === n ? "{h:" + a + ",s:" + l + ",v:" + c + ",a:" + o + "}" : "unknown format" } var lc = Array.prototype.forEach, cc = Array.prototype.slice, Ac = { BREAK: {}, extend: function (e) { return this.each(cc.call(arguments, 1), (function (t) { (this.isObject(t) ? Object.keys(t) : []).forEach(function (n) { this.isUndefined(t[n]) || (e[n] = t[n]) }.bind(this)) }), this), e }, defaults: function (e) { return this.each(cc.call(arguments, 1), (function (t) { (this.isObject(t) ? Object.keys(t) : []).forEach(function (n) { this.isUndefined(e[n]) && (e[n] = t[n]) }.bind(this)) }), this), e }, compose: function () { var e = cc.call(arguments); return function () { for (var t = cc.call(arguments), n = e.length - 1; n >= 0; n--)t = [e[n].apply(this, t)]; return t[0] } }, each: function (e, t, n) { if (e) if (lc && e.forEach && e.forEach === lc) e.forEach(t, n); else if (e.length === e.length + 0) { var i, r = void 0; for (r = 0, i = e.length; r < i; r++)if (r in e && t.call(n, e[r], r) === this.BREAK) return } else for (var s in e) if (t.call(n, e[s], s) === this.BREAK) return }, defer: function (e) { setTimeout(e, 0) }, debounce: function (e, t, n) { var i = void 0; return function () { var r = this, s = arguments; function o() { i = null, n || e.apply(r, s) } var a = n || !i; clearTimeout(i), i = setTimeout(o, t), a && e.apply(r, s) } }, toArray: function (e) { return e.toArray ? e.toArray() : cc.call(e) }, isUndefined: function (e) { return void 0 === e }, isNull: function (e) { return null === e }, isNaN: function (e) { function t() { return e.apply(this, arguments) } return t.toString = function () { return e.toString() }, t }((function (e) { return isNaN(e) })), isArray: Array.isArray || function (e) { return e.constructor === Array }, isObject: function (e) { return e === Object(e) }, isNumber: function (e) { return e === e + 0 }, isString: function (e) { return e === e + "" }, isBoolean: function (e) { return !1 === e || !0 === e }, isFunction: function (e) { return e instanceof Function } }, uc = [{ litmus: Ac.isString, conversions: { THREE_CHAR_HEX: { read: function (e) { var t = e.match(/^#([A-F0-9])([A-F0-9])([A-F0-9])$/i); return null !== t && { space: "HEX", hex: parseInt("0x" + t[1].toString() + t[1].toString() + t[2].toString() + t[2].toString() + t[3].toString() + t[3].toString(), 0) } }, write: ac }, SIX_CHAR_HEX: { read: function (e) { var t = e.match(/^#([A-F0-9]{6})$/i); return null !== t && { space: "HEX", hex: parseInt("0x" + t[1].toString(), 0) } }, write: ac }, CSS_RGB: { read: function (e) { var t = e.match(/^rgb\(\s*(.+)\s*,\s*(.+)\s*,\s*(.+)\s*\)/); return null !== t && { space: "RGB", r: parseFloat(t[1]), g: parseFloat(t[2]), b: parseFloat(t[3]) } }, write: ac }, CSS_RGBA: { read: function (e) { var t = e.match(/^rgba\(\s*(.+)\s*,\s*(.+)\s*,\s*(.+)\s*,\s*(.+)\s*\)/); return null !== t && { space: "RGB", r: parseFloat(t[1]), g: parseFloat(t[2]), b: parseFloat(t[3]), a: parseFloat(t[4]) } }, write: ac } } }, { litmus: Ac.isNumber, conversions: { HEX: { read: function (e) { return { space: "HEX", hex: e, conversionName: "HEX" } }, write: function (e) { return e.hex } } } }, { litmus: Ac.isArray, conversions: { RGB_ARRAY: { read: function (e) { return 3 === e.length && { space: "RGB", r: e[0], g: e[1], b: e[2] } }, write: function (e) { return [e.r, e.g, e.b] } }, RGBA_ARRAY: { read: function (e) { return 4 === e.length && { space: "RGB", r: e[0], g: e[1], b: e[2], a: e[3] } }, write: function (e) { return [e.r, e.g, e.b, e.a] } } } }, { litmus: Ac.isObject, conversions: { RGBA_OBJ: { read: function (e) { return !!(Ac.isNumber(e.r) && Ac.isNumber(e.g) && Ac.isNumber(e.b) && Ac.isNumber(e.a)) && { space: "RGB", r: e.r, g: e.g, b: e.b, a: e.a } }, write: function (e) { return { r: e.r, g: e.g, b: e.b, a: e.a } } }, RGB_OBJ: { read: function (e) { return !!(Ac.isNumber(e.r) && Ac.isNumber(e.g) && Ac.isNumber(e.b)) && { space: "RGB", r: e.r, g: e.g, b: e.b } }, write: function (e) { return { r: e.r, g: e.g, b: e.b } } }, HSVA_OBJ: { read: function (e) { return !!(Ac.isNumber(e.h) && Ac.isNumber(e.s) && Ac.isNumber(e.v) && Ac.isNumber(e.a)) && { space: "HSV", h: e.h, s: e.s, v: e.v, a: e.a } }, write: function (e) { return { h: e.h, s: e.s, v: e.v, a: e.a } } }, HSV_OBJ: { read: function (e) { return !!(Ac.isNumber(e.h) && Ac.isNumber(e.s) && Ac.isNumber(e.v)) && { space: "HSV", h: e.h, s: e.s, v: e.v } }, write: function (e) { return { h: e.h, s: e.s, v: e.v } } } } }], hc = void 0, dc = void 0, pc = function () { dc = !1; var e = arguments.length > 1 ? Ac.toArray(arguments) : arguments[0]; return Ac.each(uc, (function (t) { if (t.litmus(e)) return Ac.each(t.conversions, (function (t, n) { if (hc = t.read(e), !1 === dc && !1 !== hc) return dc = hc, hc.conversionName = n, hc.conversion = t, Ac.BREAK })), Ac.BREAK })), dc }, fc = void 0, gc = { hsv_to_rgb: function (e, t, n) { var i = Math.floor(e / 60) % 6, r = e / 60 - Math.floor(e / 60), s = n * (1 - t), o = n * (1 - r * t), a = n * (1 - (1 - r) * t), l = [[n, a, s], [o, n, s], [s, n, a], [s, o, n], [a, s, n], [n, s, o]][i]; return { r: 255 * l[0], g: 255 * l[1], b: 255 * l[2] } }, rgb_to_hsv: function (e, t, n) { var i = Math.min(e, t, n), r = Math.max(e, t, n), s = r - i, o = void 0; return 0 === r ? { h: NaN, s: 0, v: 0 } : (o = e === r ? (t - n) / s : t === r ? 2 + (n - e) / s : 4 + (e - t) / s, (o /= 6) < 0 && (o += 1), { h: 360 * o, s: s / r, v: r / 255 }) }, rgb_to_hex: function (e, t, n) { var i = this.hex_with_component(0, 2, e); return i = this.hex_with_component(i, 1, t), i = this.hex_with_component(i, 0, n) }, component_from_hex: function (e, t) { return e >> 8 * t & 255 }, hex_with_component: function (e, t, n) { return n << (fc = 8 * t) | e & ~(255 << fc) } }, mc = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) { return typeof e } : function (e) { return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e }, vc = function (e, t) { if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function") }, yc = function () { function e(e, t) { for (var n = 0; n < t.length; n++) { var i = t[n]; i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i) } } return function (t, n, i) { return n && e(t.prototype, n), i && e(t, i), t } }(), wc = function e(t, n, i) { null === t && (t = Function.prototype); var r = Object.getOwnPropertyDescriptor(t, n); if (void 0 === r) { var s = Object.getPrototypeOf(t); return null === s ? void 0 : e(s, n, i) } if ("value" in r) return r.value; var o = r.get; return void 0 !== o ? o.call(i) : void 0 }, xc = function (e, t) { if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function, not " + typeof t); e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t) }, Cc = function (e, t) { if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return !t || "object" != typeof t && "function" != typeof t ? e : t }, bc = function () { function e() { if (vc(this, e), this.__state = pc.apply(this, arguments), !1 === this.__state) throw new Error("Failed to interpret color arguments"); this.__state.a = this.__state.a || 1 } return yc(e, [{ key: "toString", value: function () { return ac(this) } }, { key: "toHexString", value: function () { return ac(this, !0) } }, { key: "toOriginal", value: function () { return this.__state.conversion.write(this) } }]), e }(); function Mc(e, t, n) { Object.defineProperty(e, t, { get: function () { return "RGB" === this.__state.space || bc.recalculateRGB(this, t, n), this.__state[t] }, set: function (e) { "RGB" !== this.__state.space && (bc.recalculateRGB(this, t, n), this.__state.space = "RGB"), this.__state[t] = e } }) } function Ic(e, t) { Object.defineProperty(e, t, { get: function () { return "HSV" === this.__state.space || bc.recalculateHSV(this), this.__state[t] }, set: function (e) { "HSV" !== this.__state.space && (bc.recalculateHSV(this), this.__state.space = "HSV"), this.__state[t] = e } }) } bc.recalculateRGB = function (e, t, n) { if ("HEX" === e.__state.space) e.__state[t] = gc.component_from_hex(e.__state.hex, n); else { if ("HSV" !== e.__state.space) throw new Error("Corrupted color state"); Ac.extend(e.__state, gc.hsv_to_rgb(e.__state.h, e.__state.s, e.__state.v)) } }, bc.recalculateHSV = function (e) { var t = gc.rgb_to_hsv(e.r, e.g, e.b); Ac.extend(e.__state, { s: t.s, v: t.v }), Ac.isNaN(t.h) ? Ac.isUndefined(e.__state.h) && (e.__state.h = 0) : e.__state.h = t.h }, bc.COMPONENTS = ["r", "g", "b", "h", "s", "v", "hex", "a"], Mc(bc.prototype, "r", 2), Mc(bc.prototype, "g", 1), Mc(bc.prototype, "b", 0), Ic(bc.prototype, "h"), Ic(bc.prototype, "s"), Ic(bc.prototype, "v"), Object.defineProperty(bc.prototype, "a", { get: function () { return this.__state.a }, set: function (e) { this.__state.a = e } }), Object.defineProperty(bc.prototype, "hex", { get: function () { return "HEX" !== this.__state.space && (this.__state.hex = gc.rgb_to_hex(this.r, this.g, this.b), this.__state.space = "HEX"), this.__state.hex }, set: function (e) { this.__state.space = "HEX", this.__state.hex = e } }); var Ec = function () { function e(t, n) { vc(this, e), this.initialValue = t[n], this.domElement = document.createElement("div"), this.object = t, this.property = n, this.__onChange = void 0, this.__onFinishChange = void 0 } return yc(e, [{ key: "onChange", value: function (e) { return this.__onChange = e, this } }, { key: "onFinishChange", value: function (e) { return this.__onFinishChange = e, this } }, { key: "setValue", value: function (e) { return this.object[this.property] = e, this.__onChange && this.__onChange.call(this, e), this.updateDisplay(), this } }, { key: "getValue", value: function () { return this.object[this.property] } }, { key: "updateDisplay", value: function () { return this } }, { key: "isModified", value: function () { return this.initialValue !== this.getValue() } }]), e }(), Tc = {}; Ac.each({ HTMLEvents: ["change"], MouseEvents: ["click", "mousemove", "mousedown", "mouseup", "mouseover"], KeyboardEvents: ["keydown"] }, (function (e, t) { Ac.each(e, (function (e) { Tc[e] = t })) })); var Pc = /(\d+(\.\d+)?)px/; function Sc(e) { if ("0" === e || Ac.isUndefined(e)) return 0; var t = e.match(Pc); return Ac.isNull(t) ? 0 : parseFloat(t[1]) } var Bc = { makeSelectable: function (e, t) { void 0 !== e && void 0 !== e.style && (e.onselectstart = t ? function () { return !1 } : function () { }, e.style.MozUserSelect = t ? "auto" : "none", e.style.KhtmlUserSelect = t ? "auto" : "none", e.unselectable = t ? "on" : "off") }, makeFullscreen: function (e, t, n) { var i = n, r = t; Ac.isUndefined(r) && (r = !0), Ac.isUndefined(i) && (i = !0), e.style.position = "absolute", r && (e.style.left = 0, e.style.right = 0), i && (e.style.top = 0, e.style.bottom = 0) }, fakeEvent: function (e, t, n, i) { var r = n || {}, s = Tc[t]; if (!s) throw new Error("Event type " + t + " not supported."); var o = document.createEvent(s); switch (s) { case "MouseEvents": var a = r.x || r.clientX || 0, l = r.y || r.clientY || 0; o.initMouseEvent(t, r.bubbles || !1, r.cancelable || !0, window, r.clickCount || 1, 0, 0, a, l, !1, !1, !1, !1, 0, null); break; case "KeyboardEvents": var c = o.initKeyboardEvent || o.initKeyEvent; Ac.defaults(r, { cancelable: !0, ctrlKey: !1, altKey: !1, shiftKey: !1, metaKey: !1, keyCode: void 0, charCode: void 0 }), c(t, r.bubbles || !1, r.cancelable, window, r.ctrlKey, r.altKey, r.shiftKey, r.metaKey, r.keyCode, r.charCode); break; default: o.initEvent(t, r.bubbles || !1, r.cancelable || !0) }Ac.defaults(o, i), e.dispatchEvent(o) }, bind: function (e, t, n, i) { var r = i || !1; return e.addEventListener ? e.addEventListener(t, n, r) : e.attachEvent && e.attachEvent("on" + t, n), Bc }, unbind: function (e, t, n, i) { var r = i || !1; return e.removeEventListener ? e.removeEventListener(t, n, r) : e.detachEvent && e.detachEvent("on" + t, n), Bc }, addClass: function (e, t) { if (void 0 === e.className) e.className = t; else if (e.className !== t) { var n = e.className.split(/ +/); -1 === n.indexOf(t) && (n.push(t), e.className = n.join(" ").replace(/^\s+/, "").replace(/\s+$/, "")) } return Bc }, removeClass: function (e, t) { if (t) if (e.className === t) e.removeAttribute("class"); else { var n = e.className.split(/ +/), i = n.indexOf(t); -1 !== i && (n.splice(i, 1), e.className = n.join(" ")) } else e.className = void 0; return Bc }, hasClass: function (e, t) { return new RegExp("(?:^|\\s+)" + t + "(?:\\s+|$)").test(e.className) || !1 }, getWidth: function (e) { var t = getComputedStyle(e); return Sc(t["border-left-width"]) + Sc(t["border-right-width"]) + Sc(t["padding-left"]) + Sc(t["padding-right"]) + Sc(t.width) }, getHeight: function (e) { var t = getComputedStyle(e); return Sc(t["border-top-width"]) + Sc(t["border-bottom-width"]) + Sc(t["padding-top"]) + Sc(t["padding-bottom"]) + Sc(t.height) }, getOffset: function (e) { var t = e, n = { left: 0, top: 0 }; if (t.offsetParent) do { n.left += t.offsetLeft, n.top += t.offsetTop, t = t.offsetParent } while (t); return n }, isActive: function (e) { return e === document.activeElement && (e.type || e.href) } }, Dc = function (e) { function t(e, n) { vc(this, t); var i = Cc(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this, e, n)), r = i; return i.__prev = i.getValue(), i.__checkbox = document.createElement("input"), i.__checkbox.setAttribute("type", "checkbox"), Bc.bind(i.__checkbox, "change", (function () { r.setValue(!r.__prev) }), !1), i.domElement.appendChild(i.__checkbox), i.updateDisplay(), i } return xc(t, e), yc(t, [{ key: "setValue", value: function (e) { var n = wc(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "setValue", this).call(this, e); return this.__onFinishChange && this.__onFinishChange.call(this, this.getValue()), this.__prev = this.getValue(), n } }, { key: "updateDisplay", value: function () { return !0 === this.getValue() ? (this.__checkbox.setAttribute("checked", "checked"), this.__checkbox.checked = !0, this.__prev = !0) : (this.__checkbox.checked = !1, this.__prev = !1), wc(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "updateDisplay", this).call(this) } }]), t }(Ec), Rc = function (e) { function t(e, n, i) { vc(this, t); var r = Cc(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this, e, n)), s = i, o = r; if (r.__select = document.createElement("select"), Ac.isArray(s)) { var a = {}; Ac.each(s, (function (e) { a[e] = e })), s = a } return Ac.each(s, (function (e, t) { var n = document.createElement("option"); n.innerHTML = t, n.setAttribute("value", e), o.__select.appendChild(n) })), r.updateDisplay(), Bc.bind(r.__select, "change", (function () { var e = this.options[this.selectedIndex].value; o.setValue(e) })), r.domElement.appendChild(r.__select), r } return xc(t, e), yc(t, [{ key: "setValue", value: function (e) { var n = wc(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "setValue", this).call(this, e); return this.__onFinishChange && this.__onFinishChange.call(this, this.getValue()), n } }, { key: "updateDisplay", value: function () { return Bc.isActive(this.__select) ? this : (this.__select.value = this.getValue(), wc(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "updateDisplay", this).call(this)) } }]), t }(Ec), Lc = function (e) { function t(e, n) { vc(this, t); var i = Cc(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this, e, n)), r = i; function s() { r.setValue(r.__input.value) } return i.__input = document.createElement("input"), i.__input.setAttribute("type", "text"), Bc.bind(i.__input, "keyup", s), Bc.bind(i.__input, "change", s), Bc.bind(i.__input, "blur", (function () { r.__onFinishChange && r.__onFinishChange.call(r, r.getValue()) })), Bc.bind(i.__input, "keydown", (function (e) { 13 === e.keyCode && this.blur() })), i.updateDisplay(), i.domElement.appendChild(i.__input), i } return xc(t, e), yc(t, [{ key: "updateDisplay", value: function () { return Bc.isActive(this.__input) || (this.__input.value = this.getValue()), wc(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "updateDisplay", this).call(this) } }]), t }(Ec); function Oc(e) { var t = e.toString(); return t.indexOf(".") > -1 ? t.length - t.indexOf(".") - 1 : 0 } var Nc = function (e) { function t(e, n, i) { vc(this, t); var r = Cc(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this, e, n)), s = i || {}; return r.__min = s.min, r.__max = s.max, r.__step = s.step, Ac.isUndefined(r.__step) ? 0 === r.initialValue ? r.__impliedStep = 1 : r.__impliedStep = Math.pow(10, Math.floor(Math.log(Math.abs(r.initialValue)) / Math.LN10)) / 10 : r.__impliedStep = r.__step, r.__precision = Oc(r.__impliedStep), r } return xc(t, e), yc(t, [{ key: "setValue", value: function (e) { var n = e; return void 0 !== this.__min && n < this.__min ? n = this.__min : void 0 !== this.__max && n > this.__max && (n = this.__max), void 0 !== this.__step && n % this.__step != 0 && (n = Math.round(n / this.__step) * this.__step), wc(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "setValue", this).call(this, n) } }, { key: "min", value: function (e) { return this.__min = e, this } }, { key: "max", value: function (e) { return this.__max = e, this } }, { key: "step", value: function (e) { return this.__step = e, this.__impliedStep = e, this.__precision = Oc(e), this } }]), t }(Ec); var kc = function (e) { function t(e, n, i) { vc(this, t); var r = Cc(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this, e, n, i)); r.__truncationSuspended = !1; var s = r, o = void 0; function a() { s.__onFinishChange && s.__onFinishChange.call(s, s.getValue()) } function l(e) { var t = o - e.clientY; s.setValue(s.getValue() + t * s.__impliedStep), o = e.clientY } function c() { Bc.unbind(window, "mousemove", l), Bc.unbind(window, "mouseup", c), a() } return r.__input = document.createElement("input"), r.__input.setAttribute("type", "text"), Bc.bind(r.__input, "change", (function () { var e = parseFloat(s.__input.value); Ac.isNaN(e) || s.setValue(e) })), Bc.bind(r.__input, "blur", (function () { a() })), Bc.bind(r.__input, "mousedown", (function (e) { Bc.bind(window, "mousemove", l), Bc.bind(window, "mouseup", c), o = e.clientY })), Bc.bind(r.__input, "keydown", (function (e) { 13 === e.keyCode && (s.__truncationSuspended = !0, this.blur(), s.__truncationSuspended = !1, a()) })), r.updateDisplay(), r.domElement.appendChild(r.__input), r } return xc(t, e), yc(t, [{ key: "updateDisplay", value: function () { var e, n, i; return this.__input.value = this.__truncationSuspended ? this.getValue() : (e = this.getValue(), n = this.__precision, i = Math.pow(10, n), Math.round(e * i) / i), wc(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "updateDisplay", this).call(this) } }]), t }(Nc); function Hc(e, t, n, i, r) { return i + (e - t) / (n - t) * (r - i) } var zc = function (e) { function t(e, n, i, r, s) { vc(this, t); var o = Cc(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this, e, n, { min: i, max: r, step: s })), a = o; function l(e) { e.preventDefault(); var t = a.__background.getBoundingClientRect(); return a.setValue(Hc(e.clientX, t.left, t.right, a.__min, a.__max)), !1 } function c() { Bc.unbind(window, "mousemove", l), Bc.unbind(window, "mouseup", c), a.__onFinishChange && a.__onFinishChange.call(a, a.getValue()) } function A(e) { var t = e.touches[0].clientX, n = a.__background.getBoundingClientRect(); a.setValue(Hc(t, n.left, n.right, a.__min, a.__max)) } function u() { Bc.unbind(window, "touchmove", A), Bc.unbind(window, "touchend", u), a.__onFinishChange && a.__onFinishChange.call(a, a.getValue()) } return o.__background = document.createElement("div"), o.__foreground = document.createElement("div"), Bc.bind(o.__background, "mousedown", (function (e) { document.activeElement.blur(), Bc.bind(window, "mousemove", l), Bc.bind(window, "mouseup", c), l(e) })), Bc.bind(o.__background, "touchstart", (function (e) { if (1 !== e.touches.length) return; Bc.bind(window, "touchmove", A), Bc.bind(window, "touchend", u), A(e) })), Bc.addClass(o.__background, "slider"), Bc.addClass(o.__foreground, "slider-fg"), o.updateDisplay(), o.__background.appendChild(o.__foreground), o.domElement.appendChild(o.__background), o } return xc(t, e), yc(t, [{ key: "updateDisplay", value: function () { var e = (this.getValue() - this.__min) / (this.__max - this.__min); return this.__foreground.style.width = 100 * e + "%", wc(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "updateDisplay", this).call(this) } }]), t }(Nc), Fc = function (e) { function t(e, n, i) { vc(this, t); var r = Cc(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this, e, n)), s = r; return r.__button = document.createElement("div"), r.__button.innerHTML = void 0 === i ? "Fire" : i, Bc.bind(r.__button, "click", (function (e) { return e.preventDefault(), s.fire(), !1 })), Bc.addClass(r.__button, "button"), r.domElement.appendChild(r.__button), r } return xc(t, e), yc(t, [{ key: "fire", value: function () { this.__onChange && this.__onChange.call(this), this.getValue().call(this.object), this.__onFinishChange && this.__onFinishChange.call(this, this.getValue()) } }]), t }(Ec), Qc = function (e) { function t(e, n) { vc(this, t); var i = Cc(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this, e, n)); i.__color = new bc(i.getValue()), i.__temp = new bc(0); var r = i; i.domElement = document.createElement("div"), Bc.makeSelectable(i.domElement, !1), i.__selector = document.createElement("div"), i.__selector.className = "selector", i.__saturation_field = document.createElement("div"), i.__saturation_field.className = "saturation-field", i.__field_knob = document.createElement("div"), i.__field_knob.className = "field-knob", i.__field_knob_border = "2px solid ", i.__hue_knob = document.createElement("div"), i.__hue_knob.className = "hue-knob", i.__hue_field = document.createElement("div"), i.__hue_field.className = "hue-field", i.__input = document.createElement("input"), i.__input.type = "text", i.__input_textShadow = "0 1px 1px ", Bc.bind(i.__input, "keydown", (function (e) { 13 === e.keyCode && u.call(this) })), Bc.bind(i.__input, "blur", u), Bc.bind(i.__selector, "mousedown", (function () { Bc.addClass(this, "drag").bind(window, "mouseup", (function () { Bc.removeClass(r.__selector, "drag") })) })), Bc.bind(i.__selector, "touchstart", (function () { Bc.addClass(this, "drag").bind(window, "touchend", (function () { Bc.removeClass(r.__selector, "drag") })) })); var s, o = document.createElement("div"); function a(e) { d(e), Bc.bind(window, "mousemove", d), Bc.bind(window, "touchmove", d), Bc.bind(window, "mouseup", c), Bc.bind(window, "touchend", c) } function l(e) { p(e), Bc.bind(window, "mousemove", p), Bc.bind(window, "touchmove", p), Bc.bind(window, "mouseup", A), Bc.bind(window, "touchend", A) } function c() { Bc.unbind(window, "mousemove", d), Bc.unbind(window, "touchmove", d), Bc.unbind(window, "mouseup", c), Bc.unbind(window, "touchend", c), h() } function A() { Bc.unbind(window, "mousemove", p), Bc.unbind(window, "touchmove", p), Bc.unbind(window, "mouseup", A), Bc.unbind(window, "touchend", A), h() } function u() { var e = pc(this.value); !1 !== e ? (r.__color.__state = e, r.setValue(r.__color.toOriginal())) : this.value = r.__color.toString() } function h() { r.__onFinishChange && r.__onFinishChange.call(r, r.__color.toOriginal()) } function d(e) { -1 === e.type.indexOf("touch") && e.preventDefault(); var t = r.__saturation_field.getBoundingClientRect(), n = e.touches && e.touches[0] || e, i = n.clientX, s = n.clientY, o = (i - t.left) / (t.right - t.left), a = 1 - (s - t.top) / (t.bottom - t.top); return a > 1 ? a = 1 : a < 0 && (a = 0), o > 1 ? o = 1 : o < 0 && (o = 0), r.__color.v = a, r.__color.s = o, r.setValue(r.__color.toOriginal()), !1 } function p(e) { -1 === e.type.indexOf("touch") && e.preventDefault(); var t = r.__hue_field.getBoundingClientRect(), n = 1 - ((e.touches && e.touches[0] || e).clientY - t.top) / (t.bottom - t.top); return n > 1 ? n = 1 : n < 0 && (n = 0), r.__color.h = 360 * n, r.setValue(r.__color.toOriginal()), !1 } return Ac.extend(i.__selector.style, { width: "122px", height: "102px", padding: "3px", backgroundColor: "#222", boxShadow: "0px 1px 3px rgba(0,0,0,0.3)" }), Ac.extend(i.__field_knob.style, { position: "absolute", width: "12px", height: "12px", border: i.__field_knob_border + (i.__color.v < .5 ? "#fff" : "#000"), boxShadow: "0px 1px 3px rgba(0,0,0,0.5)", borderRadius: "12px", zIndex: 1 }), Ac.extend(i.__hue_knob.style, { position: "absolute", width: "15px", height: "2px", borderRight: "4px solid #fff", zIndex: 1 }), Ac.extend(i.__saturation_field.style, { width: "100px", height: "100px", border: "1px solid #555", marginRight: "3px", display: "inline-block", cursor: "pointer" }), Ac.extend(o.style, { width: "100%", height: "100%", background: "none" }), jc(o, "top", "rgba(0,0,0,0)", "#000"), Ac.extend(i.__hue_field.style, { width: "15px", height: "100px", border: "1px solid #555", cursor: "ns-resize", position: "absolute", top: "3px", right: "3px" }), (s = i.__hue_field).style.background = "", s.style.cssText += "background: -moz-linear-gradient(top,  #ff0000 0%, #ff00ff 17%, #0000ff 34%, #00ffff 50%, #00ff00 67%, #ffff00 84%, #ff0000 100%);", s.style.cssText += "background: -webkit-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);", s.style.cssText += "background: -o-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);", s.style.cssText += "background: -ms-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);", s.style.cssText += "background: linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);", Ac.extend(i.__input.style, { outline: "none", textAlign: "center", color: "#fff", border: 0, fontWeight: "bold", textShadow: i.__input_textShadow + "rgba(0,0,0,0.7)" }), Bc.bind(i.__saturation_field, "mousedown", a), Bc.bind(i.__saturation_field, "touchstart", a), Bc.bind(i.__field_knob, "mousedown", a), Bc.bind(i.__field_knob, "touchstart", a), Bc.bind(i.__hue_field, "mousedown", l), Bc.bind(i.__hue_field, "touchstart", l), i.__saturation_field.appendChild(o), i.__selector.appendChild(i.__field_knob), i.__selector.appendChild(i.__saturation_field), i.__selector.appendChild(i.__hue_field), i.__hue_field.appendChild(i.__hue_knob), i.domElement.appendChild(i.__input), i.domElement.appendChild(i.__selector), i.updateDisplay(), i } return xc(t, e), yc(t, [{ key: "updateDisplay", value: function () { var e = pc(this.getValue()); if (!1 !== e) { var t = !1; Ac.each(bc.COMPONENTS, (function (n) { if (!Ac.isUndefined(e[n]) && !Ac.isUndefined(this.__color.__state[n]) && e[n] !== this.__color.__state[n]) return t = !0, {} }), this), t && Ac.extend(this.__color.__state, e) } Ac.extend(this.__temp.__state, this.__color.__state), this.__temp.a = 1; var n = this.__color.v < .5 || this.__color.s > .5 ? 255 : 0, i = 255 - n; Ac.extend(this.__field_knob.style, { marginLeft: 100 * this.__color.s - 7 + "px", marginTop: 100 * (1 - this.__color.v) - 7 + "px", backgroundColor: this.__temp.toHexString(), border: this.__field_knob_border + "rgb(" + n + "," + n + "," + n + ")" }), this.__hue_knob.style.marginTop = 100 * (1 - this.__color.h / 360) + "px", this.__temp.s = 1, this.__temp.v = 1, jc(this.__saturation_field, "left", "#fff", this.__temp.toHexString()), this.__input.value = this.__color.toString(), Ac.extend(this.__input.style, { backgroundColor: this.__color.toHexString(), color: "rgb(" + n + "," + n + "," + n + ")", textShadow: this.__input_textShadow + "rgba(" + i + "," + i + "," + i + ",.7)" }) } }]), t }(Ec), Gc = ["-moz-", "-o-", "-webkit-", "-ms-", ""]; function jc(e, t, n, i) { e.style.background = "", Ac.each(Gc, (function (r) { e.style.cssText += "background: " + r + "linear-gradient(" + t + ", " + n + " 0%, " + i + " 100%); " })) } var Uc = function (e, t) { var n = t || document, i = document.createElement("style"); i.type = "text/css", i.innerHTML = e; var r = n.getElementsByTagName("head")[0]; try { r.appendChild(i) } catch (e) { } }, Vc = '<div id="dg-save" class="dg dialogue">\n\n  Here\'s the new load parameter for your <code>GUI</code>\'s constructor:\n\n  <textarea id="dg-new-constructor"></textarea>\n\n  <div id="dg-save-locally">\n\n    <input id="dg-local-storage" type="checkbox"/> Automatically save\n    values to <code>localStorage</code> on exit.\n\n    <div id="dg-local-explain">The values saved to <code>localStorage</code> will\n      override those passed to <code>dat.GUI</code>\'s constructor. This makes it\n      easier to work incrementally, but <code>localStorage</code> is fragile,\n      and your friends may not see the same values you do.\n\n    </div>\n\n  </div>\n\n</div>', Yc = function (e, t) { var n = e[t]; return Ac.isArray(arguments[2]) || Ac.isObject(arguments[2]) ? new Rc(e, t, arguments[2]) : Ac.isNumber(n) ? Ac.isNumber(arguments[2]) && Ac.isNumber(arguments[3]) ? Ac.isNumber(arguments[4]) ? new zc(e, t, arguments[2], arguments[3], arguments[4]) : new zc(e, t, arguments[2], arguments[3]) : Ac.isNumber(arguments[4]) ? new kc(e, t, { min: arguments[2], max: arguments[3], step: arguments[4] }) : new kc(e, t, { min: arguments[2], max: arguments[3] }) : Ac.isString(n) ? new Lc(e, t) : Ac.isFunction(n) ? new Fc(e, t, "") : Ac.isBoolean(n) ? new Dc(e, t) : null }; var Wc = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function (e) { setTimeout(e, 1e3 / 60) }, Xc = function () { function e() { vc(this, e), this.backgroundElement = document.createElement("div"), Ac.extend(this.backgroundElement.style, { backgroundColor: "rgba(0,0,0,0.8)", top: 0, left: 0, display: "none", zIndex: "1000", opacity: 0, WebkitTransition: "opacity 0.2s linear", transition: "opacity 0.2s linear" }), Bc.makeFullscreen(this.backgroundElement), this.backgroundElement.style.position = "fixed", this.domElement = document.createElement("div"), Ac.extend(this.domElement.style, { position: "fixed", display: "none", zIndex: "1001", opacity: 0, WebkitTransition: "-webkit-transform 0.2s ease-out, opacity 0.2s linear", transition: "transform 0.2s ease-out, opacity 0.2s linear" }), document.body.appendChild(this.backgroundElement), document.body.appendChild(this.domElement); var t = this; Bc.bind(this.backgroundElement, "click", (function () { t.hide() })) } return yc(e, [{ key: "show", value: function () { var e = this; this.backgroundElement.style.display = "block", this.domElement.style.display = "block", this.domElement.style.opacity = 0, this.domElement.style.webkitTransform = "scale(1.1)", this.layout(), Ac.defer((function () { e.backgroundElement.style.opacity = 1, e.domElement.style.opacity = 1, e.domElement.style.webkitTransform = "scale(1)" })) } }, { key: "hide", value: function () { var e = this, t = function t() { e.domElement.style.display = "none", e.backgroundElement.style.display = "none", Bc.unbind(e.domElement, "webkitTransitionEnd", t), Bc.unbind(e.domElement, "transitionend", t), Bc.unbind(e.domElement, "oTransitionEnd", t) }; Bc.bind(this.domElement, "webkitTransitionEnd", t), Bc.bind(this.domElement, "transitionend", t), Bc.bind(this.domElement, "oTransitionEnd", t), this.backgroundElement.style.opacity = 0, this.domElement.style.opacity = 0, this.domElement.style.webkitTransform = "scale(1.1)" } }, { key: "layout", value: function () { this.domElement.style.left = window.innerWidth / 2 - Bc.getWidth(this.domElement) / 2 + "px", this.domElement.style.top = window.innerHeight / 2 - Bc.getHeight(this.domElement) / 2 + "px" } }]), e }(); Uc(function (e) { if (e && "undefined" != typeof window) { var t = document.createElement("style"); return t.setAttribute("type", "text/css"), t.innerHTML = e, document.head.appendChild(t), e } }(".dg ul{list-style:none;margin:0;padding:0;width:100%;clear:both}.dg.ac{position:fixed;top:0;left:0;right:0;height:0;z-index:0}.dg:not(.ac) .main{overflow:hidden}.dg.main{-webkit-transition:opacity .1s linear;-o-transition:opacity .1s linear;-moz-transition:opacity .1s linear;transition:opacity .1s linear}.dg.main.taller-than-window{overflow-y:auto}.dg.main.taller-than-window .close-button{opacity:1;margin-top:-1px;border-top:1px solid #2c2c2c}.dg.main ul.closed .close-button{opacity:1 !important}.dg.main:hover .close-button,.dg.main .close-button.drag{opacity:1}.dg.main .close-button{-webkit-transition:opacity .1s linear;-o-transition:opacity .1s linear;-moz-transition:opacity .1s linear;transition:opacity .1s linear;border:0;line-height:19px;height:20px;cursor:pointer;text-align:center;background-color:#000}.dg.main .close-button.close-top{position:relative}.dg.main .close-button.close-bottom{position:absolute}.dg.main .close-button:hover{background-color:#111}.dg.a{float:right;margin-right:15px;overflow-y:visible}.dg.a.has-save>ul.close-top{margin-top:0}.dg.a.has-save>ul.close-bottom{margin-top:27px}.dg.a.has-save>ul.closed{margin-top:0}.dg.a .save-row{top:0;z-index:1002}.dg.a .save-row.close-top{position:relative}.dg.a .save-row.close-bottom{position:fixed}.dg li{-webkit-transition:height .1s ease-out;-o-transition:height .1s ease-out;-moz-transition:height .1s ease-out;transition:height .1s ease-out;-webkit-transition:overflow .1s linear;-o-transition:overflow .1s linear;-moz-transition:overflow .1s linear;transition:overflow .1s linear}.dg li:not(.folder){cursor:auto;height:27px;line-height:27px;padding:0 4px 0 5px}.dg li.folder{padding:0;border-left:4px solid rgba(0,0,0,0)}.dg li.title{cursor:pointer;margin-left:-4px}.dg .closed li:not(.title),.dg .closed ul li,.dg .closed ul li>*{height:0;overflow:hidden;border:0}.dg .cr{clear:both;padding-left:3px;height:27px;overflow:hidden}.dg .property-name{cursor:default;float:left;clear:left;width:40%;overflow:hidden;text-overflow:ellipsis}.dg .c{float:left;width:60%;position:relative}.dg .c input[type=text]{border:0;margin-top:4px;padding:3px;width:100%;float:right}.dg .has-slider input[type=text]{width:30%;margin-left:0}.dg .slider{float:left;width:66%;margin-left:-5px;margin-right:0;height:19px;margin-top:4px}.dg .slider-fg{height:100%}.dg .c input[type=checkbox]{margin-top:7px}.dg .c select{margin-top:5px}.dg .cr.function,.dg .cr.function .property-name,.dg .cr.function *,.dg .cr.boolean,.dg .cr.boolean *{cursor:pointer}.dg .cr.color{overflow:visible}.dg .selector{display:none;position:absolute;margin-left:-9px;margin-top:23px;z-index:10}.dg .c:hover .selector,.dg .selector.drag{display:block}.dg li.save-row{padding:0}.dg li.save-row .button{display:inline-block;padding:0px 6px}.dg.dialogue{background-color:#222;width:460px;padding:15px;font-size:13px;line-height:15px}#dg-new-constructor{padding:10px;color:#222;font-family:Monaco, monospace;font-size:10px;border:0;resize:none;box-shadow:inset 1px 1px 1px #888;word-wrap:break-word;margin:12px 0;display:block;width:440px;overflow-y:scroll;height:100px;position:relative}#dg-local-explain{display:none;font-size:11px;line-height:17px;border-radius:3px;background-color:#333;padding:8px;margin-top:10px}#dg-local-explain code{font-size:10px}#dat-gui-save-locally{display:none}.dg{color:#eee;font:11px 'Lucida Grande', sans-serif;text-shadow:0 -1px 0 #111}.dg.main::-webkit-scrollbar{width:5px;background:#1a1a1a}.dg.main::-webkit-scrollbar-corner{height:0;display:none}.dg.main::-webkit-scrollbar-thumb{border-radius:5px;background:#676767}.dg li:not(.folder){background:#1a1a1a;border-bottom:1px solid #2c2c2c}.dg li.save-row{line-height:25px;background:#dad5cb;border:0}.dg li.save-row select{margin-left:5px;width:108px}.dg li.save-row .button{margin-left:5px;margin-top:1px;border-radius:2px;font-size:9px;line-height:7px;padding:4px 4px 5px 4px;background:#c5bdad;color:#fff;text-shadow:0 1px 0 #b0a58f;box-shadow:0 -1px 0 #b0a58f;cursor:pointer}.dg li.save-row .button.gears{background:#c5bdad url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAANCAYAAAB/9ZQ7AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAQJJREFUeNpiYKAU/P//PwGIC/ApCABiBSAW+I8AClAcgKxQ4T9hoMAEUrxx2QSGN6+egDX+/vWT4e7N82AMYoPAx/evwWoYoSYbACX2s7KxCxzcsezDh3evFoDEBYTEEqycggWAzA9AuUSQQgeYPa9fPv6/YWm/Acx5IPb7ty/fw+QZblw67vDs8R0YHyQhgObx+yAJkBqmG5dPPDh1aPOGR/eugW0G4vlIoTIfyFcA+QekhhHJhPdQxbiAIguMBTQZrPD7108M6roWYDFQiIAAv6Aow/1bFwXgis+f2LUAynwoIaNcz8XNx3Dl7MEJUDGQpx9gtQ8YCueB+D26OECAAQDadt7e46D42QAAAABJRU5ErkJggg==) 2px 1px no-repeat;height:7px;width:8px}.dg li.save-row .button:hover{background-color:#bab19e;box-shadow:0 -1px 0 #b0a58f}.dg li.folder{border-bottom:0}.dg li.title{padding-left:16px;background:#000 url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlI+hKgFxoCgAOw==) 6px 10px no-repeat;cursor:pointer;border-bottom:1px solid rgba(255,255,255,0.2)}.dg .closed li.title{background-image:url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlGIWqMCbWAEAOw==)}.dg .cr.boolean{border-left:3px solid #806787}.dg .cr.color{border-left:3px solid}.dg .cr.function{border-left:3px solid #e61d5f}.dg .cr.number{border-left:3px solid #2FA1D6}.dg .cr.number input[type=text]{color:#2FA1D6}.dg .cr.string{border-left:3px solid #1ed36f}.dg .cr.string input[type=text]{color:#1ed36f}.dg .cr.function:hover,.dg .cr.boolean:hover{background:#111}.dg .c input[type=text]{background:#303030;outline:none}.dg .c input[type=text]:hover{background:#3c3c3c}.dg .c input[type=text]:focus{background:#494949;color:#fff}.dg .c .slider{background:#303030;cursor:ew-resize}.dg .c .slider-fg{background:#2FA1D6;max-width:100%}.dg .c .slider:hover{background:#3c3c3c}.dg .c .slider:hover .slider-fg{background:#44abda}\n")); var Jc = function () { try { return !!window.localStorage } catch (e) { return !1 } }(), Kc = void 0, Zc = !0, qc = void 0, _c = !1, $c = [], eA = function e(t) { var n = this, i = t || {}; this.domElement = document.createElement("div"), this.__ul = document.createElement("ul"), this.domElement.appendChild(this.__ul), Bc.addClass(this.domElement, "dg"), this.__folders = {}, this.__controllers = [], this.__rememberedObjects = [], this.__rememberedObjectIndecesToControllers = [], this.__listening = [], i = Ac.defaults(i, { closeOnTop: !1, autoPlace: !0, width: e.DEFAULT_WIDTH }), i = Ac.defaults(i, { resizable: i.autoPlace, hideable: i.autoPlace }), Ac.isUndefined(i.load) ? i.load = { preset: "Default" } : i.preset && (i.load.preset = i.preset), Ac.isUndefined(i.parent) && i.hideable && $c.push(this), i.resizable = Ac.isUndefined(i.parent) && i.resizable, i.autoPlace && Ac.isUndefined(i.scrollable) && (i.scrollable = !0); var r, s = Jc && "true" === localStorage.getItem(oA(this, "isLocal")), o = void 0, a = void 0; if (Object.defineProperties(this, { parent: { get: function () { return i.parent } }, scrollable: { get: function () { return i.scrollable } }, autoPlace: { get: function () { return i.autoPlace } }, closeOnTop: { get: function () { return i.closeOnTop } }, preset: { get: function () { return n.parent ? n.getRoot().preset : i.load.preset }, set: function (e) { n.parent ? n.getRoot().preset = e : i.load.preset = e, function (e) { for (var t = 0; t < e.__preset_select.length; t++)e.__preset_select[t].value === e.preset && (e.__preset_select.selectedIndex = t) }(this), n.revert() } }, width: { get: function () { return i.width }, set: function (e) { i.width = e, uA(n, e) } }, name: { get: function () { return i.name }, set: function (e) { i.name = e, a && (a.innerHTML = i.name) } }, closed: { get: function () { return i.closed }, set: function (t) { i.closed = t, i.closed ? Bc.addClass(n.__ul, e.CLASS_CLOSED) : Bc.removeClass(n.__ul, e.CLASS_CLOSED), this.onResize(), n.__closeButton && (n.__closeButton.innerHTML = t ? e.TEXT_OPEN : e.TEXT_CLOSED) } }, load: { get: function () { return i.load } }, useLocalStorage: { get: function () { return s }, set: function (e) { Jc && (s = e, e ? Bc.bind(window, "unload", o) : Bc.unbind(window, "unload", o), localStorage.setItem(oA(n, "isLocal"), e)) } } }), Ac.isUndefined(i.parent)) { if (this.closed = i.closed || !1, Bc.addClass(this.domElement, e.CLASS_MAIN), Bc.makeSelectable(this.domElement, !1), Jc && s) { n.useLocalStorage = !0; var l = localStorage.getItem(oA(this, "gui")); l && (i.load = JSON.parse(l)) } this.__closeButton = document.createElement("div"), this.__closeButton.innerHTML = e.TEXT_CLOSED, Bc.addClass(this.__closeButton, e.CLASS_CLOSE_BUTTON), i.closeOnTop ? (Bc.addClass(this.__closeButton, e.CLASS_CLOSE_TOP), this.domElement.insertBefore(this.__closeButton, this.domElement.childNodes[0])) : (Bc.addClass(this.__closeButton, e.CLASS_CLOSE_BOTTOM), this.domElement.appendChild(this.__closeButton)), Bc.bind(this.__closeButton, "click", (function () { n.closed = !n.closed })) } else { void 0 === i.closed && (i.closed = !0); var c = document.createTextNode(i.name); Bc.addClass(c, "controller-name"), a = tA(n, c); Bc.addClass(this.__ul, e.CLASS_CLOSED), Bc.addClass(a, "title"), Bc.bind(a, "click", (function (e) { return e.preventDefault(), n.closed = !n.closed, !1 })), i.closed || (this.closed = !1) } i.autoPlace && (Ac.isUndefined(i.parent) && (Zc && (qc = document.createElement("div"), Bc.addClass(qc, "dg"), Bc.addClass(qc, e.CLASS_AUTO_PLACE_CONTAINER), document.body.appendChild(qc), Zc = !1), qc.appendChild(this.domElement), Bc.addClass(this.domElement, e.CLASS_AUTO_PLACE)), this.parent || uA(n, i.width)), this.__resizeHandler = function () { n.onResizeDebounced() }, Bc.bind(window, "resize", this.__resizeHandler), Bc.bind(this.__ul, "webkitTransitionEnd", this.__resizeHandler), Bc.bind(this.__ul, "transitionend", this.__resizeHandler), Bc.bind(this.__ul, "oTransitionEnd", this.__resizeHandler), this.onResize(), i.resizable && AA(this), o = function () { Jc && "true" === localStorage.getItem(oA(n, "isLocal")) && localStorage.setItem(oA(n, "gui"), JSON.stringify(n.getSaveObject())) }, this.saveToLocalStorageIfPossible = o, i.parent || ((r = n.getRoot()).width += 1, Ac.defer((function () { r.width -= 1 }))) }; function tA(e, t, n) { var i = document.createElement("li"); return t && i.appendChild(t), n ? e.__ul.insertBefore(i, n) : e.__ul.appendChild(i), e.onResize(), i } function nA(e) { Bc.unbind(window, "resize", e.__resizeHandler), e.saveToLocalStorageIfPossible && Bc.unbind(window, "unload", e.saveToLocalStorageIfPossible) } function iA(e, t) { var n = e.__preset_select[e.__preset_select.selectedIndex]; n.innerHTML = t ? n.value + "*" : n.value } function rA(e, t) { var n = e.getRoot(), i = n.__rememberedObjects.indexOf(t.object); if (-1 !== i) { var r = n.__rememberedObjectIndecesToControllers[i]; if (void 0 === r && (r = {}, n.__rememberedObjectIndecesToControllers[i] = r), r[t.property] = t, n.load && n.load.remembered) { var s = n.load.remembered, o = void 0; if (s[e.preset]) o = s[e.preset]; else { if (!s.Default) return; o = s.Default } if (o[i] && void 0 !== o[i][t.property]) { var a = o[i][t.property]; t.initialValue = a, t.setValue(a) } } } } function sA(e, t, n, i) { if (void 0 === t[n]) throw new Error('Object "' + t + '" has no property "' + n + '"'); var r = void 0; if (i.color) r = new Qc(t, n); else { var s = [t, n].concat(i.factoryArgs); r = Yc.apply(e, s) } i.before instanceof Ec && (i.before = i.before.__li), rA(e, r), Bc.addClass(r.domElement, "c"); var o = document.createElement("span"); Bc.addClass(o, "property-name"), o.innerHTML = r.property; var a = document.createElement("div"); a.appendChild(o), a.appendChild(r.domElement); var l = tA(e, a, i.before); return Bc.addClass(l, eA.CLASS_CONTROLLER_ROW), r instanceof Qc ? Bc.addClass(l, "color") : Bc.addClass(l, mc(r.getValue())), function (e, t, n) { if (n.__li = t, n.__gui = e, Ac.extend(n, { options: function (t) { if (arguments.length > 1) { var i = n.__li.nextElementSibling; return n.remove(), sA(e, n.object, n.property, { before: i, factoryArgs: [Ac.toArray(arguments)] }) } if (Ac.isArray(t) || Ac.isObject(t)) { var r = n.__li.nextElementSibling; return n.remove(), sA(e, n.object, n.property, { before: r, factoryArgs: [t] }) } }, name: function (e) { return n.__li.firstElementChild.firstElementChild.innerHTML = e, n }, listen: function () { return n.__gui.listen(n), n }, remove: function () { return n.__gui.remove(n), n } }), n instanceof zc) { var i = new kc(n.object, n.property, { min: n.__min, max: n.__max, step: n.__step }); Ac.each(["updateDisplay", "onChange", "onFinishChange", "step", "min", "max"], (function (e) { var t = n[e], r = i[e]; n[e] = i[e] = function () { var e = Array.prototype.slice.call(arguments); return r.apply(i, e), t.apply(n, e) } })), Bc.addClass(t, "has-slider"), n.domElement.insertBefore(i.domElement, n.domElement.firstElementChild) } else if (n instanceof kc) { var r = function (t) { if (Ac.isNumber(n.__min) && Ac.isNumber(n.__max)) { var i = n.__li.firstElementChild.firstElementChild.innerHTML, r = n.__gui.__listening.indexOf(n) > -1; n.remove(); var s = sA(e, n.object, n.property, { before: n.__li.nextElementSibling, factoryArgs: [n.__min, n.__max, n.__step] }); return s.name(i), r && s.listen(), s } return t }; n.min = Ac.compose(r, n.min), n.max = Ac.compose(r, n.max) } else n instanceof Dc ? (Bc.bind(t, "click", (function () { Bc.fakeEvent(n.__checkbox, "click") })), Bc.bind(n.__checkbox, "click", (function (e) { e.stopPropagation() }))) : n instanceof Fc ? (Bc.bind(t, "click", (function () { Bc.fakeEvent(n.__button, "click") })), Bc.bind(t, "mouseover", (function () { Bc.addClass(n.__button, "hover") })), Bc.bind(t, "mouseout", (function () { Bc.removeClass(n.__button, "hover") }))) : n instanceof Qc && (Bc.addClass(t, "color"), n.updateDisplay = Ac.compose((function (e) { return t.style.borderLeftColor = n.__color.toString(), e }), n.updateDisplay), n.updateDisplay()); n.setValue = Ac.compose((function (t) { return e.getRoot().__preset_select && n.isModified() && iA(e.getRoot(), !0), t }), n.setValue) }(e, l, r), e.__controllers.push(r), r } function oA(e, t) { return document.location.href + "." + t } function aA(e, t, n) { var i = document.createElement("option"); i.innerHTML = t, i.value = t, e.__preset_select.appendChild(i), n && (e.__preset_select.selectedIndex = e.__preset_select.length - 1) } function lA(e, t) { t.style.display = e.useLocalStorage ? "block" : "none" } function cA(e) { var t = e.__save_row = document.createElement("li"); Bc.addClass(e.domElement, "has-save"), e.__ul.insertBefore(t, e.__ul.firstChild), Bc.addClass(t, "save-row"); var n = document.createElement("span"); n.innerHTML = "&nbsp;", Bc.addClass(n, "button gears"); var i = document.createElement("span"); i.innerHTML = "Save", Bc.addClass(i, "button"), Bc.addClass(i, "save"); var r = document.createElement("span"); r.innerHTML = "New", Bc.addClass(r, "button"), Bc.addClass(r, "save-as"); var s = document.createElement("span"); s.innerHTML = "Revert", Bc.addClass(s, "button"), Bc.addClass(s, "revert"); var o = e.__preset_select = document.createElement("select"); if (e.load && e.load.remembered ? Ac.each(e.load.remembered, (function (t, n) { aA(e, n, n === e.preset) })) : aA(e, "Default", !1), Bc.bind(o, "change", (function () { for (var t = 0; t < e.__preset_select.length; t++)e.__preset_select[t].innerHTML = e.__preset_select[t].value; e.preset = this.value })), t.appendChild(o), t.appendChild(n), t.appendChild(i), t.appendChild(r), t.appendChild(s), Jc) { var a = document.getElementById("dg-local-explain"), l = document.getElementById("dg-local-storage"); document.getElementById("dg-save-locally").style.display = "block", "true" === localStorage.getItem(oA(0, "isLocal")) && l.setAttribute("checked", "checked"), lA(e, a), Bc.bind(l, "change", (function () { e.useLocalStorage = !e.useLocalStorage, lA(e, a) })) } var c = document.getElementById("dg-new-constructor"); Bc.bind(c, "keydown", (function (e) { !e.metaKey || 67 !== e.which && 67 !== e.keyCode || Kc.hide() })), Bc.bind(n, "click", (function () { c.innerHTML = JSON.stringify(e.getSaveObject(), void 0, 2), Kc.show(), c.focus(), c.select() })), Bc.bind(i, "click", (function () { e.save() })), Bc.bind(r, "click", (function () { var t = prompt("Enter a new preset name."); t && e.saveAs(t) })), Bc.bind(s, "click", (function () { e.revert() })) } function AA(e) { var t = void 0; function n(n) { return n.preventDefault(), e.width += t - n.clientX, e.onResize(), t = n.clientX, !1 } function i() { Bc.removeClass(e.__closeButton, eA.CLASS_DRAG), Bc.unbind(window, "mousemove", n), Bc.unbind(window, "mouseup", i) } function r(r) { return r.preventDefault(), t = r.clientX, Bc.addClass(e.__closeButton, eA.CLASS_DRAG), Bc.bind(window, "mousemove", n), Bc.bind(window, "mouseup", i), !1 } e.__resize_handle = document.createElement("div"), Ac.extend(e.__resize_handle.style, { width: "6px", marginLeft: "-3px", height: "200px", cursor: "ew-resize", position: "absolute" }), Bc.bind(e.__resize_handle, "mousedown", r), Bc.bind(e.__closeButton, "mousedown", r), e.domElement.insertBefore(e.__resize_handle, e.domElement.firstElementChild) } function uA(e, t) { e.domElement.style.width = t + "px", e.__save_row && e.autoPlace && (e.__save_row.style.width = t + "px"), e.__closeButton && (e.__closeButton.style.width = t + "px") } function hA(e, t) { var n = {}; return Ac.each(e.__rememberedObjects, (function (i, r) { var s = {}, o = e.__rememberedObjectIndecesToControllers[r]; Ac.each(o, (function (e, n) { s[n] = t ? e.initialValue : e.getValue() })), n[r] = s })), n } eA.toggleHide = function () { _c = !_c, Ac.each($c, (function (e) { e.domElement.style.display = _c ? "none" : "" })) }, eA.CLASS_AUTO_PLACE = "a", eA.CLASS_AUTO_PLACE_CONTAINER = "ac", eA.CLASS_MAIN = "main", eA.CLASS_CONTROLLER_ROW = "cr", eA.CLASS_TOO_TALL = "taller-than-window", eA.CLASS_CLOSED = "closed", eA.CLASS_CLOSE_BUTTON = "close-button", eA.CLASS_CLOSE_TOP = "close-top", eA.CLASS_CLOSE_BOTTOM = "close-bottom", eA.CLASS_DRAG = "drag", eA.DEFAULT_WIDTH = 245, eA.TEXT_CLOSED = "Close Controls", eA.TEXT_OPEN = "Open Controls", eA._keydownHandler = function (e) { "text" === document.activeElement.type || 72 !== e.which && 72 !== e.keyCode || eA.toggleHide() }, Bc.bind(window, "keydown", eA._keydownHandler, !1), Ac.extend(eA.prototype, { add: function (e, t) { return sA(this, e, t, { factoryArgs: Array.prototype.slice.call(arguments, 2) }) }, addColor: function (e, t) { return sA(this, e, t, { color: !0 }) }, remove: function (e) { this.__ul.removeChild(e.__li), this.__controllers.splice(this.__controllers.indexOf(e), 1); var t = this; Ac.defer((function () { t.onResize() })) }, destroy: function () { if (this.parent) throw new Error("Only the root GUI should be removed with .destroy(). For subfolders, use gui.removeFolder(folder) instead."); this.autoPlace && qc.removeChild(this.domElement); var e = this; Ac.each(this.__folders, (function (t) { e.removeFolder(t) })), Bc.unbind(window, "keydown", eA._keydownHandler, !1), nA(this) }, addFolder: function (e) { if (void 0 !== this.__folders[e]) throw new Error('You already have a folder in this GUI by the name "' + e + '"'); var t = { name: e, parent: this }; t.autoPlace = this.autoPlace, this.load && this.load.folders && this.load.folders[e] && (t.closed = this.load.folders[e].closed, t.load = this.load.folders[e]); var n = new eA(t); this.__folders[e] = n; var i = tA(this, n.domElement); return Bc.addClass(i, "folder"), n }, removeFolder: function (e) { this.__ul.removeChild(e.domElement.parentElement), delete this.__folders[e.name], this.load && this.load.folders && this.load.folders[e.name] && delete this.load.folders[e.name], nA(e); var t = this; Ac.each(e.__folders, (function (t) { e.removeFolder(t) })), Ac.defer((function () { t.onResize() })) }, open: function () { this.closed = !1 }, close: function () { this.closed = !0 }, hide: function () { this.domElement.style.display = "none" }, show: function () { this.domElement.style.display = "" }, onResize: function () { var e = this.getRoot(); if (e.scrollable) { var t = Bc.getOffset(e.__ul).top, n = 0; Ac.each(e.__ul.childNodes, (function (t) { e.autoPlace && t === e.__save_row || (n += Bc.getHeight(t)) })), window.innerHeight - t - 20 < n ? (Bc.addClass(e.domElement, eA.CLASS_TOO_TALL), e.__ul.style.height = window.innerHeight - t - 20 + "px") : (Bc.removeClass(e.domElement, eA.CLASS_TOO_TALL), e.__ul.style.height = "auto") } e.__resize_handle && Ac.defer((function () { e.__resize_handle.style.height = e.__ul.offsetHeight + "px" })), e.__closeButton && (e.__closeButton.style.width = e.width + "px") }, onResizeDebounced: Ac.debounce((function () { this.onResize() }), 50), remember: function () { if (Ac.isUndefined(Kc) && ((Kc = new Xc).domElement.innerHTML = Vc), this.parent) throw new Error("You can only call remember on a top level GUI."); var e = this; Ac.each(Array.prototype.slice.call(arguments), (function (t) { 0 === e.__rememberedObjects.length && cA(e), -1 === e.__rememberedObjects.indexOf(t) && e.__rememberedObjects.push(t) })), this.autoPlace && uA(this, this.width) }, getRoot: function () { for (var e = this; e.parent;)e = e.parent; return e }, getSaveObject: function () { var e = this.load; return e.closed = this.closed, this.__rememberedObjects.length > 0 && (e.preset = this.preset, e.remembered || (e.remembered = {}), e.remembered[this.preset] = hA(this)), e.folders = {}, Ac.each(this.__folders, (function (t, n) { e.folders[n] = t.getSaveObject() })), e }, save: function () { this.load.remembered || (this.load.remembered = {}), this.load.remembered[this.preset] = hA(this), iA(this, !1), this.saveToLocalStorageIfPossible() }, saveAs: function (e) { this.load.remembered || (this.load.remembered = {}, this.load.remembered.Default = hA(this, !0)), this.load.remembered[e] = hA(this), this.preset = e, aA(this, e, !0), this.saveToLocalStorageIfPossible() }, revert: function (e) { Ac.each(this.__controllers, (function (t) { this.getRoot().load.remembered ? rA(e || this.getRoot(), t) : t.setValue(t.initialValue), t.__onFinishChange && t.__onFinishChange.call(t, t.getValue()) }), this), Ac.each(this.__folders, (function (e) { e.revert(e) })), e || iA(this.getRoot(), !1) }, listen: function (e) { var t = 0 === this.__listening.length; this.__listening.push(e), t && function e(t) { 0 !== t.length && Wc.call(window, (function () { e(t) })); Ac.each(t, (function (e) { e.updateDisplay() })) }(this.__listening) }, updateDisplay: function () { Ac.each(this.__controllers, (function (e) { e.updateDisplay() })), Ac.each(this.__folders, (function (e) { e.updateDisplay() })) } }); function dA(e) { return (dA = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) { return typeof e } : function (e) { return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e })(e) } function pA(e, t) { for (var n = 0; n < t.length; n++) { var i = t[n]; i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i) } } function fA(e, t) { return (fA = Object.setPrototypeOf || function (e, t) { return e.__proto__ = t, e })(e, t) } function gA(e) { var t = function () { if ("undefined" == typeof Reflect || !Reflect.construct) return !1; if (Reflect.construct.sham) return !1; if ("function" == typeof Proxy) return !0; try { return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function () { }))), !0 } catch (e) { return !1 } }(); return function () { var n, i = vA(e); if (t) { var r = vA(this).constructor; n = Reflect.construct(i, arguments, r) } else n = i.apply(this, arguments); return mA(this, n) } } function mA(e, t) { return !t || "object" !== dA(t) && "function" != typeof t ? function (e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e }(e) : t } function vA(e) { return (vA = Object.setPrototypeOf ? Object.getPrototypeOf : function (e) { return e.__proto__ || Object.getPrototypeOf(e) })(e) } var yA = ["positionStart", "startTime", "velocity", "acceleration", "color", "endColor", "size", "lifeTime"], wA = function (e) { !function (e, t) { if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function"); e.prototype = Object.create(t && t.prototype, { constructor: { value: e, writable: !0, configurable: !0 } }), t && fA(e, t) }(s, e); var t, n, i, r = gA(s); function s(e) { var t, n; for (function (e, t) { if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function") }(this, s), e = e || {}, (t = r.call(this)).blending = e.blending ? e.blending : 1, t.PARTICLE_COUNT = e.maxParticles || 100, t.PARTICLE_CURSOR = 0, t.time = 0, t.offset = 0, t.count = 0, t.DPR = Math.min(window.devicePixelRatio, 2), t.particleUpdate = !1, t.onTick = e.onTick, t.reverseTime = e.reverseTime, t.fadeIn = e.fadeIn || 1, 0 === t.fadeIn && (t.fadeIn = .001), t.fadeOut = e.fadeOut || 1, 0 === t.fadeOut && (t.fadeOut = .001), t.rand = [], n = 1e5; n > 0; n--)t.rand.push(Math.random() - .5); if (t.i = n, t.sprite = e.particleSpriteTex || null, !t.sprite) throw new Error("No particle sprite texture specified"); return t.sprite.wrapS = t.sprite.wrapT = 1e3, t._createMaterial(), t._createGeometry(), t._createMesh(), t } return t = s, (n = [{ key: "update", value: function (e, t) { this.time += e, this.material.uniforms.uTime.value = this.time, this.onTick && this.onTick(this, this.time), this._geometryUpdate() } }, { key: "spawnParticle", value: function (e) { var t = new O, n = new O, i = new O, r = new nt, s = new nt, o = this.geometry.getAttribute("positionStart"), a = this.geometry.getAttribute("startTime"), l = this.geometry.getAttribute("velocity"), c = this.geometry.getAttribute("acceleration"), A = this.geometry.getAttribute("color"), u = this.geometry.getAttribute("endColor"), h = this.geometry.getAttribute("size"), d = this.geometry.getAttribute("lifeTime"); t = void 0 !== (e = e || {}).position ? t.copy(e.position) : t.set(0, 0, 0), n = void 0 !== e.velocity ? n.copy(e.velocity) : n.set(0, 0, 0), i = void 0 !== e.acceleration ? i.copy(e.acceleration) : i.set(0, 0, 0), r = void 0 !== e.color ? r.copy(e.color) : r.set(16777215), s = void 0 !== e.endColor ? s.copy(e.endColor) : s.copy(r); var p = void 0 !== e.lifetime ? e.lifetime : 5, f = void 0 !== e.size ? e.size : 10, g = void 0 !== e.sizeRandomness ? e.sizeRandomness : 0; void 0 !== this.DPR && (f *= this.DPR); var m = this.PARTICLE_CURSOR; o.array[3 * m + 0] = t.x, o.array[3 * m + 1] = t.y, o.array[3 * m + 2] = t.z, l.array[3 * m + 0] = n.x, l.array[3 * m + 1] = n.y, l.array[3 * m + 2] = n.z, c.array[3 * m + 0] = i.x, c.array[3 * m + 1] = i.y, c.array[3 * m + 2] = i.z, A.array[3 * m + 0] = r.r, A.array[3 * m + 1] = r.g, A.array[3 * m + 2] = r.b, u.array[3 * m + 0] = s.r, u.array[3 * m + 1] = s.g, u.array[3 * m + 2] = s.b, h.array[m] = f + this._random() * g, d.array[m] = p, a.array[m] = this.time + .02 * this._random(), 0 === this.offset && (this.offset = this.PARTICLE_CURSOR), this.count++, this.PARTICLE_CURSOR++, this.PARTICLE_CURSOR >= this.PARTICLE_COUNT && (this.PARTICLE_CURSOR = 0), this.particleUpdate = !0 } }, { key: "_createMaterial", value: function () { this.material = new jt({ transparent: !0, depthWrite: !1, uniforms: { uTime: { value: 0 }, uScale: { value: 1 }, tSprite: { value: this.sprite }, reverseTime: { value: this.reverseTime }, fadeIn: { value: this.fadeIn }, fadeOut: { value: this.fadeOut } }, blending: this.blending, vertexShader: "#define GLSLIFY 1\n uniform float uTime;\nuniform float uScale;\nuniform bool reverseTime;\nuniform float fadeIn;\nuniform float fadeOut;\n\nattribute vec3 positionStart;\nattribute float startTime;\nattribute vec3 velocity;\nattribute vec3 acceleration;\nattribute vec3 color;\nattribute vec3 endColor;\nattribute float size;\nattribute float lifeTime;\n\nvarying vec4 vColor;\nvarying vec4 vEndColor;\nvarying float lifeLeft;\nvarying float alpha;\n\nvoid main() {\n    vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n    vec3 newPosition;\n    float timeElapsed = uTime - startTime;\n    \n    if(reverseTime) timeElapsed = lifeTime - timeElapsed;\n    if(timeElapsed < fadeIn) {\n        alpha = timeElapsed/fadeIn;\n    }\n    if(timeElapsed >= fadeIn && timeElapsed <= (lifeTime - fadeOut)) {\n        alpha = 1.0;\n    }\n    if(timeElapsed > (lifeTime - fadeOut)) {\n        alpha = 1.0 - (timeElapsed - (lifeTime-fadeOut))/fadeOut;\n    }\n    \n    lifeLeft = 1.0 - ( timeElapsed / lifeTime );\n   gl_PointSize = (size * uScale) * ( 10.0 );// * lifeLeft;\n    newPosition = positionStart \n        + (velocity * timeElapsed)\n        + (acceleration * 0.5 * timeElapsed * timeElapsed)\n        ;\n    if (lifeLeft < 0.0) { \n        lifeLeft = 0.0; \n        gl_PointSize = 0.;\n    }\n    //while active use the new position\n    if( timeElapsed > 0.0 ) {\n        gl_Position = projectionMatrix * modelViewMatrix * vec4( newPosition, 1.0 );\n    } else {\n        //if dead use the initial position and set point size to 0\n        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n        lifeLeft = 0.0;\n        gl_PointSize = 0.;\n    }\n    \n    // varyings\n    vColor = vec4( color, 1.0 );\n    vEndColor = vec4( endColor, 1.0);\n}", fragmentShader: "#define GLSLIFY 1\nvarying vec4 vColor;\nvarying vec4 vEndColor;\nvarying float lifeLeft;\nvarying float alpha;\nuniform sampler2D tSprite;\nvoid main() {\n    // color based on particle texture and the lifeLeft. \n    // if lifeLeft is 0 then make invisible\n    vec4 tex = texture2D( tSprite, gl_PointCoord );\n    vec4 color = mix(vColor, vEndColor, 1.0-lifeLeft);\n    gl_FragColor = vec4( color.rgb*tex.rgb, alpha * tex.a);\n}" }), this.material.defaultAttributeValues.particlePositionsStartTime = [0, 0, 0, 0], this.material.defaultAttributeValues.particleVelColSizeLife = [0, 0, 0, 0] } }, { key: "_createGeometry", value: function () { this.geometry = new vt, this.geometry.setAttribute("position", new ot(new Float32Array(3 * this.PARTICLE_COUNT), 3).setUsage(35048)), this.geometry.setAttribute("positionStart", new ot(new Float32Array(3 * this.PARTICLE_COUNT), 3).setUsage(35048)), this.geometry.setAttribute("velocity", new ot(new Float32Array(3 * this.PARTICLE_COUNT), 3).setUsage(35048)), this.geometry.setAttribute("acceleration", new ot(new Float32Array(3 * this.PARTICLE_COUNT), 3).setUsage(35048)), this.geometry.setAttribute("color", new ot(new Float32Array(3 * this.PARTICLE_COUNT), 3).setUsage(35048)), this.geometry.setAttribute("endColor", new ot(new Float32Array(3 * this.PARTICLE_COUNT), 3).setUsage(35048)), this.geometry.setAttribute("startTime", new ot(new Float32Array(this.PARTICLE_COUNT), 1).setUsage(35048)), this.geometry.setAttribute("size", new ot(new Float32Array(this.PARTICLE_COUNT), 1).setUsage(35048)), this.geometry.setAttribute("lifeTime", new ot(new Float32Array(this.PARTICLE_COUNT), 1).setUsage(35048)) } }, { key: "_createMesh", value: function () { this.particleSystem = new ms(this.geometry, this.material), this.particleSystem.frustumCulled = !1, this.add(this.particleSystem) } }, { key: "_geometryUpdate", value: function () { if (!0 === this.particleUpdate) { this.particleUpdate = !1; for (var e = 0; e < yA.length; e++) { var t = this.geometry.getAttribute(yA[e]); this.offset + this.count < this.PARTICLE_COUNT ? (t.updateRange.offset = this.offset * t.itemSize, t.updateRange.count = this.count * t.itemSize) : (t.updateRange.offset = 0, t.updateRange.count = -1), t.needsUpdate = !0 } this.offset = 0, this.count = 0 } } }, { key: "_random", value: function () { return ++this.i >= this.rand.length ? this.rand[this.i = 1] : this.rand[this.i] } }, { key: "_dispose", value: function () { this.material.dispose(), this.sprite.dispose(), this.geometry.dispose() } }]) && pA(t.prototype, n), i && pA(t, i), s }(ke), xA = { loosePiece: 10, normalPiece: 11, platformPieceType: [{ type: 10 }, { type: 11 }], platformOffset: 5, levelGenerator: [{ level: 0, count: 2 }, { level: 0, count: 5 }, { level: 1, count: 5 }, { level: 0, count: 5 }, { level: 1, count: 5 }, { level: 2, count: 10 }], ambientLight: "0xffffff", ambientLightIntensity: .5, directionalLight: "0xffffff", directionalLightIntensity: .3, cameraX: 0, cameraY: 3, cameraZ: -9, lookAtY: -3, ballAccelerationOnBoost: .1, platformsNormalBoost: 2, platformsSuperBoost: 3, gameColors: [{ loosePlatformColor: "#ff0000", normalPlatformColor: "#2B2B2B", tubeColor: "#EAEAEA", ballColorNormal: "#FCC366", ballColorFire: "#ff0000", backgroundGradient: "linear-gradient(#B1B1B1, #3D3D3D)" }, { loosePlatformColor: "#ff0000", normalPlatformColor: "#76335F", tubeColor: "#E3927F", ballColorNormal: "#FF7E45", ballColorFire: "#ff0000", backgroundGradient: "linear-gradient(#e66465, #9198e5)" }, { loosePlatformColor: "#ff0000", normalPlatformColor: "#525482", tubeColor: "#D0CB94", ballColorNormal: "#32A9D4", ballColorFire: "#ff0000", backgroundGradient: "linear-gradient(#BDA9B5, #6147A7)" }, { loosePlatformColor: "#ff0000", normalPlatformColor: "#EFC652", tubeColor: "#F0DC8D", ballColorNormal: "#A2AD30", ballColorFire: "#ff0000", backgroundGradient: "linear-gradient(#98AFB8, #B08B55)" }, { loosePlatformColor: "#ff0000", normalPlatformColor: "#7AAF09", tubeColor: "#9DD8BF", ballColorNormal: "#7870E8", ballColorFire: "#ff0000", backgroundGradient: "linear-gradient(#85B58C, #3A6160)" }, { loosePlatformColor: "#ff0000", normalPlatformColor: "#7AAF09", tubeColor: "#9DD8BF", ballColorNormal: "#7870E8", ballColorFire: "#ff0000", backgroundGradient: "linear-gradient(#85B58C, #3A6160)" }] }, CA = { level_00: [{ count: 23, rotation: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27], type: [1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0], level: 0, randomRotation: 5.6 }, { count: 25, rotation: [0, 1, 2, 3, 4, 5, 6, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26], type: [1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], level: 0, randomRotation: .3 }, { count: 25, rotation: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 19, 20, 21, 22, 23, 24, 25, 26, 27], type: [1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1], level: 0, randomRotation: 12.4 }, { count: 25, rotation: [0, 1, 2, 3, 4, 5, 6, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 23, 24, 25, 26, 27, 28], type: [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1], level: 0, randomRotation: 22.3 }], level_01: [{ count: 25, rotation: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29], type: [0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0], level: 1, randomRotation: 1.6 }, { count: 25, rotation: [0, 1, 2, 3, 4, 5, 6, 7, 8, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 23, 24, 25, 26, 27, 28], type: [1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1], level: 1, randomRotation: 5.3 }, { count: 25, rotation: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 19, 20, 21, 22, 23, 24, 25, 26, 27], type: [1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0], level: 1, randomRotation: 22.4 }, { count: 26, rotation: [0, 1, 2, 3, 4, 5, 6, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 23, 24, 25, 26, 27, 28, 29], type: [0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0], level: 1, randomRotation: 7.3 }], level_02: [{ count: 28, rotation: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28], type: [0, 0, 0, 0, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 0, 1, 0], level: 2, randomRotation: 1.3 }, { count: 28, rotation: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28], type: [0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0], level: 2, randomRotation: 2.79 }, { count: 28, rotation: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27], type: [0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1], level: 2, randomRotation: 17.3 }, { count: 28, rotation: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28], type: [0, 1, 0, 0, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0], level: 2, randomRotation: .3 }], level_03: [{ count: 28, rotation: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27], type: [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], level: 3, randomRotation: .6 }, { count: 28, rotation: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27], type: [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], level: 3, randomRotation: .3 }, { count: 28, rotation: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27], type: [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], level: 3, randomRotation: .4 }, { count: 28, rotation: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27], type: [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], level: 3, randomRotation: .2 }] }; function bA(e) { return (bA = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) { return typeof e } : function (e) { return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e })(e) } function MA(e, t) { for (var n = 0; n < t.length; n++) { var i = t[n]; i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i) } } function IA(e, t) { return (IA = Object.setPrototypeOf || function (e, t) { return e.__proto__ = t, e })(e, t) } function EA(e) { var t = function () { if ("undefined" == typeof Reflect || !Reflect.construct) return !1; if (Reflect.construct.sham) return !1; if ("function" == typeof Proxy) return !0; try { return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function () { }))), !0 } catch (e) { return !1 } }(); return function () { var n, i = PA(e); if (t) { var r = PA(this).constructor; n = Reflect.construct(i, arguments, r) } else n = i.apply(this, arguments); return TA(this, n) } } function TA(e, t) { return !t || "object" !== bA(t) && "function" != typeof t ? function (e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e }(e) : t } function PA(e) { return (PA = Object.setPrototypeOf ? Object.getPrototypeOf : function (e) { return e.__proto__ || Object.getPrototypeOf(e) })(e) } var SA = function (e) { !function (e, t) { if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function"); e.prototype = Object.create(t && t.prototype, { constructor: { value: e, writable: !0, configurable: !0 } }), t && IA(e, t) }(s, e); var t, n, i, r = EA(s); function s(e) { var t; return function (e, t) { if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function") }(this, s), (t = r.call(this))._setupHelpers(), t } return t = s, (n = [{ key: "build", value: function () { this._createAmbientLight(), this._createDirectionalLight(), this._addToScene() } }, { key: "_createAmbientLight", value: function () { this._aLight = new ya(new nt(xA.ambientLight), xA.ambientLightIntensity), this._aLight.position.x = 10, this._aLight.position.y = 10, this._aLight.position.z = 10 } }, { key: "_createDirectionalLight", value: function () { this._pointLight = new fa(16777215, 1, 18), this._pointLight.position.set(-1, 6, -3), Mf.LIGHT = this._pointLight } }, { key: "_setupHelpers", value: function () { } }, { key: "_addToScene", value: function () { this.add(this._aLight, this._pointLight) } }, { key: "update", value: function (e) { } }]) && MA(t.prototype, n), i && MA(t, i), s }(ke); function BA(e) { return (BA = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) { return typeof e } : function (e) { return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e })(e) } function DA(e, t) { for (var n = 0; n < t.length; n++) { var i = t[n]; i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i) } } function RA(e, t) { return (RA = Object.setPrototypeOf || function (e, t) { return e.__proto__ = t, e })(e, t) } function LA(e) { var t = function () { if ("undefined" == typeof Reflect || !Reflect.construct) return !1; if (Reflect.construct.sham) return !1; if ("function" == typeof Proxy) return !0; try { return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function () { }))), !0 } catch (e) { return !1 } }(); return function () { var n, i = NA(e); if (t) { var r = NA(this).constructor; n = Reflect.construct(i, arguments, r) } else n = i.apply(this, arguments); return OA(this, n) } } function OA(e, t) { return !t || "object" !== BA(t) && "function" != typeof t ? function (e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e }(e) : t } function NA(e) { return (NA = Object.setPrototypeOf ? Object.getPrototypeOf : function (e) { return e.__proto__ || Object.getPrototypeOf(e) })(e) } var kA = function (e) { !function (e, t) { if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function"); e.prototype = Object.create(t && t.prototype, { constructor: { value: e, writable: !0, configurable: !0 } }), t && RA(e, t) }(s, e); var t, n, i, r = LA(s); function s(e) { var t; return function (e, t) { if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function") }(this, s), t = r.call(this), Mf.EVENT_DISPATCHER.addEventListener("touchRestartScreen", (function () { return t._resetTube() })), Mf.EVENT_DISPATCHER.addEventListener("touchRetryScreen", (function () { return t._resetTube() })), t } return t = s, (n = [{ key: "build", value: function () { var e = new xs(1.5, 1.5, 180, 50), t = new Co({ side: 2, color: xA.gameColors[0].tubeColor }); this._tube = new kt(e, t), this._tube.position.y = -75, Mf.CYLINDER_GROUP.add(this._tube) } }, { key: "changeColor", value: function () { } }, { key: "update", value: function (e) { this._tube.position.y = Mf.BALL.position.y } }, { key: "_resetTube", value: function () { this._tube.position.y = -75 } }]) && DA(t.prototype, n), i && DA(t, i), s }(ke); function HA(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e } function zA(e, t) { e.prototype = Object.create(t.prototype), e.prototype.constructor = e, e.__proto__ = t } var FA, QA, GA, jA, UA, VA, YA, WA, XA, JA, KA, ZA, qA, _A = { autoSleep: 120, force3D: "auto", nullTargetWarn: 1, units: { lineHeight: "" } }, $A = { duration: .5, overwrite: !1, delay: 0 }, eu = 1e8, tu = 2 * Math.PI, nu = tu / 4, iu = 0, ru = Math.sqrt, su = Math.cos, ou = Math.sin, au = function (e) { return "string" == typeof e }, lu = function (e) { return "function" == typeof e }, cu = function (e) { return "number" == typeof e }, Au = function (e) { return void 0 === e }, uu = function (e) { return "object" == typeof e }, hu = function (e) { return !1 !== e }, du = function () { return "undefined" != typeof window }, pu = function (e) { return lu(e) || au(e) }, fu = "function" == typeof ArrayBuffer && ArrayBuffer.isView || function () { }, gu = Array.isArray, mu = /(?:-?\.?\d|\.)+/gi, vu = /[-+=.]*\d+[.e\-+]*\d*[e\-+]*\d*/g, yu = /[-+=.]*\d+[.e-]*\d*[a-z%]*/g, wu = /[-+=.]*\d+\.?\d*(?:e-|e\+)?\d*/gi, xu = /[+-]=-?[.\d]+/, Cu = /[^,'"\[\]\s]+/gi, bu = /[\d.+\-=]+(?:e[-+]\d*)*/i, Mu = {}, Iu = {}, Eu = function (e) { return (Iu = qu(e, Mu)) && Nd }, Tu = function (e, t) { return console.warn("Invalid property", e, "set to", t, "Missing plugin? gsap.registerPlugin()") }, Pu = function (e, t) { return !t && console.warn(e) }, Su = function (e, t) { return e && (Mu[e] = t) && Iu && (Iu[e] = t) || Mu }, Bu = function () { return 0 }, Du = {}, Ru = [], Lu = {}, Ou = {}, Nu = {}, ku = 30, Hu = [], zu = "", Fu = function (e) { var t, n, i = e[0]; if (uu(i) || lu(i) || (e = [e]), !(t = (i._gsap || {}).harness)) { for (n = Hu.length; n-- && !Hu[n].targetTest(i);); t = Hu[n] } for (n = e.length; n--;)e[n] && (e[n]._gsap || (e[n]._gsap = new od(e[n], t))) || e.splice(n, 1); return e }, Qu = function (e) { return e._gsap || Fu(Eh(e))[0]._gsap }, Gu = function (e, t, n) { return (n = e[t]) && lu(n) ? e[t]() : Au(n) && e.getAttribute && e.getAttribute(t) || n }, ju = function (e, t) { return (e = e.split(",")).forEach(t) || e }, Uu = function (e) { return Math.round(1e5 * e) / 1e5 || 0 }, Vu = function (e, t) { for (var n = t.length, i = 0; e.indexOf(t[i]) < 0 && ++i < n;); return i < n }, Yu = function () { var e, t, n = Ru.length, i = Ru.slice(0); for (Lu = {}, Ru.length = 0, e = 0; e < n; e++)(t = i[e]) && t._lazy && (t.render(t._lazy[0], t._lazy[1], !0)._lazy = 0) }, Wu = function (e, t, n, i) { Ru.length && Yu(), e.render(t, n, i), Ru.length && Yu() }, Xu = function (e) { var t = parseFloat(e); return (t || 0 === t) && (e + "").match(Cu).length < 2 ? t : au(e) ? e.trim() : e }, Ju = function (e) { return e }, Ku = function (e, t) { for (var n in t) n in e || (e[n] = t[n]); return e }, Zu = function (e, t) { for (var n in t) n in e || "duration" === n || "ease" === n || (e[n] = t[n]) }, qu = function (e, t) { for (var n in t) e[n] = t[n]; return e }, _u = function e(t, n) { for (var i in n) "__proto__" !== i && "constructor" !== i && "prototype" !== i && (t[i] = uu(n[i]) ? e(t[i] || (t[i] = {}), n[i]) : n[i]); return t }, $u = function (e, t) { var n, i = {}; for (n in e) n in t || (i[n] = e[n]); return i }, eh = function (e) { var t = e.parent || QA, n = e.keyframes ? Zu : Ku; if (hu(e.inherit)) for (; t;)n(e, t.vars.defaults), t = t.parent || t._dp; return e }, th = function (e, t, n, i) { void 0 === n && (n = "_first"), void 0 === i && (i = "_last"); var r = t._prev, s = t._next; r ? r._next = s : e[n] === t && (e[n] = s), s ? s._prev = r : e[i] === t && (e[i] = r), t._next = t._prev = t.parent = null }, nh = function (e, t) { e.parent && (!t || e.parent.autoRemoveChildren) && e.parent.remove(e), e._act = 0 }, ih = function (e, t) { if (e && (!t || t._end > e._dur || t._start < 0)) for (var n = e; n;)n._dirty = 1, n = n.parent; return e }, rh = function (e) { for (var t = e.parent; t && t.parent;)t._dirty = 1, t.totalDuration(), t = t.parent; return e }, sh = function (e) { return e._repeat ? oh(e._tTime, e = e.duration() + e._rDelay) * e : 0 }, oh = function (e, t) { var n = Math.floor(e /= t); return e && n === e ? n - 1 : n }, ah = function (e, t) { return (e - t._start) * t._ts + (t._ts >= 0 ? 0 : t._dirty ? t.totalDuration() : t._tDur) }, lh = function (e) { return e._end = Uu(e._start + (e._tDur / Math.abs(e._ts || e._rts || 1e-8) || 0)) }, ch = function (e, t) { var n = e._dp; return n && n.smoothChildTiming && e._ts && (e._start = Uu(n._time - (e._ts > 0 ? t / e._ts : ((e._dirty ? e.totalDuration() : e._tDur) - t) / -e._ts)), lh(e), n._dirty || ih(n, e)), e }, Ah = function (e, t) { var n; if ((t._time || t._initted && !t._dur) && (n = ah(e.rawTime(), t), (!t._dur || xh(0, t.totalDuration(), n) - t._tTime > 1e-8) && t.render(n, !0)), ih(e, t)._dp && e._initted && e._time >= e._dur && e._ts) { if (e._dur < e.duration()) for (n = e; n._dp;)n.rawTime() >= 0 && n.totalTime(n._tTime), n = n._dp; e._zTime = -1e-8 } }, uh = function (e, t, n, i) { return t.parent && nh(t), t._start = Uu((cu(n) ? n : n || e !== QA ? vh(e, n, t) : e._time) + t._delay), t._end = Uu(t._start + (t.totalDuration() / Math.abs(t.timeScale()) || 0)), function (e, t, n, i, r) { void 0 === n && (n = "_first"), void 0 === i && (i = "_last"); var s, o = e[i]; if (r) for (s = t[r]; o && o[r] > s;)o = o._prev; o ? (t._next = o._next, o._next = t) : (t._next = e[n], e[n] = t), t._next ? t._next._prev = t : e[i] = t, t._prev = o, t.parent = t._dp = e }(e, t, "_first", "_last", e._sort ? "_start" : 0), ph(t) || (e._recent = t), i || Ah(e, t), e }, hh = function (e, t) { return (Mu.ScrollTrigger || Tu("scrollTrigger", t)) && Mu.ScrollTrigger.create(t, e) }, dh = function (e, t, n, i) { return dd(e, t), e._initted ? !n && e._pt && (e._dur && !1 !== e.vars.lazy || !e._dur && e.vars.lazy) && YA !== Xh.frame ? (Ru.push(e), e._lazy = [t, i], 1) : void 0 : 1 }, ph = function (e) { var t = e.data; return "isFromStart" === t || "isStart" === t }, fh = function (e, t, n, i) { var r = e._repeat, s = Uu(t) || 0, o = e._tTime / e._tDur; return o && !i && (e._time *= s / e._dur), e._dur = s, e._tDur = r ? r < 0 ? 1e10 : Uu(s * (r + 1) + e._rDelay * r) : s, o && !i ? ch(e, e._tTime = e._tDur * o) : e.parent && lh(e), n || ih(e.parent, e), e }, gh = function (e) { return e instanceof ld ? ih(e) : fh(e, e._dur) }, mh = { _start: 0, endTime: Bu, totalDuration: Bu }, vh = function e(t, n, i) { var r, s, o, a = t.labels, l = t._recent || mh, c = t.duration() >= eu ? l.endTime(!1) : t._dur; return au(n) && (isNaN(n) || n in a) ? (s = n.charAt(0), o = "%" === n.substr(-1), r = n.indexOf("="), "<" === s || ">" === s ? (r >= 0 && (n = n.replace(/=/, "")), ("<" === s ? l._start : l.endTime(l._repeat >= 0)) + (parseFloat(n.substr(1)) || 0) * (o ? (r < 0 ? l : i).totalDuration() / 100 : 1)) : r < 0 ? (n in a || (a[n] = c), a[n]) : (s = parseFloat(n.charAt(r - 1) + n.substr(r + 1)), o && i && (s = s / 100 * (gu(i) ? i[0] : i).totalDuration()), r > 1 ? e(t, n.substr(0, r - 1), i) + s : c + s)) : null == n ? c : +n }, yh = function (e, t, n) { var i, r, s = cu(t[1]), o = (s ? 2 : 1) + (e < 2 ? 0 : 1), a = t[o]; if (s && (a.duration = t[1]), a.parent = n, e) { for (i = a, r = n; r && !("immediateRender" in i);)i = r.vars.defaults || {}, r = hu(r.vars.inherit) && r.parent; a.immediateRender = hu(i.immediateRender), e < 2 ? a.runBackwards = 1 : a.startAt = t[o - 1] } return new md(t[0], a, t[o + 1]) }, wh = function (e, t) { return e || 0 === e ? t(e) : t }, xh = function (e, t, n) { return n < e ? e : n > t ? t : n }, Ch = function (e) { if ("string" != typeof e) return ""; var t = bu.exec(e); return t ? e.substr(t.index + t[0].length) : "" }, bh = [].slice, Mh = function (e, t) { return e && uu(e) && "length" in e && (!t && !e.length || e.length - 1 in e && uu(e[0])) && !e.nodeType && e !== GA }, Ih = function (e, t, n) { return void 0 === n && (n = []), e.forEach((function (e) { var i; return au(e) && !t || Mh(e, 1) ? (i = n).push.apply(i, Eh(e)) : n.push(e) })) || n }, Eh = function (e, t, n) { return !au(e) || n || !jA && Jh() ? gu(e) ? Ih(e, n) : Mh(e) ? bh.call(e, 0) : e ? [e] : [] : bh.call((t || UA).querySelectorAll(e), 0) }, Th = function (e) { return e.sort((function () { return .5 - Math.random() })) }, Ph = function (e) { if (lu(e)) return e; var t = uu(e) ? e : { each: e }, n = td(t.ease), i = t.from || 0, r = parseFloat(t.base) || 0, s = {}, o = i > 0 && i < 1, a = isNaN(i) || o, l = t.axis, c = i, A = i; return au(i) ? c = A = { center: .5, edges: .5, end: 1 }[i] || 0 : !o && a && (c = i[0], A = i[1]), function (e, o, u) { var h, d, p, f, g, m, v, y, w, x = (u || t).length, C = s[x]; if (!C) { if (!(w = "auto" === t.grid ? 0 : (t.grid || [1, eu])[1])) { for (v = -eu; v < (v = u[w++].getBoundingClientRect().left) && w < x;); w-- } for (C = s[x] = [], h = a ? Math.min(w, x) * c - .5 : i % w, d = a ? x * A / w - .5 : i / w | 0, v = 0, y = eu, m = 0; m < x; m++)p = m % w - h, f = d - (m / w | 0), C[m] = g = l ? Math.abs("y" === l ? f : p) : ru(p * p + f * f), g > v && (v = g), g < y && (y = g); "random" === i && Th(C), C.max = v - y, C.min = y, C.v = x = (parseFloat(t.amount) || parseFloat(t.each) * (w > x ? x - 1 : l ? "y" === l ? x / w : w : Math.max(w, x / w)) || 0) * ("edges" === i ? -1 : 1), C.b = x < 0 ? r - x : r, C.u = Ch(t.amount || t.each) || 0, n = n && x < 0 ? $h(n) : n } return x = (C[e] - C.min) / C.max || 0, Uu(C.b + (n ? n(x) : x) * C.v) + C.u } }, Sh = function (e) { var t = e < 1 ? Math.pow(10, (e + "").length - 2) : 1; return function (n) { var i = Math.round(parseFloat(n) / e) * e * t; return (i - i % 1) / t + (cu(n) ? 0 : Ch(n)) } }, Bh = function (e, t) { var n, i, r = gu(e); return !r && uu(e) && (n = r = e.radius || eu, e.values ? (e = Eh(e.values), (i = !cu(e[0])) && (n *= n)) : e = Sh(e.increment)), wh(t, r ? lu(e) ? function (t) { return i = e(t), Math.abs(i - t) <= n ? i : t } : function (t) { for (var r, s, o = parseFloat(i ? t.x : t), a = parseFloat(i ? t.y : 0), l = eu, c = 0, A = e.length; A--;)(r = i ? (r = e[A].x - o) * r + (s = e[A].y - a) * s : Math.abs(e[A] - o)) < l && (l = r, c = A); return c = !n || l <= n ? e[c] : t, i || c === t || cu(t) ? c : c + Ch(t) } : Sh(e)) }, Dh = function (e, t, n, i) { return wh(gu(e) ? !t : !0 === n ? !!(n = 0) : !i, (function () { return gu(e) ? e[~~(Math.random() * e.length)] : (n = n || 1e-5) && (i = n < 1 ? Math.pow(10, (n + "").length - 2) : 1) && Math.floor(Math.round((e - n / 2 + Math.random() * (t - e + .99 * n)) / n) * n * i) / i })) }, Rh = function (e, t, n) { return wh(n, (function (n) { return e[~~t(n)] })) }, Lh = function (e) { for (var t, n, i, r, s = 0, o = ""; ~(t = e.indexOf("random(", s));)i = e.indexOf(")", t), r = "[" === e.charAt(t + 7), n = e.substr(t + 7, i - t - 7).match(r ? Cu : mu), o += e.substr(s, t - s) + Dh(r ? n : +n[0], r ? 0 : +n[1], +n[2] || 1e-5), s = i + 1; return o + e.substr(s, e.length - s) }, Oh = function (e, t, n, i, r) { var s = t - e, o = i - n; return wh(r, (function (t) { return n + ((t - e) / s * o || 0) })) }, Nh = function (e, t, n) { var i, r, s, o = e.labels, a = eu; for (i in o) (r = o[i] - t) < 0 == !!n && r && a > (r = Math.abs(r)) && (s = i, a = r); return s }, kh = function (e, t, n) { var i, r, s = e.vars, o = s[t]; if (o) return i = s[t + "Params"], r = s.callbackScope || e, n && Ru.length && Yu(), i ? o.apply(r, i) : o.call(r) }, Hh = function (e) { return nh(e), e.scrollTrigger && e.scrollTrigger.kill(!1), e.progress() < 1 && kh(e, "onInterrupt"), e }, zh = function (e) { var t = (e = !e.name && e.default || e).name, n = lu(e), i = t && !n && e.init ? function () { this._props = [] } : e, r = { init: Bu, render: Ed, add: ud, kill: Pd, modifier: Td, rawVars: 0 }, s = { targetTest: 0, get: 0, getSetter: Cd, aliases: {}, register: 0 }; if (Jh(), e !== i) { if (Ou[t]) return; Ku(i, Ku($u(e, r), s)), qu(i.prototype, qu(r, $u(e, s))), Ou[i.prop = t] = i, e.targetTest && (Hu.push(i), Du[t] = 1), t = ("css" === t ? "CSS" : t.charAt(0).toUpperCase() + t.substr(1)) + "Plugin" } Su(t, i), e.register && e.register(Nd, i, Dd) }, Fh = { aqua: [0, 255, 255], lime: [0, 255, 0], silver: [192, 192, 192], black: [0, 0, 0], maroon: [128, 0, 0], teal: [0, 128, 128], blue: [0, 0, 255], navy: [0, 0, 128], white: [255, 255, 255], olive: [128, 128, 0], yellow: [255, 255, 0], orange: [255, 165, 0], gray: [128, 128, 128], purple: [128, 0, 128], green: [0, 128, 0], red: [255, 0, 0], pink: [255, 192, 203], cyan: [0, 255, 255], transparent: [255, 255, 255, 0] }, Qh = function (e, t, n) { return 255 * (6 * (e = e < 0 ? e + 1 : e > 1 ? e - 1 : e) < 1 ? t + (n - t) * e * 6 : e < .5 ? n : 3 * e < 2 ? t + (n - t) * (2 / 3 - e) * 6 : t) + .5 | 0 }, Gh = function (e, t, n) { var i, r, s, o, a, l, c, A, u, h, d = e ? cu(e) ? [e >> 16, e >> 8 & 255, 255 & e] : 0 : Fh.black; if (!d) { if ("," === e.substr(-1) && (e = e.substr(0, e.length - 1)), Fh[e]) d = Fh[e]; else if ("#" === e.charAt(0)) { if (e.length < 6 && (i = e.charAt(1), r = e.charAt(2), s = e.charAt(3), e = "#" + i + i + r + r + s + s + (5 === e.length ? e.charAt(4) + e.charAt(4) : "")), 9 === e.length) return [(d = parseInt(e.substr(1, 6), 16)) >> 16, d >> 8 & 255, 255 & d, parseInt(e.substr(7), 16) / 255]; d = [(e = parseInt(e.substr(1), 16)) >> 16, e >> 8 & 255, 255 & e] } else if ("hsl" === e.substr(0, 3)) if (d = h = e.match(mu), t) { if (~e.indexOf("=")) return d = e.match(vu), n && d.length < 4 && (d[3] = 1), d } else o = +d[0] % 360 / 360, a = +d[1] / 100, i = 2 * (l = +d[2] / 100) - (r = l <= .5 ? l * (a + 1) : l + a - l * a), d.length > 3 && (d[3] *= 1), d[0] = Qh(o + 1 / 3, i, r), d[1] = Qh(o, i, r), d[2] = Qh(o - 1 / 3, i, r); else d = e.match(mu) || Fh.transparent; d = d.map(Number) } return t && !h && (i = d[0] / 255, r = d[1] / 255, s = d[2] / 255, l = ((c = Math.max(i, r, s)) + (A = Math.min(i, r, s))) / 2, c === A ? o = a = 0 : (u = c - A, a = l > .5 ? u / (2 - c - A) : u / (c + A), o = c === i ? (r - s) / u + (r < s ? 6 : 0) : c === r ? (s - i) / u + 2 : (i - r) / u + 4, o *= 60), d[0] = ~~(o + .5), d[1] = ~~(100 * a + .5), d[2] = ~~(100 * l + .5)), n && d.length < 4 && (d[3] = 1), d }, jh = function (e) { var t = [], n = [], i = -1; return e.split(Vh).forEach((function (e) { var r = e.match(yu) || []; t.push.apply(t, r), n.push(i += r.length + 1) })), t.c = n, t }, Uh = function (e, t, n) { var i, r, s, o, a = "", l = (e + a).match(Vh), c = t ? "hsla(" : "rgba(", A = 0; if (!l) return e; if (l = l.map((function (e) { return (e = Gh(e, t, 1)) && c + (t ? e[0] + "," + e[1] + "%," + e[2] + "%," + e[3] : e.join(",")) + ")" })), n && (s = jh(e), (i = n.c).join(a) !== s.c.join(a))) for (o = (r = e.replace(Vh, "1").split(yu)).length - 1; A < o; A++)a += r[A] + (~i.indexOf(A) ? l.shift() || c + "0,0,0,0)" : (s.length ? s : l.length ? l : n).shift()); if (!r) for (o = (r = e.split(Vh)).length - 1; A < o; A++)a += r[A] + l[A]; return a + r[o] }, Vh = function () { var e, t = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3,4}){1,2}\\b"; for (e in Fh) t += "|" + e + "\\b"; return new RegExp(t + ")", "gi") }(), Yh = /hsl[a]?\(/, Wh = function (e) { var t, n = e.join(" "); if (Vh.lastIndex = 0, Vh.test(n)) return t = Yh.test(n), e[1] = Uh(e[1], t), e[0] = Uh(e[0], t, jh(e[1])), !0 }, Xh = function () { var e, t, n, i, r, s, o = Date.now, a = 500, l = 33, c = o(), A = c, u = 1e3 / 240, h = u, d = [], p = function n(p) { var f, g, m, v, y = o() - A, w = !0 === p; if (y > a && (c += y - l), ((f = (m = (A += y) - c) - h) > 0 || w) && (v = ++i.frame, r = m - 1e3 * i.time, i.time = m /= 1e3, h += f + (f >= u ? 4 : u - f), g = 1), w || (e = t(n)), g) for (s = 0; s < d.length; s++)d[s](m, r, v, p) }; return i = { time: 0, frame: 0, tick: function () { p(!0) }, deltaRatio: function (e) { return r / (1e3 / (e || 60)) }, wake: function () { VA && (!jA && du() && (GA = jA = window, UA = GA.document || {}, Mu.gsap = Nd, (GA.gsapVersions || (GA.gsapVersions = [])).push(Nd.version), Eu(Iu || GA.GreenSockGlobals || !GA.gsap && GA || {}), n = GA.requestAnimationFrame), e && i.sleep(), t = n || function (e) { return setTimeout(e, h - 1e3 * i.time + 1 | 0) }, XA = 1, p(2)) }, sleep: function () { (n ? GA.cancelAnimationFrame : clearTimeout)(e), XA = 0, t = Bu }, lagSmoothing: function (e, t) { a = e || 1 / 1e-8, l = Math.min(t, a, 0) }, fps: function (e) { u = 1e3 / (e || 240), h = 1e3 * i.time + u }, add: function (e) { d.indexOf(e) < 0 && d.push(e), Jh() }, remove: function (e) { var t; ~(t = d.indexOf(e)) && d.splice(t, 1) && s >= t && s-- }, _listeners: d } }(), Jh = function () { return !XA && Xh.wake() }, Kh = {}, Zh = /^[\d.\-M][\d.\-,\s]/, qh = /["']/g, _h = function (e) { for (var t, n, i, r = {}, s = e.substr(1, e.length - 3).split(":"), o = s[0], a = 1, l = s.length; a < l; a++)n = s[a], t = a !== l - 1 ? n.lastIndexOf(",") : n.length, i = n.substr(0, t), r[o] = isNaN(i) ? i.replace(qh, "").trim() : +i, o = n.substr(t + 1).trim(); return r }, $h = function (e) { return function (t) { return 1 - e(1 - t) } }, ed = function e(t, n) { for (var i, r = t._first; r;)r instanceof ld ? e(r, n) : !r.vars.yoyoEase || r._yoyo && r._repeat || r._yoyo === n || (r.timeline ? e(r.timeline, n) : (i = r._ease, r._ease = r._yEase, r._yEase = i, r._yoyo = n)), r = r._next }, td = function (e, t) { return e && (lu(e) ? e : Kh[e] || function (e) { var t, n, i, r, s = (e + "").split("("), o = Kh[s[0]]; return o && s.length > 1 && o.config ? o.config.apply(null, ~e.indexOf("{") ? [_h(s[1])] : (t = e, n = t.indexOf("(") + 1, i = t.indexOf(")"), r = t.indexOf("(", n), t.substring(n, ~r && r < i ? t.indexOf(")", i + 1) : i)).split(",").map(Xu)) : Kh._CE && Zh.test(e) ? Kh._CE("", e) : o }(e)) || t }, nd = function (e, t, n, i) { void 0 === n && (n = function (e) { return 1 - t(1 - e) }), void 0 === i && (i = function (e) { return e < .5 ? t(2 * e) / 2 : 1 - t(2 * (1 - e)) / 2 }); var r, s = { easeIn: t, easeOut: n, easeInOut: i }; return ju(e, (function (e) { for (var t in Kh[e] = Mu[e] = s, Kh[r = e.toLowerCase()] = n, s) Kh[r + ("easeIn" === t ? ".in" : "easeOut" === t ? ".out" : ".inOut")] = Kh[e + "." + t] = s[t] })), s }, id = function (e) { return function (t) { return t < .5 ? (1 - e(1 - 2 * t)) / 2 : .5 + e(2 * (t - .5)) / 2 } }, rd = function e(t, n, i) { var r = n >= 1 ? n : 1, s = (i || (t ? .3 : .45)) / (n < 1 ? n : 1), o = s / tu * (Math.asin(1 / r) || 0), a = function (e) { return 1 === e ? 1 : r * Math.pow(2, -10 * e) * ou((e - o) * s) + 1 }, l = "out" === t ? a : "in" === t ? function (e) { return 1 - a(1 - e) } : id(a); return s = tu / s, l.config = function (n, i) { return e(t, n, i) }, l }, sd = function e(t, n) { void 0 === n && (n = 1.70158); var i = function (e) { return e ? --e * e * ((n + 1) * e + n) + 1 : 0 }, r = "out" === t ? i : "in" === t ? function (e) { return 1 - i(1 - e) } : id(i); return r.config = function (n) { return e(t, n) }, r }; ju("Linear,Quad,Cubic,Quart,Quint,Strong", (function (e, t) { var n = t < 5 ? t + 1 : t; nd(e + ",Power" + (n - 1), t ? function (e) { return Math.pow(e, n) } : function (e) { return e }, (function (e) { return 1 - Math.pow(1 - e, n) }), (function (e) { return e < .5 ? Math.pow(2 * e, n) / 2 : 1 - Math.pow(2 * (1 - e), n) / 2 })) })), Kh.Linear.easeNone = Kh.none = Kh.Linear.easeIn, nd("Elastic", rd("in"), rd("out"), rd()), JA = 7.5625, ZA = 1 / (KA = 2.75), nd("Bounce", (function (e) { return 1 - qA(1 - e) }), qA = function (e) { return e < ZA ? JA * e * e : e < .7272727272727273 ? JA * Math.pow(e - 1.5 / KA, 2) + .75 : e < .9090909090909092 ? JA * (e -= 2.25 / KA) * e + .9375 : JA * Math.pow(e - 2.625 / KA, 2) + .984375 }), nd("Expo", (function (e) { return e ? Math.pow(2, 10 * (e - 1)) : 0 })), nd("Circ", (function (e) { return -(ru(1 - e * e) - 1) })), nd("Sine", (function (e) { return 1 === e ? 1 : 1 - su(e * nu) })), nd("Back", sd("in"), sd("out"), sd()), Kh.SteppedEase = Kh.steps = Mu.SteppedEase = { config: function (e, t) { void 0 === e && (e = 1); var n = 1 / e, i = e + (t ? 0 : 1), r = t ? 1 : 0; return function (e) { return ((i * xh(0, 1 - 1e-8, e) | 0) + r) * n } } }, $A.ease = Kh["quad.out"], ju("onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt", (function (e) { return zu += e + "," + e + "Params," })); var od = function (e, t) { this.id = iu++, e._gsap = this, this.target = e, this.harness = t, this.get = t ? t.get : Gu, this.set = t ? t.getSetter : Cd }, ad = function () { function e(e) { this.vars = e, this._delay = +e.delay || 0, (this._repeat = e.repeat === 1 / 0 ? -2 : e.repeat || 0) && (this._rDelay = e.repeatDelay || 0, this._yoyo = !!e.yoyo || !!e.yoyoEase), this._ts = 1, fh(this, +e.duration, 1, 1), this.data = e.data, XA || Xh.wake() } var t = e.prototype; return t.delay = function (e) { return e || 0 === e ? (this.parent && this.parent.smoothChildTiming && this.startTime(this._start + e - this._delay), this._delay = e, this) : this._delay }, t.duration = function (e) { return arguments.length ? this.totalDuration(this._repeat > 0 ? e + (e + this._rDelay) * this._repeat : e) : this.totalDuration() && this._dur }, t.totalDuration = function (e) { return arguments.length ? (this._dirty = 0, fh(this, this._repeat < 0 ? e : (e - this._repeat * this._rDelay) / (this._repeat + 1))) : this._tDur }, t.totalTime = function (e, t) { if (Jh(), !arguments.length) return this._tTime; var n = this._dp; if (n && n.smoothChildTiming && this._ts) { for (ch(this, e), !n._dp || n.parent || Ah(n, this); n.parent;)n.parent._time !== n._start + (n._ts >= 0 ? n._tTime / n._ts : (n.totalDuration() - n._tTime) / -n._ts) && n.totalTime(n._tTime, !0), n = n.parent; !this.parent && this._dp.autoRemoveChildren && (this._ts > 0 && e < this._tDur || this._ts < 0 && e > 0 || !this._tDur && !e) && uh(this._dp, this, this._start - this._delay) } return (this._tTime !== e || !this._dur && !t || this._initted && 1e-8 === Math.abs(this._zTime) || !e && !this._initted && (this.add || this._ptLookup)) && (this._ts || (this._pTime = e), Wu(this, e, t)), this }, t.time = function (e, t) { return arguments.length ? this.totalTime(Math.min(this.totalDuration(), e + sh(this)) % this._dur || (e ? this._dur : 0), t) : this._time }, t.totalProgress = function (e, t) { return arguments.length ? this.totalTime(this.totalDuration() * e, t) : this.totalDuration() ? Math.min(1, this._tTime / this._tDur) : this.ratio }, t.progress = function (e, t) { return arguments.length ? this.totalTime(this.duration() * (!this._yoyo || 1 & this.iteration() ? e : 1 - e) + sh(this), t) : this.duration() ? Math.min(1, this._time / this._dur) : this.ratio }, t.iteration = function (e, t) { var n = this.duration() + this._rDelay; return arguments.length ? this.totalTime(this._time + (e - 1) * n, t) : this._repeat ? oh(this._tTime, n) + 1 : 1 }, t.timeScale = function (e) { if (!arguments.length) return -1e-8 === this._rts ? 0 : this._rts; if (this._rts === e) return this; var t = this.parent && this._ts ? ah(this.parent._time, this) : this._tTime; return this._rts = +e || 0, this._ts = this._ps || -1e-8 === e ? 0 : this._rts, rh(this.totalTime(xh(-this._delay, this._tDur, t), !0)) }, t.paused = function (e) { return arguments.length ? (this._ps !== e && (this._ps = e, e ? (this._pTime = this._tTime || Math.max(-this._delay, this.rawTime()), this._ts = this._act = 0) : (Jh(), this._ts = this._rts, this.totalTime(this.parent && !this.parent.smoothChildTiming ? this.rawTime() : this._tTime || this._pTime, 1 === this.progress() && (this._tTime -= 1e-8) && 1e-8 !== Math.abs(this._zTime)))), this) : this._ps }, t.startTime = function (e) { if (arguments.length) { this._start = e; var t = this.parent || this._dp; return t && (t._sort || !this.parent) && uh(t, this, e - this._delay), this } return this._start }, t.endTime = function (e) { return this._start + (hu(e) ? this.totalDuration() : this.duration()) / Math.abs(this._ts) }, t.rawTime = function (e) { var t = this.parent || this._dp; return t ? e && (!this._ts || this._repeat && this._time && this.totalProgress() < 1) ? this._tTime % (this._dur + this._rDelay) : this._ts ? ah(t.rawTime(e), this) : this._tTime : this._tTime }, t.globalTime = function (e) { for (var t = this, n = arguments.length ? e : t.rawTime(); t;)n = t._start + n / (t._ts || 1), t = t._dp; return n }, t.repeat = function (e) { return arguments.length ? (this._repeat = e === 1 / 0 ? -2 : e, gh(this)) : -2 === this._repeat ? 1 / 0 : this._repeat }, t.repeatDelay = function (e) { return arguments.length ? (this._rDelay = e, gh(this)) : this._rDelay }, t.yoyo = function (e) { return arguments.length ? (this._yoyo = e, this) : this._yoyo }, t.seek = function (e, t) { return this.totalTime(vh(this, e), hu(t)) }, t.restart = function (e, t) { return this.play().totalTime(e ? -this._delay : 0, hu(t)) }, t.play = function (e, t) { return null != e && this.seek(e, t), this.reversed(!1).paused(!1) }, t.reverse = function (e, t) { return null != e && this.seek(e || this.totalDuration(), t), this.reversed(!0).paused(!1) }, t.pause = function (e, t) { return null != e && this.seek(e, t), this.paused(!0) }, t.resume = function () { return this.paused(!1) }, t.reversed = function (e) { return arguments.length ? (!!e !== this.reversed() && this.timeScale(-this._rts || (e ? -1e-8 : 0)), this) : this._rts < 0 }, t.invalidate = function () { return this._initted = this._act = 0, this._zTime = -1e-8, this }, t.isActive = function () { var e, t = this.parent || this._dp, n = this._start; return !(t && !(this._ts && this._initted && t.isActive() && (e = t.rawTime(!0)) >= n && e < this.endTime(!0) - 1e-8)) }, t.eventCallback = function (e, t, n) { var i = this.vars; return arguments.length > 1 ? (t ? (i[e] = t, n && (i[e + "Params"] = n), "onUpdate" === e && (this._onUpdate = t)) : delete i[e], this) : i[e] }, t.then = function (e) { var t = this; return new Promise((function (n) { var i = lu(e) ? e : Ju, r = function () { var e = t.then; t.then = null, lu(i) && (i = i(t)) && (i.then || i === t) && (t.then = e), n(i), t.then = e }; t._initted && 1 === t.totalProgress() && t._ts >= 0 || !t._tTime && t._ts < 0 ? r() : t._prom = r })) }, t.kill = function () { Hh(this) }, e }(); Ku(ad.prototype, { _time: 0, _start: 0, _end: 0, _tTime: 0, _tDur: 0, _dirty: 0, _repeat: 0, _yoyo: !1, parent: null, _initted: !1, _rDelay: 0, _ts: 1, _dp: 0, ratio: 0, _zTime: -1e-8, _prom: 0, _ps: !1, _rts: 1 }); var ld = function (e) { function t(t, n) { var i; return void 0 === t && (t = {}), (i = e.call(this, t) || this).labels = {}, i.smoothChildTiming = !!t.smoothChildTiming, i.autoRemoveChildren = !!t.autoRemoveChildren, i._sort = hu(t.sortChildren), QA && uh(t.parent || QA, HA(i), n), t.reversed && i.reverse(), t.paused && i.paused(!0), t.scrollTrigger && hh(HA(i), t.scrollTrigger), i } zA(t, e); var n = t.prototype; return n.to = function (e, t, n) { return yh(0, arguments, this), this }, n.from = function (e, t, n) { return yh(1, arguments, this), this }, n.fromTo = function (e, t, n, i) { return yh(2, arguments, this), this }, n.set = function (e, t, n) { return t.duration = 0, t.parent = this, eh(t).repeatDelay || (t.repeat = 0), t.immediateRender = !!t.immediateRender, new md(e, t, vh(this, n), 1), this }, n.call = function (e, t, n) { return uh(this, md.delayedCall(0, e, t), n) }, n.staggerTo = function (e, t, n, i, r, s, o) { return n.duration = t, n.stagger = n.stagger || i, n.onComplete = s, n.onCompleteParams = o, n.parent = this, new md(e, n, vh(this, r)), this }, n.staggerFrom = function (e, t, n, i, r, s, o) { return n.runBackwards = 1, eh(n).immediateRender = hu(n.immediateRender), this.staggerTo(e, t, n, i, r, s, o) }, n.staggerFromTo = function (e, t, n, i, r, s, o, a) { return i.startAt = n, eh(i).immediateRender = hu(i.immediateRender), this.staggerTo(e, t, i, r, s, o, a) }, n.render = function (e, t, n) { var i, r, s, o, a, l, c, A, u, h, d, p, f = this._time, g = this._dirty ? this.totalDuration() : this._tDur, m = this._dur, v = this !== QA && e > g - 1e-8 && e >= 0 ? g : e < 1e-8 ? 0 : e, y = this._zTime < 0 != e < 0 && (this._initted || !m); if (v !== this._tTime || n || y) { if (f !== this._time && m && (v += this._time - f, e += this._time - f), i = v, u = this._start, l = !(A = this._ts), y && (m || (f = this._zTime), (e || !t) && (this._zTime = e)), this._repeat) { if (d = this._yoyo, a = m + this._rDelay, this._repeat < -1 && e < 0) return this.totalTime(100 * a + e, t, n); if (i = Uu(v % a), v === g ? (o = this._repeat, i = m) : ((o = ~~(v / a)) && o === v / a && (i = m, o--), i > m && (i = m)), h = oh(this._tTime, a), !f && this._tTime && h !== o && (h = o), d && 1 & o && (i = m - i, p = 1), o !== h && !this._lock) { var w = d && 1 & h, x = w === (d && 1 & o); if (o < h && (w = !w), f = w ? 0 : m, this._lock = 1, this.render(f || (p ? 0 : Uu(o * a)), t, !m)._lock = 0, this._tTime = v, !t && this.parent && kh(this, "onRepeat"), this.vars.repeatRefresh && !p && (this.invalidate()._lock = 1), f && f !== this._time || l !== !this._ts || this.vars.onRepeat && !this.parent && !this._act) return this; if (m = this._dur, g = this._tDur, x && (this._lock = 2, f = w ? m : -1e-4, this.render(f, !0), this.vars.repeatRefresh && !p && this.invalidate()), this._lock = 0, !this._ts && !l) return this; ed(this, p) } } if (this._hasPause && !this._forcing && this._lock < 2 && (c = function (e, t, n) { var i; if (n > t) for (i = e._first; i && i._start <= n;) { if (!i._dur && "isPause" === i.data && i._start > t) return i; i = i._next } else for (i = e._last; i && i._start >= n;) { if (!i._dur && "isPause" === i.data && i._start < t) return i; i = i._prev } }(this, Uu(f), Uu(i))) && (v -= i - (i = c._start)), this._tTime = v, this._time = i, this._act = !A, this._initted || (this._onUpdate = this.vars.onUpdate, this._initted = 1, this._zTime = e, f = 0), !f && i && !t && (kh(this, "onStart"), this._tTime !== v)) return this; if (i >= f && e >= 0) for (r = this._first; r;) { if (s = r._next, (r._act || i >= r._start) && r._ts && c !== r) { if (r.parent !== this) return this.render(e, t, n); if (r.render(r._ts > 0 ? (i - r._start) * r._ts : (r._dirty ? r.totalDuration() : r._tDur) + (i - r._start) * r._ts, t, n), i !== this._time || !this._ts && !l) { c = 0, s && (v += this._zTime = -1e-8); break } } r = s } else { r = this._last; for (var C = e < 0 ? e : i; r;) { if (s = r._prev, (r._act || C <= r._end) && r._ts && c !== r) { if (r.parent !== this) return this.render(e, t, n); if (r.render(r._ts > 0 ? (C - r._start) * r._ts : (r._dirty ? r.totalDuration() : r._tDur) + (C - r._start) * r._ts, t, n), i !== this._time || !this._ts && !l) { c = 0, s && (v += this._zTime = C ? -1e-8 : 1e-8); break } } r = s } } if (c && !t && (this.pause(), c.render(i >= f ? 0 : -1e-8)._zTime = i >= f ? 1 : -1, this._ts)) return this._start = u, lh(this), this.render(e, t, n); this._onUpdate && !t && kh(this, "onUpdate", !0), (v === g && g >= this.totalDuration() || !v && f) && (u !== this._start && Math.abs(A) === Math.abs(this._ts) || this._lock || ((e || !m) && (v === g && this._ts > 0 || !v && this._ts < 0) && nh(this, 1), t || e < 0 && !f || !v && !f && g || (kh(this, v === g && e >= 0 ? "onComplete" : "onReverseComplete", !0), this._prom && !(v < g && this.timeScale() > 0) && this._prom()))) } return this }, n.add = function (e, t) { var n = this; if (cu(t) || (t = vh(this, t, e)), !(e instanceof ad)) { if (gu(e)) return e.forEach((function (e) { return n.add(e, t) })), this; if (au(e)) return this.addLabel(e, t); if (!lu(e)) return this; e = md.delayedCall(0, e) } return this !== e ? uh(this, e, t) : this }, n.getChildren = function (e, t, n, i) { void 0 === e && (e = !0), void 0 === t && (t = !0), void 0 === n && (n = !0), void 0 === i && (i = -eu); for (var r = [], s = this._first; s;)s._start >= i && (s instanceof md ? t && r.push(s) : (n && r.push(s), e && r.push.apply(r, s.getChildren(!0, t, n)))), s = s._next; return r }, n.getById = function (e) { for (var t = this.getChildren(1, 1, 1), n = t.length; n--;)if (t[n].vars.id === e) return t[n] }, n.remove = function (e) { return au(e) ? this.removeLabel(e) : lu(e) ? this.killTweensOf(e) : (th(this, e), e === this._recent && (this._recent = this._last), ih(this)) }, n.totalTime = function (t, n) { return arguments.length ? (this._forcing = 1, !this._dp && this._ts && (this._start = Uu(Xh.time - (this._ts > 0 ? t / this._ts : (this.totalDuration() - t) / -this._ts))), e.prototype.totalTime.call(this, t, n), this._forcing = 0, this) : this._tTime }, n.addLabel = function (e, t) { return this.labels[e] = vh(this, t), this }, n.removeLabel = function (e) { return delete this.labels[e], this }, n.addPause = function (e, t, n) { var i = md.delayedCall(0, t || Bu, n); return i.data = "isPause", this._hasPause = 1, uh(this, i, vh(this, e)) }, n.removePause = function (e) { var t = this._first; for (e = vh(this, e); t;)t._start === e && "isPause" === t.data && nh(t), t = t._next }, n.killTweensOf = function (e, t, n) { for (var i = this.getTweensOf(e, n), r = i.length; r--;)cd !== i[r] && i[r].kill(e, t); return this }, n.getTweensOf = function (e, t) { for (var n, i = [], r = Eh(e), s = this._first, o = cu(t); s;)s instanceof md ? Vu(s._targets, r) && (o ? (!cd || s._initted && s._ts) && s.globalTime(0) <= t && s.globalTime(s.totalDuration()) > t : !t || s.isActive()) && i.push(s) : (n = s.getTweensOf(r, t)).length && i.push.apply(i, n), s = s._next; return i }, n.tweenTo = function (e, t) { t = t || {}; var n, i = this, r = vh(i, e), s = t, o = s.startAt, a = s.onStart, l = s.onStartParams, c = s.immediateRender, A = md.to(i, Ku({ ease: t.ease || "none", lazy: !1, immediateRender: !1, time: r, overwrite: "auto", duration: t.duration || Math.abs((r - (o && "time" in o ? o.time : i._time)) / i.timeScale()) || 1e-8, onStart: function () { if (i.pause(), !n) { var e = t.duration || Math.abs((r - (o && "time" in o ? o.time : i._time)) / i.timeScale()); A._dur !== e && fh(A, e, 0, 1).render(A._time, !0, !0), n = 1 } a && a.apply(A, l || []) } }, t)); return c ? A.render(0) : A }, n.tweenFromTo = function (e, t, n) { return this.tweenTo(t, Ku({ startAt: { time: vh(this, e) } }, n)) }, n.recent = function () { return this._recent }, n.nextLabel = function (e) { return void 0 === e && (e = this._time), Nh(this, vh(this, e)) }, n.previousLabel = function (e) { return void 0 === e && (e = this._time), Nh(this, vh(this, e), 1) }, n.currentLabel = function (e) { return arguments.length ? this.seek(e, !0) : this.previousLabel(this._time + 1e-8) }, n.shiftChildren = function (e, t, n) { void 0 === n && (n = 0); for (var i, r = this._first, s = this.labels; r;)r._start >= n && (r._start += e, r._end += e), r = r._next; if (t) for (i in s) s[i] >= n && (s[i] += e); return ih(this) }, n.invalidate = function () { var t = this._first; for (this._lock = 0; t;)t.invalidate(), t = t._next; return e.prototype.invalidate.call(this) }, n.clear = function (e) { void 0 === e && (e = !0); for (var t, n = this._first; n;)t = n._next, this.remove(n), n = t; return this._dp && (this._time = this._tTime = this._pTime = 0), e && (this.labels = {}), ih(this) }, n.totalDuration = function (e) { var t, n, i, r = 0, s = this, o = s._last, a = eu; if (arguments.length) return s.timeScale((s._repeat < 0 ? s.duration() : s.totalDuration()) / (s.reversed() ? -e : e)); if (s._dirty) { for (i = s.parent; o;)t = o._prev, o._dirty && o.totalDuration(), (n = o._start) > a && s._sort && o._ts && !s._lock ? (s._lock = 1, uh(s, o, n - o._delay, 1)._lock = 0) : a = n, n < 0 && o._ts && (r -= n, (!i && !s._dp || i && i.smoothChildTiming) && (s._start += n / s._ts, s._time -= n, s._tTime -= n), s.shiftChildren(-n, !1, -Infinity), a = 0), o._end > r && o._ts && (r = o._end), o = t; fh(s, s === QA && s._time > r ? s._time : r, 1, 1), s._dirty = 0 } return s._tDur }, t.updateRoot = function (e) { if (QA._ts && (Wu(QA, ah(e, QA)), YA = Xh.frame), Xh.frame >= ku) { ku += _A.autoSleep || 120; var t = QA._first; if ((!t || !t._ts) && _A.autoSleep && Xh._listeners.length < 2) { for (; t && !t._ts;)t = t._next; t || Xh.sleep() } } }, t }(ad); Ku(ld.prototype, { _lock: 0, _hasPause: 0, _forcing: 0 }); var cd, Ad = function (e, t, n, i, r, s, o) { var a, l, c, A, u, h, d, p, f = new Dd(this._pt, e, t, 0, 1, Id, null, r), g = 0, m = 0; for (f.b = n, f.e = i, n += "", (d = ~(i += "").indexOf("random(")) && (i = Lh(i)), s && (s(p = [n, i], e, t), n = p[0], i = p[1]), l = n.match(wu) || []; a = wu.exec(i);)A = a[0], u = i.substring(g, a.index), c ? c = (c + 1) % 5 : "rgba(" === u.substr(-5) && (c = 1), A !== l[m++] && (h = parseFloat(l[m - 1]) || 0, f._pt = { _next: f._pt, p: u || 1 === m ? u : ",", s: h, c: "=" === A.charAt(1) ? parseFloat(A.substr(2)) * ("-" === A.charAt(0) ? -1 : 1) : parseFloat(A) - h, m: c && c < 4 ? Math.round : 0 }, g = wu.lastIndex); return f.c = g < i.length ? i.substring(g, i.length) : "", f.fp = o, (xu.test(i) || d) && (f.e = 0), this._pt = f, f }, ud = function (e, t, n, i, r, s, o, a, l) { lu(i) && (i = i(r || 0, e, s)); var c, A = e[t], u = "get" !== n ? n : lu(A) ? l ? e[t.indexOf("set") || !lu(e["get" + t.substr(3)]) ? t : "get" + t.substr(3)](l) : e[t]() : A, h = lu(A) ? l ? wd : yd : vd; if (au(i) && (~i.indexOf("random(") && (i = Lh(i)), "=" === i.charAt(1) && ((c = parseFloat(u) + parseFloat(i.substr(2)) * ("-" === i.charAt(0) ? -1 : 1) + (Ch(u) || 0)) || 0 === c) && (i = c)), u !== i) return isNaN(u * i) || "" === i ? (!A && !(t in e) && Tu(t, i), Ad.call(this, e, t, u, i, h, a || _A.stringFilter, l)) : (c = new Dd(this._pt, e, t, +u || 0, i - (u || 0), "boolean" == typeof A ? Md : bd, 0, h), l && (c.fp = l), o && c.modifier(o, this, e), this._pt = c) }, hd = function (e, t, n, i, r, s) { var o, a, l, c; if (Ou[e] && !1 !== (o = new Ou[e]).init(r, o.rawVars ? t[e] : function (e, t, n, i, r) { if (lu(e) && (e = pd(e, r, t, n, i)), !uu(e) || e.style && e.nodeType || gu(e) || fu(e)) return au(e) ? pd(e, r, t, n, i) : e; var s, o = {}; for (s in e) o[s] = pd(e[s], r, t, n, i); return o }(t[e], i, r, s, n), n, i, s) && (n._pt = a = new Dd(n._pt, r, e, 0, 1, o.render, o, 0, o.priority), n !== WA)) for (l = n._ptLookup[n._targets.indexOf(r)], c = o._props.length; c--;)l[o._props[c]] = a; return o }, dd = function e(t, n) { var i, r, s, o, a, l, c, A, u, h, d, p, f, g = t.vars, m = g.ease, v = g.startAt, y = g.immediateRender, w = g.lazy, x = g.onUpdate, C = g.onUpdateParams, b = g.callbackScope, M = g.runBackwards, I = g.yoyoEase, E = g.keyframes, T = g.autoRevert, P = t._dur, S = t._startAt, B = t._targets, D = t.parent, R = D && "nested" === D.data ? D.parent._targets : B, L = "auto" === t._overwrite && !FA, O = t.timeline; if (O && (!E || !m) && (m = "none"), t._ease = td(m, $A.ease), t._yEase = I ? $h(td(!0 === I ? m : I, $A.ease)) : 0, I && t._yoyo && !t._repeat && (I = t._yEase, t._yEase = t._ease, t._ease = I), t._from = !O && !!g.runBackwards, !O) { if (p = (A = B[0] ? Qu(B[0]).harness : 0) && g[A.prop], i = $u(g, Du), S && S.render(-1, !0).kill(), v) if (nh(t._startAt = md.set(B, Ku({ data: "isStart", overwrite: !1, parent: D, immediateRender: !0, lazy: hu(w), startAt: null, delay: 0, onUpdate: x, onUpdateParams: C, callbackScope: b, stagger: 0 }, v))), n < 0 && !y && !T && t._startAt.render(-1, !0), y) { if (n > 0 && !T && (t._startAt = 0), P && n <= 0) return void (n && (t._zTime = n)) } else !1 === T && (t._startAt = 0); else if (M && P) if (S) !T && (t._startAt = 0); else if (n && (y = !1), s = Ku({ overwrite: !1, data: "isFromStart", lazy: y && hu(w), immediateRender: y, stagger: 0, parent: D }, i), p && (s[A.prop] = p), nh(t._startAt = md.set(B, s)), n < 0 && t._startAt.render(-1, !0), y) { if (!n) return } else e(t._startAt, 1e-8); for (t._pt = 0, w = P && hu(w) || w && !P, r = 0; r < B.length; r++) { if (c = (a = B[r])._gsap || Fu(B)[r]._gsap, t._ptLookup[r] = h = {}, Lu[c.id] && Ru.length && Yu(), d = R === B ? r : R.indexOf(a), A && !1 !== (u = new A).init(a, p || i, t, d, R) && (t._pt = o = new Dd(t._pt, a, u.name, 0, 1, u.render, u, 0, u.priority), u._props.forEach((function (e) { h[e] = o })), u.priority && (l = 1)), !A || p) for (s in i) Ou[s] && (u = hd(s, i, t, d, a, R)) ? u.priority && (l = 1) : h[s] = o = ud.call(t, a, s, "get", i[s], d, R, 0, g.stringFilter); t._op && t._op[r] && t.kill(a, t._op[r]), L && t._pt && (cd = t, QA.killTweensOf(a, h, t.globalTime(0)), f = !t.parent, cd = 0), t._pt && w && (Lu[c.id] = 1) } l && Bd(t), t._onInit && t._onInit(t) } t._onUpdate = x, t._initted = (!t._op || t._pt) && !f }, pd = function (e, t, n, i, r) { return lu(e) ? e.call(t, n, i, r) : au(e) && ~e.indexOf("random(") ? Lh(e) : e }, fd = zu + "repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase", gd = (fd + ",id,stagger,delay,duration,paused,scrollTrigger").split(","), md = function (e) { function t(t, n, i, r) { var s; "number" == typeof n && (i.duration = n, n = i, i = null); var o, a, l, c, A, u, h, d, p = (s = e.call(this, r ? n : eh(n)) || this).vars, f = p.duration, g = p.delay, m = p.immediateRender, v = p.stagger, y = p.overwrite, w = p.keyframes, x = p.defaults, C = p.scrollTrigger, b = p.yoyoEase, M = n.parent || QA, I = (gu(t) || fu(t) ? cu(t[0]) : "length" in n) ? [t] : Eh(t); if (s._targets = I.length ? Fu(I) : Pu("GSAP target " + t + " not found. https://greensock.com", !_A.nullTargetWarn) || [], s._ptLookup = [], s._overwrite = y, w || v || pu(f) || pu(g)) { if (n = s.vars, (o = s.timeline = new ld({ data: "nested", defaults: x || {} })).kill(), o.parent = o._dp = HA(s), o._start = 0, w) Ku(o.vars.defaults, { ease: "none" }), v ? I.forEach((function (e, t) { return w.forEach((function (n, i) { return o.to(e, n, i ? ">" : t * v) })) })) : w.forEach((function (e) { return o.to(I, e, ">") })); else { if (c = I.length, h = v ? Ph(v) : Bu, uu(v)) for (A in v) ~fd.indexOf(A) && (d || (d = {}), d[A] = v[A]); for (a = 0; a < c; a++) { for (A in l = {}, n) gd.indexOf(A) < 0 && (l[A] = n[A]); l.stagger = 0, b && (l.yoyoEase = b), d && qu(l, d), u = I[a], l.duration = +pd(f, HA(s), a, u, I), l.delay = (+pd(g, HA(s), a, u, I) || 0) - s._delay, !v && 1 === c && l.delay && (s._delay = g = l.delay, s._start += g, l.delay = 0), o.to(u, l, h(a, u, I)) } o.duration() ? f = g = 0 : s.timeline = 0 } f || s.duration(f = o.duration()) } else s.timeline = 0; return !0 !== y || FA || (cd = HA(s), QA.killTweensOf(I), cd = 0), uh(M, HA(s), i), n.reversed && s.reverse(), n.paused && s.paused(!0), (m || !f && !w && s._start === Uu(M._time) && hu(m) && function e(t) { return !t || t._ts && e(t.parent) }(HA(s)) && "nested" !== M.data) && (s._tTime = -1e-8, s.render(Math.max(0, -g))), C && hh(HA(s), C), s } zA(t, e); var n = t.prototype; return n.render = function (e, t, n) { var i, r, s, o, a, l, c, A, u, h = this._time, d = this._tDur, p = this._dur, f = e > d - 1e-8 && e >= 0 ? d : e < 1e-8 ? 0 : e; if (p) { if (f !== this._tTime || !e || n || !this._initted && this._tTime || this._startAt && this._zTime < 0 != e < 0) { if (i = f, A = this.timeline, this._repeat) { if (o = p + this._rDelay, this._repeat < -1 && e < 0) return this.totalTime(100 * o + e, t, n); if (i = Uu(f % o), f === d ? (s = this._repeat, i = p) : ((s = ~~(f / o)) && s === f / o && (i = p, s--), i > p && (i = p)), (l = this._yoyo && 1 & s) && (u = this._yEase, i = p - i), a = oh(this._tTime, o), i === h && !n && this._initted) return this; s !== a && (A && this._yEase && ed(A, l), !this.vars.repeatRefresh || l || this._lock || (this._lock = n = 1, this.render(Uu(o * s), !0).invalidate()._lock = 0)) } if (!this._initted) { if (dh(this, e < 0 ? e : i, n, t)) return this._tTime = 0, this; if (p !== this._dur) return this.render(e, t, n) } if (this._tTime = f, this._time = i, !this._act && this._ts && (this._act = 1, this._lazy = 0), this.ratio = c = (u || this._ease)(i / p), this._from && (this.ratio = c = 1 - c), i && !h && !t && kh(this, "onStart"), i && !h && !t && (kh(this, "onStart"), this._tTime !== f)) return this; for (r = this._pt; r;)r.r(c, r.d), r = r._next; A && A.render(e < 0 ? e : !i && l ? -1e-8 : A._dur * c, t, n) || this._startAt && (this._zTime = e), this._onUpdate && !t && (e < 0 && this._startAt && this._startAt.render(e, !0, n), kh(this, "onUpdate")), this._repeat && s !== a && this.vars.onRepeat && !t && this.parent && kh(this, "onRepeat"), f !== this._tDur && f || this._tTime !== f || (e < 0 && this._startAt && !this._onUpdate && this._startAt.render(e, !0, !0), (e || !p) && (f === this._tDur && this._ts > 0 || !f && this._ts < 0) && nh(this, 1), t || e < 0 && !h || !f && !h || (kh(this, f === d ? "onComplete" : "onReverseComplete", !0), this._prom && !(f < d && this.timeScale() > 0) && this._prom())) } } else !function (e, t, n, i) { var r, s, o, a = e.ratio, l = t < 0 || !t && (!e._start && function e(t) { var n = t.parent; return n && n._ts && n._initted && !n._lock && (n.rawTime() < 0 || e(n)) }(e) && (e._initted || !ph(e)) || (e._ts < 0 || e._dp._ts < 0) && !ph(e)) ? 0 : 1, c = e._rDelay, A = 0; if (c && e._repeat && (A = xh(0, e._tDur, t), s = oh(A, c), o = oh(e._tTime, c), e._yoyo && 1 & s && (l = 1 - l), s !== o && (a = 1 - l, e.vars.repeatRefresh && e._initted && e.invalidate())), l !== a || i || 1e-8 === e._zTime || !t && e._zTime) { if (!e._initted && dh(e, t, i, n)) return; for (o = e._zTime, e._zTime = t || (n ? 1e-8 : 0), n || (n = t && !o), e.ratio = l, e._from && (l = 1 - l), e._time = 0, e._tTime = A, r = e._pt; r;)r.r(l, r.d), r = r._next; e._startAt && t < 0 && e._startAt.render(t, !0, !0), e._onUpdate && !n && kh(e, "onUpdate"), A && e._repeat && !n && e.parent && kh(e, "onRepeat"), (t >= e._tDur || t < 0) && e.ratio === l && (l && nh(e, 1), n || (kh(e, l ? "onComplete" : "onReverseComplete", !0), e._prom && e._prom())) } else e._zTime || (e._zTime = t) }(this, e, t, n); return this }, n.targets = function () { return this._targets }, n.invalidate = function () { return this._pt = this._op = this._startAt = this._onUpdate = this._lazy = this.ratio = 0, this._ptLookup = [], this.timeline && this.timeline.invalidate(), e.prototype.invalidate.call(this) }, n.kill = function (e, t) { if (void 0 === t && (t = "all"), !(e || t && "all" !== t)) return this._lazy = this._pt = 0, this.parent ? Hh(this) : this; if (this.timeline) { var n = this.timeline.totalDuration(); return this.timeline.killTweensOf(e, t, cd && !0 !== cd.vars.overwrite)._first || Hh(this), this.parent && n !== this.timeline.totalDuration() && fh(this, this._dur * this.timeline._tDur / n, 0, 1), this } var i, r, s, o, a, l, c, A = this._targets, u = e ? Eh(e) : A, h = this._ptLookup, d = this._pt; if ((!t || "all" === t) && function (e, t) { for (var n = e.length, i = n === t.length; i && n-- && e[n] === t[n];); return n < 0 }(A, u)) return "all" === t && (this._pt = 0), Hh(this); for (i = this._op = this._op || [], "all" !== t && (au(t) && (a = {}, ju(t, (function (e) { return a[e] = 1 })), t = a), t = function (e, t) { var n, i, r, s, o = e[0] ? Qu(e[0]).harness : 0, a = o && o.aliases; if (!a) return t; for (i in n = qu({}, t), a) if (i in n) for (r = (s = a[i].split(",")).length; r--;)n[s[r]] = n[i]; return n }(A, t)), c = A.length; c--;)if (~u.indexOf(A[c])) for (a in r = h[c], "all" === t ? (i[c] = t, o = r, s = {}) : (s = i[c] = i[c] || {}, o = t), o) (l = r && r[a]) && ("kill" in l.d && !0 !== l.d.kill(a) || th(this, l, "_pt"), delete r[a]), "all" !== s && (s[a] = 1); return this._initted && !this._pt && d && Hh(this), this }, t.to = function (e, n) { return new t(e, n, arguments[2]) }, t.from = function (e, t) { return yh(1, arguments) }, t.delayedCall = function (e, n, i, r) { return new t(n, 0, { immediateRender: !1, lazy: !1, overwrite: !1, delay: e, onComplete: n, onReverseComplete: n, onCompleteParams: i, onReverseCompleteParams: i, callbackScope: r }) }, t.fromTo = function (e, t, n) { return yh(2, arguments) }, t.set = function (e, n) { return n.duration = 0, n.repeatDelay || (n.repeat = 0), new t(e, n) }, t.killTweensOf = function (e, t, n) { return QA.killTweensOf(e, t, n) }, t }(ad); Ku(md.prototype, { _targets: [], _lazy: 0, _startAt: 0, _op: 0, _onInit: 0 }), ju("staggerTo,staggerFrom,staggerFromTo", (function (e) { md[e] = function () { var t = new ld, n = bh.call(arguments, 0); return n.splice("staggerFromTo" === e ? 5 : 4, 0, 0), t[e].apply(t, n) } })); var vd = function (e, t, n) { return e[t] = n }, yd = function (e, t, n) { return e[t](n) }, wd = function (e, t, n, i) { return e[t](i.fp, n) }, xd = function (e, t, n) { return e.setAttribute(t, n) }, Cd = function (e, t) { return lu(e[t]) ? yd : Au(e[t]) && e.setAttribute ? xd : vd }, bd = function (e, t) { return t.set(t.t, t.p, Math.round(1e6 * (t.s + t.c * e)) / 1e6, t) }, Md = function (e, t) { return t.set(t.t, t.p, !!(t.s + t.c * e), t) }, Id = function (e, t) { var n = t._pt, i = ""; if (!e && t.b) i = t.b; else if (1 === e && t.e) i = t.e; else { for (; n;)i = n.p + (n.m ? n.m(n.s + n.c * e) : Math.round(1e4 * (n.s + n.c * e)) / 1e4) + i, n = n._next; i += t.c } t.set(t.t, t.p, i, t) }, Ed = function (e, t) { for (var n = t._pt; n;)n.r(e, n.d), n = n._next }, Td = function (e, t, n, i) { for (var r, s = this._pt; s;)r = s._next, s.p === i && s.modifier(e, t, n), s = r }, Pd = function (e) { for (var t, n, i = this._pt; i;)n = i._next, i.p === e && !i.op || i.op === e ? th(this, i, "_pt") : i.dep || (t = 1), i = n; return !t }, Sd = function (e, t, n, i) { i.mSet(e, t, i.m.call(i.tween, n, i.mt), i) }, Bd = function (e) { for (var t, n, i, r, s = e._pt; s;) { for (t = s._next, n = i; n && n.pr > s.pr;)n = n._next; (s._prev = n ? n._prev : r) ? s._prev._next = s : i = s, (s._next = n) ? n._prev = s : r = s, s = t } e._pt = i }, Dd = function () { function e(e, t, n, i, r, s, o, a, l) { this.t = t, this.s = i, this.c = r, this.p = n, this.r = s || bd, this.d = o || this, this.set = a || vd, this.pr = l || 0, this._next = e, e && (e._prev = this) } return e.prototype.modifier = function (e, t, n) { this.mSet = this.mSet || this.set, this.set = Sd, this.m = e, this.mt = n, this.tween = t }, e }(); ju(zu + "parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger", (function (e) { return Du[e] = 1 })), Mu.TweenMax = Mu.TweenLite = md, Mu.TimelineLite = Mu.TimelineMax = ld, QA = new ld({ sortChildren: !1, defaults: $A, autoRemoveChildren: !0, id: "root", smoothChildTiming: !0 }), _A.stringFilter = Wh; var Rd = { registerPlugin: function () { for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)t[n] = arguments[n]; t.forEach((function (e) { return zh(e) })) }, timeline: function (e) { return new ld(e) }, getTweensOf: function (e, t) { return QA.getTweensOf(e, t) }, getProperty: function (e, t, n, i) { au(e) && (e = Eh(e)[0]); var r = Qu(e || {}).get, s = n ? Ju : Xu; return "native" === n && (n = ""), e ? t ? s((Ou[t] && Ou[t].get || r)(e, t, n, i)) : function (t, n, i) { return s((Ou[t] && Ou[t].get || r)(e, t, n, i)) } : e }, quickSetter: function (e, t, n) { if ((e = Eh(e)).length > 1) { var i = e.map((function (e) { return Nd.quickSetter(e, t, n) })), r = i.length; return function (e) { for (var t = r; t--;)i[t](e) } } e = e[0] || {}; var s = Ou[t], o = Qu(e), a = o.harness && (o.harness.aliases || {})[t] || t, l = s ? function (t) { var i = new s; WA._pt = 0, i.init(e, n ? t + n : t, WA, 0, [e]), i.render(1, i), WA._pt && Ed(1, WA) } : o.set(e, a); return s ? l : function (t) { return l(e, a, n ? t + n : t, o, 1) } }, isTweening: function (e) { return QA.getTweensOf(e, !0).length > 0 }, defaults: function (e) { return e && e.ease && (e.ease = td(e.ease, $A.ease)), _u($A, e || {}) }, config: function (e) { return _u(_A, e || {}) }, registerEffect: function (e) { var t = e.name, n = e.effect, i = e.plugins, r = e.defaults, s = e.extendTimeline; (i || "").split(",").forEach((function (e) { return e && !Ou[e] && !Mu[e] && Pu(t + " effect requires " + e + " plugin.") })), Nu[t] = function (e, t, i) { return n(Eh(e), Ku(t || {}, r), i) }, s && (ld.prototype[t] = function (e, n, i) { return this.add(Nu[t](e, uu(n) ? n : (i = n) && {}, this), i) }) }, registerEase: function (e, t) { Kh[e] = td(t) }, parseEase: function (e, t) { return arguments.length ? td(e, t) : Kh }, getById: function (e) { return QA.getById(e) }, exportRoot: function (e, t) { void 0 === e && (e = {}); var n, i, r = new ld(e); for (r.smoothChildTiming = hu(e.smoothChildTiming), QA.remove(r), r._dp = 0, r._time = r._tTime = QA._time, n = QA._first; n;)i = n._next, !t && !n._dur && n instanceof md && n.vars.onComplete === n._targets[0] || uh(r, n, n._start - n._delay), n = i; return uh(QA, r, 0), r }, utils: { wrap: function e(t, n, i) { var r = n - t; return gu(t) ? Rh(t, e(0, t.length), n) : wh(i, (function (e) { return (r + (e - t) % r) % r + t })) }, wrapYoyo: function e(t, n, i) { var r = n - t, s = 2 * r; return gu(t) ? Rh(t, e(0, t.length - 1), n) : wh(i, (function (e) { return t + ((e = (s + (e - t) % s) % s || 0) > r ? s - e : e) })) }, distribute: Ph, random: Dh, snap: Bh, normalize: function (e, t, n) { return Oh(e, t, 0, 1, n) }, getUnit: Ch, clamp: function (e, t, n) { return wh(n, (function (n) { return xh(e, t, n) })) }, splitColor: Gh, toArray: Eh, selector: function (e) { return e = Eh(e)[0] || Pu("Invalid scope") || {}, function (t) { var n = e.current || e.nativeElement || e; return Eh(t, n.querySelectorAll ? n : n === e ? Pu("Invalid scope") || UA.createElement("div") : e) } }, mapRange: Oh, pipe: function () { for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)t[n] = arguments[n]; return function (e) { return t.reduce((function (e, t) { return t(e) }), e) } }, unitize: function (e, t) { return function (n) { return e(parseFloat(n)) + (t || Ch(n)) } }, interpolate: function e(t, n, i, r) { var s = isNaN(t + n) ? 0 : function (e) { return (1 - e) * t + e * n }; if (!s) { var o, a, l, c, A, u = au(t), h = {}; if (!0 === i && (r = 1) && (i = null), u) t = { p: t }, n = { p: n }; else if (gu(t) && !gu(n)) { for (l = [], c = t.length, A = c - 2, a = 1; a < c; a++)l.push(e(t[a - 1], t[a])); c--, s = function (e) { e *= c; var t = Math.min(A, ~~e); return l[t](e - t) }, i = n } else r || (t = qu(gu(t) ? [] : {}, t)); if (!l) { for (o in n) ud.call(h, t, o, "get", n[o]); s = function (e) { return Ed(e, h) || (u ? t.p : t) } } } return wh(i, s) }, shuffle: Th }, install: Eu, effects: Nu, ticker: Xh, updateRoot: ld.updateRoot, plugins: Ou, globalTimeline: QA, core: { PropTween: Dd, globals: Su, Tween: md, Timeline: ld, Animation: ad, getCache: Qu, _removeLinkedListItem: th, suppressOverwrites: function (e) { return FA = e } } }; ju("to,from,fromTo,delayedCall,set,killTweensOf", (function (e) { return Rd[e] = md[e] })), Xh.add(ld.updateRoot), WA = Rd.to({}, { duration: 0 }); var Ld = function (e, t) { for (var n = e._pt; n && n.p !== t && n.op !== t && n.fp !== t;)n = n._next; return n }, Od = function (e, t) { return { name: e, rawVars: 1, init: function (e, n, i) { i._onInit = function (e) { var i, r; if (au(n) && (i = {}, ju(n, (function (e) { return i[e] = 1 })), n = i), t) { for (r in i = {}, n) i[r] = t(n[r]); n = i } !function (e, t) { var n, i, r, s = e._targets; for (n in t) for (i = s.length; i--;)(r = e._ptLookup[i][n]) && (r = r.d) && (r._pt && (r = Ld(r, n)), r && r.modifier && r.modifier(t[n], e, s[i], n)) }(e, n) } } } }, Nd = Rd.registerPlugin({ name: "attr", init: function (e, t, n, i, r) { var s, o; for (s in t) (o = this.add(e, "setAttribute", (e.getAttribute(s) || 0) + "", t[s], i, r, 0, 0, s)) && (o.op = s), this._props.push(s) } }, { name: "endArray", init: function (e, t) { for (var n = t.length; n--;)this.add(e, n, e[n] || 0, t[n]) } }, Od("roundProps", Sh), Od("modifiers"), Od("snap", Bh)) || Rd; md.version = ld.version = Nd.version = "3.7.0", VA = 1, du() && Jh(); Kh.Power0, Kh.Power1, Kh.Power2, Kh.Power3, Kh.Power4, Kh.Linear, Kh.Quad, Kh.Cubic, Kh.Quart, Kh.Quint, Kh.Strong, Kh.Elastic, Kh.Back, Kh.SteppedEase, Kh.Bounce, Kh.Sine, Kh.Expo, Kh.Circ; var kd, Hd, zd, Fd, Qd, Gd, jd, Ud = {}, Vd = 180 / Math.PI, Yd = Math.PI / 180, Wd = Math.atan2, Xd = /([A-Z])/g, Jd = /(?:left|right|width|margin|padding|x)/i, Kd = /[\s,\(]\S/, Zd = { autoAlpha: "opacity,visibility", scale: "scaleX,scaleY", alpha: "opacity" }, qd = function (e, t) { return t.set(t.t, t.p, Math.round(1e4 * (t.s + t.c * e)) / 1e4 + t.u, t) }, _d = function (e, t) { return t.set(t.t, t.p, 1 === e ? t.e : Math.round(1e4 * (t.s + t.c * e)) / 1e4 + t.u, t) }, $d = function (e, t) { return t.set(t.t, t.p, e ? Math.round(1e4 * (t.s + t.c * e)) / 1e4 + t.u : t.b, t) }, ep = function (e, t) { var n = t.s + t.c * e; t.set(t.t, t.p, ~~(n + (n < 0 ? -.5 : .5)) + t.u, t) }, tp = function (e, t) { return t.set(t.t, t.p, e ? t.e : t.b, t) }, np = function (e, t) { return t.set(t.t, t.p, 1 !== e ? t.b : t.e, t) }, ip = function (e, t, n) { return e.style[t] = n }, rp = function (e, t, n) { return e.style.setProperty(t, n) }, sp = function (e, t, n) { return e._gsap[t] = n }, op = function (e, t, n) { return e._gsap.scaleX = e._gsap.scaleY = n }, ap = function (e, t, n, i, r) { var s = e._gsap; s.scaleX = s.scaleY = n, s.renderTransform(r, s) }, lp = function (e, t, n, i, r) { var s = e._gsap; s[t] = n, s.renderTransform(r, s) }, cp = "transform", Ap = cp + "Origin", up = function (e, t) { var n = Hd.createElementNS ? Hd.createElementNS((t || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"), e) : Hd.createElement(e); return n.style ? n : Hd.createElement(e) }, hp = function e(t, n, i) { var r = getComputedStyle(t); return r[n] || r.getPropertyValue(n.replace(Xd, "-$1").toLowerCase()) || r.getPropertyValue(n) || !i && e(t, pp(n) || n, 1) || "" }, dp = "O,Moz,ms,Ms,Webkit".split(","), pp = function (e, t, n) { var i = (t || Qd).style, r = 5; if (e in i && !n) return e; for (e = e.charAt(0).toUpperCase() + e.substr(1); r-- && !(dp[r] + e in i);); return r < 0 ? null : (3 === r ? "ms" : r >= 0 ? dp[r] : "") + e }, fp = function () { "undefined" != typeof window && window.document && (kd = window, Hd = kd.document, zd = Hd.documentElement, Qd = up("div") || { style: {} }, up("div"), cp = pp(cp), Ap = cp + "Origin", Qd.style.cssText = "border-width:0;line-height:0;position:absolute;padding:0", jd = !!pp("perspective"), Fd = 1) }, gp = function e(t) { var n, i = up("svg", this.ownerSVGElement && this.ownerSVGElement.getAttribute("xmlns") || "http://www.w3.org/2000/svg"), r = this.parentNode, s = this.nextSibling, o = this.style.cssText; if (zd.appendChild(i), i.appendChild(this), this.style.display = "block", t) try { n = this.getBBox(), this._gsapBBox = this.getBBox, this.getBBox = e } catch (e) { } else this._gsapBBox && (n = this._gsapBBox()); return r && (s ? r.insertBefore(this, s) : r.appendChild(this)), zd.removeChild(i), this.style.cssText = o, n }, mp = function (e, t) { for (var n = t.length; n--;)if (e.hasAttribute(t[n])) return e.getAttribute(t[n]) }, vp = function (e) { var t; try { t = e.getBBox() } catch (n) { t = gp.call(e, !0) } return t && (t.width || t.height) || e.getBBox === gp || (t = gp.call(e, !0)), !t || t.width || t.x || t.y ? t : { x: +mp(e, ["x", "cx", "x1"]) || 0, y: +mp(e, ["y", "cy", "y1"]) || 0, width: 0, height: 0 } }, yp = function (e) { return !(!e.getCTM || e.parentNode && !e.ownerSVGElement || !vp(e)) }, wp = function (e, t) { if (t) { var n = e.style; t in Ud && t !== Ap && (t = cp), n.removeProperty ? ("ms" !== t.substr(0, 2) && "webkit" !== t.substr(0, 6) || (t = "-" + t), n.removeProperty(t.replace(Xd, "-$1").toLowerCase())) : n.removeAttribute(t) } }, xp = function (e, t, n, i, r, s) { var o = new Dd(e._pt, t, n, 0, 1, s ? np : tp); return e._pt = o, o.b = i, o.e = r, e._props.push(n), o }, Cp = { deg: 1, rad: 1, turn: 1 }, bp = function e(t, n, i, r) { var s, o, a, l, c = parseFloat(i) || 0, A = (i + "").trim().substr((c + "").length) || "px", u = Qd.style, h = Jd.test(n), d = "svg" === t.tagName.toLowerCase(), p = (d ? "client" : "offset") + (h ? "Width" : "Height"), f = "px" === r, g = "%" === r; return r === A || !c || Cp[r] || Cp[A] ? c : ("px" !== A && !f && (c = e(t, n, i, "px")), l = t.getCTM && yp(t), !g && "%" !== A || !Ud[n] && !~n.indexOf("adius") ? (u[h ? "width" : "height"] = 100 + (f ? A : r), o = ~n.indexOf("adius") || "em" === r && t.appendChild && !d ? t : t.parentNode, l && (o = (t.ownerSVGElement || {}).parentNode), o && o !== Hd && o.appendChild || (o = Hd.body), (a = o._gsap) && g && a.width && h && a.time === Xh.time ? Uu(c / a.width * 100) : ((g || "%" === A) && (u.position = hp(t, "position")), o === t && (u.position = "static"), o.appendChild(Qd), s = Qd[p], o.removeChild(Qd), u.position = "absolute", h && g && ((a = Qu(o)).time = Xh.time, a.width = o[p]), Uu(f ? s * c / 100 : s && c ? 100 / s * c : 0))) : (s = l ? t.getBBox()[h ? "width" : "height"] : t[p], Uu(g ? c / s * 100 : c / 100 * s))) }, Mp = function (e, t, n, i) { var r; return Fd || fp(), t in Zd && "transform" !== t && ~(t = Zd[t]).indexOf(",") && (t = t.split(",")[0]), Ud[t] && "transform" !== t ? (r = Np(e, i), r = "transformOrigin" !== t ? r[t] : r.svg ? r.origin : kp(hp(e, Ap)) + " " + r.zOrigin + "px") : (!(r = e.style[t]) || "auto" === r || i || ~(r + "").indexOf("calc(")) && (r = Pp[t] && Pp[t](e, t, n) || hp(e, t) || Gu(e, t) || ("opacity" === t ? 1 : 0)), n && !~(r + "").trim().indexOf(" ") ? bp(e, t, r, n) + n : r }, Ip = function (e, t, n, i) { if (!n || "none" === n) { var r = pp(t, e, 1), s = r && hp(e, r, 1); s && s !== n ? (t = r, n = s) : "borderColor" === t && (n = hp(e, "borderTopColor")) } var o, a, l, c, A, u, h, d, p, f, g, m, v = new Dd(this._pt, e.style, t, 0, 1, Id), y = 0, w = 0; if (v.b = n, v.e = i, n += "", "auto" === (i += "") && (e.style[t] = i, i = hp(e, t) || i, e.style[t] = n), Wh(o = [n, i]), i = o[1], l = (n = o[0]).match(yu) || [], (i.match(yu) || []).length) { for (; a = yu.exec(i);)h = a[0], p = i.substring(y, a.index), A ? A = (A + 1) % 5 : "rgba(" !== p.substr(-5) && "hsla(" !== p.substr(-5) || (A = 1), h !== (u = l[w++] || "") && (c = parseFloat(u) || 0, g = u.substr((c + "").length), (m = "=" === h.charAt(1) ? +(h.charAt(0) + "1") : 0) && (h = h.substr(2)), d = parseFloat(h), f = h.substr((d + "").length), y = yu.lastIndex - f.length, f || (f = f || _A.units[t] || g, y === i.length && (i += f, v.e += f)), g !== f && (c = bp(e, t, u, f) || 0), v._pt = { _next: v._pt, p: p || 1 === w ? p : ",", s: c, c: m ? m * d : d - c, m: A && A < 4 || "zIndex" === t ? Math.round : 0 }); v.c = y < i.length ? i.substring(y, i.length) : "" } else v.r = "display" === t && "none" === i ? np : tp; return xu.test(i) && (v.e = 0), this._pt = v, v }, Ep = { top: "0%", bottom: "100%", left: "0%", right: "100%", center: "50%" }, Tp = function (e, t) { if (t.tween && t.tween._time === t.tween._dur) { var n, i, r, s = t.t, o = s.style, a = t.u, l = s._gsap; if ("all" === a || !0 === a) o.cssText = "", i = 1; else for (r = (a = a.split(",")).length; --r > -1;)n = a[r], Ud[n] && (i = 1, n = "transformOrigin" === n ? Ap : cp), wp(s, n); i && (wp(s, cp), l && (l.svg && s.removeAttribute("transform"), Np(s, 1), l.uncache = 1)) } }, Pp = { clearProps: function (e, t, n, i, r) { if ("isFromStart" !== r.data) { var s = e._pt = new Dd(e._pt, t, n, 0, 0, Tp); return s.u = i, s.pr = -10, s.tween = r, e._props.push(n), 1 } } }, Sp = [1, 0, 0, 1, 0, 0], Bp = {}, Dp = function (e) { return "matrix(1, 0, 0, 1, 0, 0)" === e || "none" === e || !e }, Rp = function (e) { var t = hp(e, cp); return Dp(t) ? Sp : t.substr(7).match(vu).map(Uu) }, Lp = function (e, t) { var n, i, r, s, o = e._gsap || Qu(e), a = e.style, l = Rp(e); return o.svg && e.getAttribute("transform") ? "1,0,0,1,0,0" === (l = [(r = e.transform.baseVal.consolidate().matrix).a, r.b, r.c, r.d, r.e, r.f]).join(",") ? Sp : l : (l !== Sp || e.offsetParent || e === zd || o.svg || (r = a.display, a.display = "block", (n = e.parentNode) && e.offsetParent || (s = 1, i = e.nextSibling, zd.appendChild(e)), l = Rp(e), r ? a.display = r : wp(e, "display"), s && (i ? n.insertBefore(e, i) : n ? n.appendChild(e) : zd.removeChild(e))), t && l.length > 6 ? [l[0], l[1], l[4], l[5], l[12], l[13]] : l) }, Op = function (e, t, n, i, r, s) { var o, a, l, c = e._gsap, A = r || Lp(e, !0), u = c.xOrigin || 0, h = c.yOrigin || 0, d = c.xOffset || 0, p = c.yOffset || 0, f = A[0], g = A[1], m = A[2], v = A[3], y = A[4], w = A[5], x = t.split(" "), C = parseFloat(x[0]) || 0, b = parseFloat(x[1]) || 0; n ? A !== Sp && (a = f * v - g * m) && (l = C * (-g / a) + b * (f / a) - (f * w - g * y) / a, C = C * (v / a) + b * (-m / a) + (m * w - v * y) / a, b = l) : (C = (o = vp(e)).x + (~x[0].indexOf("%") ? C / 100 * o.width : C), b = o.y + (~(x[1] || x[0]).indexOf("%") ? b / 100 * o.height : b)), i || !1 !== i && c.smooth ? (y = C - u, w = b - h, c.xOffset = d + (y * f + w * m) - y, c.yOffset = p + (y * g + w * v) - w) : c.xOffset = c.yOffset = 0, c.xOrigin = C, c.yOrigin = b, c.smooth = !!i, c.origin = t, c.originIsAbsolute = !!n, e.style[Ap] = "0px 0px", s && (xp(s, c, "xOrigin", u, C), xp(s, c, "yOrigin", h, b), xp(s, c, "xOffset", d, c.xOffset), xp(s, c, "yOffset", p, c.yOffset)), e.setAttribute("data-svg-origin", C + " " + b) }, Np = function (e, t) { var n = e._gsap || new od(e); if ("x" in n && !t && !n.uncache) return n; var i, r, s, o, a, l, c, A, u, h, d, p, f, g, m, v, y, w, x, C, b, M, I, E, T, P, S, B, D, R, L, O, N = e.style, k = n.scaleX < 0, H = hp(e, Ap) || "0"; return i = r = s = l = c = A = u = h = d = 0, o = a = 1, n.svg = !(!e.getCTM || !yp(e)), g = Lp(e, n.svg), n.svg && (E = (!n.uncache || "0px 0px" === H) && !t && e.getAttribute("data-svg-origin"), Op(e, E || H, !!E || n.originIsAbsolute, !1 !== n.smooth, g)), p = n.xOrigin || 0, f = n.yOrigin || 0, g !== Sp && (w = g[0], x = g[1], C = g[2], b = g[3], i = M = g[4], r = I = g[5], 6 === g.length ? (o = Math.sqrt(w * w + x * x), a = Math.sqrt(b * b + C * C), l = w || x ? Wd(x, w) * Vd : 0, (u = C || b ? Wd(C, b) * Vd + l : 0) && (a *= Math.abs(Math.cos(u * Yd))), n.svg && (i -= p - (p * w + f * C), r -= f - (p * x + f * b))) : (O = g[6], R = g[7], S = g[8], B = g[9], D = g[10], L = g[11], i = g[12], r = g[13], s = g[14], c = (m = Wd(O, D)) * Vd, m && (E = M * (v = Math.cos(-m)) + S * (y = Math.sin(-m)), T = I * v + B * y, P = O * v + D * y, S = M * -y + S * v, B = I * -y + B * v, D = O * -y + D * v, L = R * -y + L * v, M = E, I = T, O = P), A = (m = Wd(-C, D)) * Vd, m && (v = Math.cos(-m), L = b * (y = Math.sin(-m)) + L * v, w = E = w * v - S * y, x = T = x * v - B * y, C = P = C * v - D * y), l = (m = Wd(x, w)) * Vd, m && (E = w * (v = Math.cos(m)) + x * (y = Math.sin(m)), T = M * v + I * y, x = x * v - w * y, I = I * v - M * y, w = E, M = T), c && Math.abs(c) + Math.abs(l) > 359.9 && (c = l = 0, A = 180 - A), o = Uu(Math.sqrt(w * w + x * x + C * C)), a = Uu(Math.sqrt(I * I + O * O)), m = Wd(M, I), u = Math.abs(m) > 2e-4 ? m * Vd : 0, d = L ? 1 / (L < 0 ? -L : L) : 0), n.svg && (E = e.getAttribute("transform"), n.forceCSS = e.setAttribute("transform", "") || !Dp(hp(e, cp)), E && e.setAttribute("transform", E))), Math.abs(u) > 90 && Math.abs(u) < 270 && (k ? (o *= -1, u += l <= 0 ? 180 : -180, l += l <= 0 ? 180 : -180) : (a *= -1, u += u <= 0 ? 180 : -180)), n.x = i - ((n.xPercent = i && (n.xPercent || (Math.round(e.offsetWidth / 2) === Math.round(-i) ? -50 : 0))) ? e.offsetWidth * n.xPercent / 100 : 0) + "px", n.y = r - ((n.yPercent = r && (n.yPercent || (Math.round(e.offsetHeight / 2) === Math.round(-r) ? -50 : 0))) ? e.offsetHeight * n.yPercent / 100 : 0) + "px", n.z = s + "px", n.scaleX = Uu(o), n.scaleY = Uu(a), n.rotation = Uu(l) + "deg", n.rotationX = Uu(c) + "deg", n.rotationY = Uu(A) + "deg", n.skewX = u + "deg", n.skewY = h + "deg", n.transformPerspective = d + "px", (n.zOrigin = parseFloat(H.split(" ")[2]) || 0) && (N[Ap] = kp(H)), n.xOffset = n.yOffset = 0, n.force3D = _A.force3D, n.renderTransform = n.svg ? Qp : jd ? Fp : zp, n.uncache = 0, n }, kp = function (e) { return (e = e.split(" "))[0] + " " + e[1] }, Hp = function (e, t, n) { var i = Ch(t); return Uu(parseFloat(t) + parseFloat(bp(e, "x", n + "px", i))) + i }, zp = function (e, t) { t.z = "0px", t.rotationY = t.rotationX = "0deg", t.force3D = 0, Fp(e, t) }, Fp = function (e, t) { var n = t || this, i = n.xPercent, r = n.yPercent, s = n.x, o = n.y, a = n.z, l = n.rotation, c = n.rotationY, A = n.rotationX, u = n.skewX, h = n.skewY, d = n.scaleX, p = n.scaleY, f = n.transformPerspective, g = n.force3D, m = n.target, v = n.zOrigin, y = "", w = "auto" === g && e && 1 !== e || !0 === g; if (v && ("0deg" !== A || "0deg" !== c)) { var x, C = parseFloat(c) * Yd, b = Math.sin(C), M = Math.cos(C); C = parseFloat(A) * Yd, x = Math.cos(C), s = Hp(m, s, b * x * -v), o = Hp(m, o, -Math.sin(C) * -v), a = Hp(m, a, M * x * -v + v) } "0px" !== f && (y += "perspective(" + f + ") "), (i || r) && (y += "translate(" + i + "%, " + r + "%) "), (w || "0px" !== s || "0px" !== o || "0px" !== a) && (y += "0px" !== a || w ? "translate3d(" + s + ", " + o + ", " + a + ") " : "translate(" + s + ", " + o + ") "), "0deg" !== l && (y += "rotate(" + l + ") "), "0deg" !== c && (y += "rotateY(" + c + ") "), "0deg" !== A && (y += "rotateX(" + A + ") "), "0deg" === u && "0deg" === h || (y += "skew(" + u + ", " + h + ") "), 1 === d && 1 === p || (y += "scale(" + d + ", " + p + ") "), m.style[cp] = y || "translate(0, 0)" }, Qp = function (e, t) { var n, i, r, s, o, a = t || this, l = a.xPercent, c = a.yPercent, A = a.x, u = a.y, h = a.rotation, d = a.skewX, p = a.skewY, f = a.scaleX, g = a.scaleY, m = a.target, v = a.xOrigin, y = a.yOrigin, w = a.xOffset, x = a.yOffset, C = a.forceCSS, b = parseFloat(A), M = parseFloat(u); h = parseFloat(h), d = parseFloat(d), (p = parseFloat(p)) && (d += p = parseFloat(p), h += p), h || d ? (h *= Yd, d *= Yd, n = Math.cos(h) * f, i = Math.sin(h) * f, r = Math.sin(h - d) * -g, s = Math.cos(h - d) * g, d && (p *= Yd, o = Math.tan(d - p), r *= o = Math.sqrt(1 + o * o), s *= o, p && (o = Math.tan(p), n *= o = Math.sqrt(1 + o * o), i *= o)), n = Uu(n), i = Uu(i), r = Uu(r), s = Uu(s)) : (n = f, s = g, i = r = 0), (b && !~(A + "").indexOf("px") || M && !~(u + "").indexOf("px")) && (b = bp(m, "x", A, "px"), M = bp(m, "y", u, "px")), (v || y || w || x) && (b = Uu(b + v - (v * n + y * r) + w), M = Uu(M + y - (v * i + y * s) + x)), (l || c) && (o = m.getBBox(), b = Uu(b + l / 100 * o.width), M = Uu(M + c / 100 * o.height)), o = "matrix(" + n + "," + i + "," + r + "," + s + "," + b + "," + M + ")", m.setAttribute("transform", o), C && (m.style[cp] = o) }, Gp = function (e, t, n, i, r, s) { var o, a, l = au(r), c = parseFloat(r) * (l && ~r.indexOf("rad") ? Vd : 1), A = s ? c * s : c - i, u = i + A + "deg"; return l && ("short" === (o = r.split("_")[1]) && (A %= 360) !== A % 180 && (A += A < 0 ? 360 : -360), "cw" === o && A < 0 ? A = (A + 36e9) % 360 - 360 * ~~(A / 360) : "ccw" === o && A > 0 && (A = (A - 36e9) % 360 - 360 * ~~(A / 360))), e._pt = a = new Dd(e._pt, t, n, i, A, _d), a.e = u, a.u = "deg", e._props.push(n), a }, jp = function (e, t) { for (var n in t) e[n] = t[n]; return e }, Up = function (e, t, n) { var i, r, s, o, a, l, c, A = jp({}, n._gsap), u = n.style; for (r in A.svg ? (s = n.getAttribute("transform"), n.setAttribute("transform", ""), u[cp] = t, i = Np(n, 1), wp(n, cp), n.setAttribute("transform", s)) : (s = getComputedStyle(n)[cp], u[cp] = t, i = Np(n, 1), u[cp] = s), Ud) (s = A[r]) !== (o = i[r]) && "perspective,force3D,transformOrigin,svgOrigin".indexOf(r) < 0 && (a = Ch(s) !== (c = Ch(o)) ? bp(n, r, s, c) : parseFloat(s), l = parseFloat(o), e._pt = new Dd(e._pt, i, r, a, l - a, qd), e._pt.u = c || 0, e._props.push(r)); jp(i, A) }; ju("padding,margin,Width,Radius", (function (e, t) { var n = "Top", i = "Right", r = "Bottom", s = "Left", o = (t < 3 ? [n, i, r, s] : [n + s, n + i, r + i, r + s]).map((function (n) { return t < 2 ? e + n : "border" + n + e })); Pp[t > 1 ? "border" + e : e] = function (e, t, n, i, r) { var s, a; if (arguments.length < 4) return s = o.map((function (t) { return Mp(e, t, n) })), 5 === (a = s.join(" ")).split(s[0]).length ? s[0] : a; s = (i + "").split(" "), a = {}, o.forEach((function (e, t) { return a[e] = s[t] = s[t] || s[(t - 1) / 2 | 0] })), e.init(t, a, r) } })); var Vp, Yp, Wp = { name: "css", register: fp, targetTest: function (e) { return e.style && e.nodeType }, init: function (e, t, n, i, r) { var s, o, a, l, c, A, u, h, d, p, f, g, m, v, y, w, x, C, b, M = this._props, I = e.style, E = n.vars.startAt; for (u in Fd || fp(), t) if ("autoRound" !== u && (o = t[u], !Ou[u] || !hd(u, t, n, i, e, r))) if (c = typeof o, A = Pp[u], "function" === c && (c = typeof (o = o.call(n, i, e, r))), "string" === c && ~o.indexOf("random(") && (o = Lh(o)), A) A(this, e, u, o, n) && (y = 1); else if ("--" === u.substr(0, 2)) s = (getComputedStyle(e).getPropertyValue(u) + "").trim(), o += "", Vh.lastIndex = 0, Vh.test(s) || (h = Ch(s), d = Ch(o)), d ? h !== d && (s = bp(e, u, s, d) + d) : h && (o += h), this.add(I, "setProperty", s, o, i, r, 0, 0, u), M.push(u); else if ("undefined" !== c) { if (E && u in E ? (s = "function" == typeof E[u] ? E[u].call(n, i, e, r) : E[u], u in _A.units && !Ch(s) && (s += _A.units[u]), "=" === (s + "").charAt(1) && (s = Mp(e, u))) : s = Mp(e, u), l = parseFloat(s), (p = "string" === c && "=" === o.charAt(1) ? +(o.charAt(0) + "1") : 0) && (o = o.substr(2)), a = parseFloat(o), u in Zd && ("autoAlpha" === u && (1 === l && "hidden" === Mp(e, "visibility") && a && (l = 0), xp(this, I, "visibility", l ? "inherit" : "hidden", a ? "inherit" : "hidden", !a)), "scale" !== u && "transform" !== u && ~(u = Zd[u]).indexOf(",") && (u = u.split(",")[0])), f = u in Ud) if (g || ((m = e._gsap).renderTransform && !t.parseTransform || Np(e, t.parseTransform), v = !1 !== t.smoothOrigin && m.smooth, (g = this._pt = new Dd(this._pt, I, cp, 0, 1, m.renderTransform, m, 0, -1)).dep = 1), "scale" === u) this._pt = new Dd(this._pt, m, "scaleY", m.scaleY, (p ? p * a : a - m.scaleY) || 0), M.push("scaleY", u), u += "X"; else { if ("transformOrigin" === u) { x = void 0, C = void 0, b = void 0, x = (w = o).split(" "), C = x[0], b = x[1] || "50%", "top" !== C && "bottom" !== C && "left" !== b && "right" !== b || (w = C, C = b, b = w), x[0] = Ep[C] || C, x[1] = Ep[b] || b, o = x.join(" "), m.svg ? Op(e, o, 0, v, 0, this) : ((d = parseFloat(o.split(" ")[2]) || 0) !== m.zOrigin && xp(this, m, "zOrigin", m.zOrigin, d), xp(this, I, u, kp(s), kp(o))); continue } if ("svgOrigin" === u) { Op(e, o, 1, v, 0, this); continue } if (u in Bp) { Gp(this, m, u, l, o, p); continue } if ("smoothOrigin" === u) { xp(this, m, "smooth", m.smooth, o); continue } if ("force3D" === u) { m[u] = o; continue } if ("transform" === u) { Up(this, o, e); continue } } else u in I || (u = pp(u) || u); if (f || (a || 0 === a) && (l || 0 === l) && !Kd.test(o) && u in I) a || (a = 0), (h = (s + "").substr((l + "").length)) !== (d = Ch(o) || (u in _A.units ? _A.units[u] : h)) && (l = bp(e, u, s, d)), this._pt = new Dd(this._pt, f ? m : I, u, l, p ? p * a : a - l, f || "px" !== d && "zIndex" !== u || !1 === t.autoRound ? qd : ep), this._pt.u = d || 0, h !== d && (this._pt.b = s, this._pt.r = $d); else if (u in I) Ip.call(this, e, u, s, o); else { if (!(u in e)) { Tu(u, o); continue } this.add(e, u, s || e[u], o, i, r) } M.push(u) } y && Bd(this) }, get: Mp, aliases: Zd, getSetter: function (e, t, n) { var i = Zd[t]; return i && i.indexOf(",") < 0 && (t = i), t in Ud && t !== Ap && (e._gsap.x || Mp(e, "x")) ? n && Gd === n ? "scale" === t ? op : sp : (Gd = n || {}) && ("scale" === t ? ap : lp) : e.style && !Au(e.style[t]) ? ip : ~t.indexOf("-") ? rp : Cd(e, t) }, core: { _removeProperty: wp, _getMatrix: Lp } }; Nd.utils.checkPrefix = pp, Yp = ju("x,y,z,scale,scaleX,scaleY,xPercent,yPercent," + (Vp = "rotation,rotationX,rotationY,skewX,skewY") + ",transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective", (function (e) { Ud[e] = 1 })), ju(Vp, (function (e) { _A.units[e] = "deg", Bp[e] = 1 })), Zd[Yp[13]] = "x,y,z,scale,scaleX,scaleY,xPercent,yPercent," + Vp, ju("0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY", (function (e) { var t = e.split(":"); Zd[t[1]] = Yp[t[0]] })), ju("x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective", (function (e) { _A.units[e] = "px" })), Nd.registerPlugin(Wp); var Xp = Nd.registerPlugin(Wp) || Nd; Xp.core.Tween; function Jp(e) { return (Jp = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) { return typeof e } : function (e) { return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e })(e) } function Kp(e, t, n, i, r, s, o) { try { var a = e[s](o), l = a.value } catch (e) { return void n(e) } a.done ? t(l) : Promise.resolve(l).then(i, r) } function Zp(e) { return function () { var t = this, n = arguments; return new Promise((function (i, r) { var s = e.apply(t, n); function o(e) { Kp(s, i, r, o, a, "next", e) } function a(e) { Kp(s, i, r, o, a, "throw", e) } o(void 0) })) } } function qp(e, t) { for (var n = 0; n < t.length; n++) { var i = t[n]; i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i) } } function _p(e, t) { return (_p = Object.setPrototypeOf || function (e, t) { return e.__proto__ = t, e })(e, t) } function $p(e) { var t = function () { if ("undefined" == typeof Reflect || !Reflect.construct) return !1; if (Reflect.construct.sham) return !1; if ("function" == typeof Proxy) return !0; try { return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function () { }))), !0 } catch (e) { return !1 } }(); return function () { var n, i = tf(e); if (t) { var r = tf(this).constructor; n = Reflect.construct(i, arguments, r) } else n = i.apply(this, arguments); return ef(this, n) } } function ef(e, t) { return !t || "object" !== Jp(t) && "function" != typeof t ? function (e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e }(e) : t } function tf(e) { return (tf = Object.setPrototypeOf ? Object.getPrototypeOf : function (e) { return e.__proto__ || Object.getPrototypeOf(e) })(e) } var nf = function (e) { !function (e, t) { if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function"); e.prototype = Object.create(t && t.prototype, { constructor: { value: e, writable: !0, configurable: !0 } }), t && _p(e, t) }(a, e); var t, n, i, r, s, o = $p(a); function a(e) { var t; return function (e, t) { if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function") }(this, a), (t = o.call(this))._score = document.querySelector(".js-score"), t._bestScore = document.querySelector(".js-best-score"), t._newBestScore = document.querySelector(".js-new-best-score"), t._newBestText = document.querySelector(".js-new-best-text"), t._scoreAdd = document.querySelector(".js-score-add"), t.wordings = { perfect: document.querySelector(".wording-perfect"), good: document.querySelector(".wording-good"), bad: document.querySelector(".wording-bad") }, t._scoreAdd.style.color = Mf.BALL_COLOR, Mf.SCORE = 0, Mf.EVENT_DISPATCHER.addEventListener("touchRestartScreen", (function () { t._restart(), t._setupRespawnPlatform(), t._setupRandomPlatforms(0), t._setScore(0), t._replaceBoostArrow(), Mf.CYLINDER_GROUP.rotation.y = 0 })), Mf.EVENT_DISPATCHER.addEventListener("touchRetryScreen", (function () { t._restart(), t._setupRespawnPlatform(), t._setupRandomPlatforms(t._cubeBox.userData.platformLevel), t._setScore(Mf.SCORE), t._replaceBoostArrow(), Mf.CYLINDER_GROUP.rotation.y = 0 })), t._setFirstScore(), t } return t = a, (n = [{ key: "_setFirstScore", value: (s = Zp(regeneratorRuntime.mark((function e() { var t; return regeneratorRuntime.wrap((function (e) { for (; ;)switch (e.prev = e.next) { case 0: return e.next = 2, Mf.H5SDK.getPlatform().getBestScore(); case 2: t = e.sent, this._bestScore.innerHTML = t || 0; case 4: case "end": return e.stop() } }), e, this) }))), function () { return s.apply(this, arguments) }) }, { key: "build", value: function () { var e = this; this._normalPlatform = Sf.models.PieMin2.scene.clone(), this._normalPlatformMaterial = new Co({ color: new nt(Mf.GAME_COLORS.normalPlatformColor) }), this._normalPlatform.traverse((function (t) { t.isMesh && (t.material = e._normalPlatformMaterial) })), this._bonusPlatformMaterial = new Co({ color: new nt(Mf.GAME_COLORS.ballColorNormal) }), this._loosePlatform = Sf.models.PieMin2.scene.clone(), this._loosePlatformMaterial = new Co({ side: 2, color: Mf.GAME_COLORS.loosePlatformColor }), this._loosePlatform.traverse((function (t) { t.isMesh && (t.material = e._loosePlatformMaterial) })), this._loosePlatform.scale.set(1.01, 1.01, 1.01), this._setupParameters(), this._setupRespawnPlatform(), this._setupRandomPlatforms(0), this._setupBoostArrow(); for (var t = 0; t < 3; t++)this._setupSplashTextures(t); this._setupCollisions() } }, { key: "update", value: function (e) { Mf.GAME.isLose || this._findCollision() } }, { key: "_setupCollisions", value: function () { this._cubeBox, this._boxVector, this._yPoint = 0, this._clearInd = 0 } }, { key: "_setupParameters", value: function () { this._rotationValue = .786, this._platformIndex = -1, this._splashTexturesIndex = 0, this._lastSplashTextureIndex = 0, this._colliderArr = [], this._platformArr = [], this._splashTexturesArr = [], this._platformPassedIndex = -1, this._platformBonusIndex = 0, this._scoreBoost = 0, this._detuneSoundValue = 0, this._platformBoostActive = !1, this._platformLevelIndex = 0, this._lastPlatform = null, this._lastPlatformPosition = 0, this._isInfiniteLevel = !1, this._platformsToReplace = [], this._platformsToReplacePos = [], this._platformsToReplaceRotation = [], this._splashTextureVisible = !1, this._velocityDebounceCollider = -.2, this._yBoxProgressVector = new O, this._boxVector = new O, this._arrowBoxVector = new O, this._boundingBoxMin = new O(-1, -1, -2), this._boundingBoxMax = new O(1, 1, 2), this._arrowBox = new H(this._boundingBoxMin, this._boundingBoxMax) } }, { key: "_setupRespawnPlatform", value: function () { var e = new ur, t = 1; e.name = "respawnPlat", this._colliderGroupRespawn = []; for (var n = 0; n < 28; n++) { t -= .75; var i = this._normalPlatform.clone(); i.position.set(0, 0, 0); var r = []; r.push(new ke), r[0].position.set(-2.15, .22, .2), r[0].rotation.x += Math.PI / 2, r[0].rotation.z -= .1, r[0].userData.platformType = 11; var s = new ur; s.add(i), s.add(r[0]), s.rotation.y = t / 4 + 2.5, s.position.y = -1, e.add(s), this._colliderGroupRespawn.push(r[0]) } this._colliderArr[0] = this._colliderGroupRespawn, Mf.CYLINDER_GROUP.add(e) } }, { key: "_setupRandomPlatforms", value: function (e) { var t = new ur; t.name = "platGroup", this._platformIndex = 0, this._platformIndexTest = -1; for (var n = e; n < xA.levelGenerator.length; n++) { this._platformIndexTest += 1; for (var i = 0; i < xA.levelGenerator[n].count; i++) { ++this._platformIndex, this._platGroupArr = [], this._colliderGroupArr = []; var r = "level_0".concat(xA.levelGenerator[n].level), s = CA[r][Math.floor(Math.random() * CA[r].length)], o = s.type; if (s.level === xA.levelGenerator[n].level) { for (var a = 0; a < s.count; a++) { var l = void 0; (l = xA.platformPieceType[o[a]].type === xA.loosePiece ? this._loosePlatform.clone() : this._normalPlatform.clone()).position.set(0, 0, 0); var c = []; c.push(new ke), c[0].position.set(-2.15, .22, .2), c[0].rotation.x += Math.PI / 2, c[0].rotation.z -= .1, c[0].userData.platformType = xA.platformPieceType[o[a]].type, c[0].userData.platformLevel = this._platformIndexTest; var A = new ur; A.add(l), A.add(c[0]), A.rotation.y -= s.randomRotation ? s.rotation[a] / 4 * this._rotationValue + s.randomRotation : s.rotation[a] / 4 * this._rotationValue, A.position.y -= this._platformIndex * xA.platformOffset, this._lastPlatformYPosition = A.position.y, t.add(A), A.userData.mat = l.getObjectByName("Pie").material, this._platGroupArr.push(A), this._colliderGroupArr.push(c[0]) } this._platformArr[this._platformIndex] = this._platGroupArr, this._colliderArr[this._platformIndex] = this._colliderGroupArr } } } Mf.CYLINDER_GROUP.add(t) } }, { key: "_setupSplashTextures", value: function (e) { var t = "splash_".concat(e), n = { uMap: { value: Sf.textures[t] }, uColor: { value: new nt(Mf.BALL_COLOR) }, uSize: { value: 0 }, uAlphaProgress: { value: 1 } }, i = new rn(1, 1), r = new jt({ uniforms: n, vertexShader: "#define GLSLIFY 1\nvarying vec2 vUv;\n\nvoid main() {\n    vUv = uv;\n    gl_Position = projectionMatrix* modelViewMatrix * vec4(position.xyz, 1.0);\n}", fragmentShader: "#define GLSLIFY 1\nuniform sampler2D uMap;\nuniform vec3 uColor;\nuniform float uSize;\nuniform float uAlphaProgress;\nvarying vec2 vUv;\nvoid main() {\n    vec4 splashTexture = texture2D(uMap, vUv);\n    gl_FragColor = vec4(uColor, splashTexture.a * uAlphaProgress );\n}", transparent: !0, depthWrite: !1 }), s = new kt(i, r); s.rotation.x -= Math.PI / 2, this._splashTexturesArr.push(s), Mf.CYLINDER_GROUP.add(s) } }, { key: "_setupBoostArrow", value: function () { this._boostArrow = Sf.models.BoostArrow.scene, this._boostArrow.position.z = -1.95, this._boostArrow.position.y = this._platformArr[this._platformPassedIndex + 10 + Math.floor(5 * Math.random())][0].position.y + .6, Xp.to(this._boostArrow.rotation, { y: 2 * Math.PI, repeat: -1, ease: "none", duration: 4 }), Mf.CYLINDER_GROUP.add(this._boostArrow) } }, { key: "_findCollision", value: function () { var e = this; if (!(this._colliderArr.length <= 0)) { if (this._platformPassedIndex > this._platformIndex - xA.levelGenerator[xA.levelGenerator.length - 1].count && (this._isInfiniteLevel = !0), this._clearInd < this._platformPassedIndex && (this._isInfiniteLevel ? this._replacePlatform(this._clearInd) : this._breakNormalPlatform(this._clearInd), this._clearInd = this._platformPassedIndex, this._detuneSoundValue += .4, this._score.innerHTML = Mf.SCORE, Mf.GAME.isFirstClick && Mf.SOUND_MANAGER.playSound({ name: "Platform", volume: .01, loop: !1, detuneValue: this._detuneSoundValue })), Mf.BALL.position.y < this._yBoxProgressVector.y && (this._platformPassedIndex += 1), Mf.BALL.position.y < this._arrowBoxVector.y - 1 && !this._platformBoostActive && !this._isInfiniteLevel && this._replaceBoostArrow(), this._colliderArr[this._platformPassedIndex]) { this._yBoxProgressVector.setFromMatrixPosition(this._colliderArr[this._platformPassedIndex][0].matrixWorld), this._velocityDebounceCollider = Mf.GRAVITY_WORLD.velocity >= 3 ? -1.8 : -.3, this._arrowBoxVector.setFromMatrixPosition(this._boostArrow.matrixWorld), this._arrowBoxVector.x < .3 && this._arrowBoxVector.x > -.3 && this._arrowBoxVector.y - Mf.BALL.position.y <= 2.4 && this._arrowBoxVector.y - Mf.BALL.position.y >= -2.4 && this._arrowBoxVector.z < -1.8 && this._arrowBoxVector.z > -2.4 && !this._platformBoostActive && (this._platformBoostActive = !0, Mf.GRAVITY_WORLD.velocity -= 1.4, Mf.EVENT_DISPATCHER.dispatchEvent({ type: "ballStatusChange", data: "superFire" }), this._replaceBoostArrow(), this._breakBoostPlatforms()); for (var t = 0; t < this._colliderArr[this._platformPassedIndex].length; t++)if (this._cubeBox = this._colliderArr[this._platformPassedIndex][t], this._boxVector.setFromMatrixPosition(this._cubeBox.matrixWorld), this._yPoint = this._boxVector.y - Mf.BALL.position.y, this._boxVector.x < .3 && this._boxVector.x > -.3 && this._yPoint <= .2 && this._yPoint >= this._velocityDebounceCollider && this._boxVector.z < -1.8 && this._boxVector.z > -2.4) { if (this._splashTextureVisible || (Mf.GAME.isFirstClick && Mf.SOUND_MANAGER.playSound({ name: "Splash", volume: .005, loop: !1, detuneValue: 0 }), Mf.H5SDK.performHapticFeedBack(100), this._splashTextureVisible = !0, this._updateSplashTexture()), this._platformBonusIndex >= xA.platformsSuperBoost) { this._clearInd = this._platformPassedIndex, this._platformPassedIndex += 1; for (var n = 0; n < this._platformArr[this._clearInd].length; n++)this._platformArr[this._clearInd][n].getObjectByName("Pie").material = this._bonusPlatformMaterial; Mf.EVENT_DISPATCHER.dispatchEvent({ type: "ballStatusChange", data: "normal" }), Mf.EVENT_DISPATCHER.dispatchEvent({ type: "ballStatusChange", data: "emitExplosion" }), setTimeout((function () { Mf.EVENT_DISPATCHER.dispatchEvent({ type: "emitExplosionParticles" }), e._breakFirePlatform(e._clearInd), e._deleteSplashTextureOnBoostHit() }), 1) } else Mf.EVENT_DISPATCHER.dispatchEvent({ type: "ballStatusChange", data: "normal" }); this._cubeBox.userData.platformType === xA.loosePiece && !Mf.GAME.isFirstLose && this._platformBonusIndex < xA.platformsSuperBoost ? (this.wordings.bad.classList.add("active"), setTimeout((function () { e.wordings.bad.classList.remove("active") }), 2e3), Mf.EVENT_DISPATCHER.dispatchEvent({ type: "gameFirstLoose", data: "" })) : this._cubeBox.userData.platformType === xA.loosePiece && !Mf.GAME.isLose && this._platformBonusIndex < xA.platformsSuperBoost && (Mf.EVENT_DISPATCHER.dispatchEvent({ type: "gameNormalLoose", data: "" }), Mf.EVENT_DISPATCHER.dispatchEvent({ type: "emitLooseParticles", data: "" }), this._setScore(Mf.SCORE)), this._platformBonusIndex = 0, setTimeout((function () { e._detuneSoundValue = 0, e._scoreBoost = 0 }), 200), Mf.GRAVITY_WORLD.collision = !0 } } return !1 } } }, { key: "_setScore", value: (r = Zp(regeneratorRuntime.mark((function e(t) { var n; return regeneratorRuntime.wrap((function (e) { for (; ;)switch (e.prev = e.next) { case 0: return console.log(t), Mf.SCORE = t, e.next = 4, Mf.H5SDK.getPlatform().getBestScore(); case 4: if (n = e.sent, this._newBestScore.innerHTML = t, this._newBestText.innerHTML = "YOUR SCORE", !(t >= n)) { e.next = 12; break } return e.next = 10, Mf.H5SDK.getPlatform().setBestScore(t); case 10: this._newBestScore.innerHTML = t, this._newBestText.innerHTML = "NEW BEST SCORE !"; case 12: this._bestScore.innerHTML = n, this._score.innerHTML = t; case 14: case "end": return e.stop() } }), e, this) }))), function (e) { return r.apply(this, arguments) }) }, { key: "_restart", value: function () { this._platformBonusIndex = 0, this._platformPassedIndex = -1, this._platformIndex = -1, this._isInfiniteLevel = !1, this._clearInd = 0, this._lastPlatform = null, this._yBoxProgressVector = new O, this._boxVector = new O, this._clearAllPlatforms() } }, { key: "_clearAllPlatforms", value: function () { var e = Mf.CYLINDER_GROUP.getObjectByName("platGroup"); Mf.CYLINDER_GROUP.remove(e), this._platformArr = [], this._colliderArr = [] } }, { key: "_replaceBoostArrow", value: function () { Xp.to(this._boostArrow.scale, { x: 0, y: 0, z: 0, duration: .2 }), Xp.set(this._boostArrow.scale, { x: 1, y: 1, z: 1, delay: 1 }), this._boostArrow.position.y = this._platformArr[this._platformPassedIndex + 8 + Math.floor(5 * Math.random())][0].position.y + .6 } }, { key: "_replacePlatform", value: function (e) { this._animateRemovePlatform(e) } }, { key: "_breakNormalPlatform", value: function (e) { this._platformBonusIndex += 1, this._platformArr[e] && !this._isInfiniteLevel && (this._animateRemovePlatform(e), this._platformArr[e] = void 0, this._colliderArr[e] = void 0) } }, { key: "_breakFirePlatform", value: function (e) { var t = this; this._platformArr[e] && !this._isInfiniteLevel && (this._animateRemovePlatform(e, !0), this._platformArr[e] = void 0, this._colliderArr[e] = void 0), setTimeout((function () { t._platformBonusIndex = 0 }), 100) } }, { key: "_breakBoostPlatforms", value: function () { var e = this, t = 0; setTimeout((function () { e._platformBoostActive = !1 }), 3e3); for (var n = function (n) { t += 1; for (var i = 0; i < e._platformArr[n].length; i++)e._platformArr[n][i].getObjectByName("Pie").material = e._loosePlatformMaterial; setTimeout((function () { e._platformArr[n] && (e._animateRemovePlatform(n, !0), e._platformArr[n] = void 0, e._colliderArr[n] = void 0) }), 50 * t) }, i = this._platformPassedIndex; i < this._platformPassedIndex + 5; i++)n(i) } }, { key: "_animateRemovePlatform", value: function (e, t) { var n = this; if (!Mf.GAME.isLose && this._platformArr[e]) { Mf.SCORE += 20, this._scoreBoost += 20, Mf.H5SDK.performHapticFeedBack(100), Mf.H5SDK.notifyUpdateScore(Mf.SCORE), this._scoreAdd.classList.add("active"), this.wordings.perfect.classList.add("active"), this._scoreAdd.innerHTML = "+".concat(this._scoreBoost), setTimeout((function () { n.wordings.perfect.classList.remove("active") }), 1e3), setTimeout((function () { n._scoreAdd.classList.remove("active") }), 100); var i = CA.level_00[Math.floor(Math.random() * CA.level_00.length)]; this._isInfiniteLevel && (this._lastPlatformYPosition -= xA.platformOffset); for (var r = 0; r < this._platformArr[e].length; r++)this._isInfiniteLevel && (this._platformsToReplace.push(this._platformArr[e][r]), this._platformsToReplacePos.push(this._lastPlatformYPosition), this._platformsToReplaceRotation.push(this._platformArr[e][r].rotation.y + i.randomRotation)), r % 2 ? (Xp.to(this._platformArr[e][r].getObjectByName("Pie").position, { x: -4, y: t ? 10 : 5, ease: "circ.out", duration: 4.8 }), Xp.set(this._platformArr[e][r].getObjectByName("Pie"), { visible: !1, delay: .5 })) : Xp.set(this._platformArr[e][r].getObjectByName("Pie"), { visible: !1 }); if (this._isInfiniteLevel) { for (var s = 0; s < this._platformsToReplace.length; s++) { var o = this._platformsToReplace[s], a = this._platformsToReplacePos[s], l = this._platformsToReplaceRotation[s]; Xp.set(o.getObjectByName("Pie"), { visible: !0, delay: 5.1 }), Xp.set(o.getObjectByName("Pie").position, { x: 0, y: .22, z: 0, delay: 5.1 }), Xp.set(o.getObjectByName("Pie").scale, { x: 1, y: 1, z: 1, delay: 5.1 }), Xp.set(o.getObjectByName("Pie"), { material: o.userData.mat, delay: 5.1 }), Xp.set(o.rotation, { y: l, delay: 5.1 }), Xp.set(o.position, { y: a, delay: 5.1, onComplete: function () { n._platformArr[e] && (n._platformsToReplace.splice(0, n._platformArr[e].length), n._platformsToReplacePos.splice(0, n._platformArr[e].length), n._platformsToReplaceRotation.splice(0, n._platformArr[e].length)) } }) } this._platformArr.push(this._platformArr[e]), this._colliderArr.push(this._colliderArr[e]) } this._platformBonusIndex >= xA.platformsNormalBoost && Mf.EVENT_DISPATCHER.dispatchEvent({ type: "ballStatusChange", data: "fire" }), this._platformBonusIndex >= xA.platformsSuperBoost && Mf.EVENT_DISPATCHER.dispatchEvent({ type: "ballStatusChange", data: "superFire" }) } } }, { key: "_updateSplashTexture", value: function () { var e = this; setTimeout((function () { e._splashTextureVisible = !1 }), 100), this._lastSplashTextureIndex = this._splashTexturesIndex, Xp.to(this._splashTexturesArr[this._lastSplashTextureIndex].material.uniforms.uAlphaProgress, { value: 0, delay: .4 }), this._splashTexturesIndex = oc.mod(this._splashTexturesIndex + 1, this._splashTexturesArr.length), Xp.set(this._splashTexturesArr[this._splashTexturesIndex].material.uniforms.uAlphaProgress, { value: 1 }), this._splashTexturesArr[this._splashTexturesIndex].material.uniforms.uColor.value = new nt(Mf.BALL_COLOR), this._splashTexturesArr[this._splashTexturesIndex].material.uniforms.uMap.value = Sf.textures["splash_".concat(this._splashTexturesIndex)], this._splashTexturesArr[this._splashTexturesIndex].position.x = 2 * Math.sin(Mf.CYLINDER_GROUP.rotation.y), this._splashTexturesArr[this._splashTexturesIndex].position.y = this._boxVector.y + .09, this._splashTexturesArr[this._splashTexturesIndex].rotation.z = 2 * Math.random(), this._splashTexturesArr[this._splashTexturesIndex].position.z = 2 * -Math.cos(Mf.CYLINDER_GROUP.rotation.y) } }, { key: "_deleteSplashTextureOnBoostHit", value: function () { Xp.set(this._splashTexturesArr[this._splashTexturesIndex].material.uniforms.uAlphaProgress, { value: 0 }) } }]) && qp(t.prototype, n), i && qp(t, i), a }(ke); function rf(e) { return (rf = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) { return typeof e } : function (e) { return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e })(e) } function sf(e, t) { for (var n = 0; n < t.length; n++) { var i = t[n]; i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i) } } function of(e, t) { return (of = Object.setPrototypeOf || function (e, t) { return e.__proto__ = t, e })(e, t) } function af(e) { var t = function () { if ("undefined" == typeof Reflect || !Reflect.construct) return !1; if (Reflect.construct.sham) return !1; if ("function" == typeof Proxy) return !0; try { return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function () { }))), !0 } catch (e) { return !1 } }(); return function () { var n, i = cf(e); if (t) { var r = cf(this).constructor; n = Reflect.construct(i, arguments, r) } else n = i.apply(this, arguments); return lf(this, n) } } function lf(e, t) { return !t || "object" !== rf(t) && "function" != typeof t ? function (e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e }(e) : t } function cf(e) { return (cf = Object.setPrototypeOf ? Object.getPrototypeOf : function (e) { return e.__proto__ || Object.getPrototypeOf(e) })(e) } var Af = function (e) { !function (e, t) { if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function"); e.prototype = Object.create(t && t.prototype, { constructor: { value: e, writable: !0, configurable: !0 } }), t && of(e, t) }(s, e); var t, n, i, r = af(s); function s(e) { var t; return function (e, t) { if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function") }(this, s), (t = r.call(this))._ballPos = 0, t._posUpdate = 0, t._ballGroup = new ur, t._ballSuperFire = !1, t } return t = s, (n = [{ key: "build", value: function () { this._setupBall(), this._setupBallTrail(), this._setupBoostSphere(), this._setupBoostTrail(), this._setupBallBounceParticleSystem(), this._setupBallTrailParticleSystem(), this._addToScene() } }, { key: "update", value: function (e) { this.particlesBounceSystem.update(e), this.particlesTrailSystem.update(e), Mf.GAME.isLose || (this._ball.position.y = Mf.GRAVITY_WORLD.yPos, Xp.to(this._ball.scale, { y: oc.clamp(-.8 * Mf.GRAVITY_WORLD.velocity + 1, .8, 1.4), z: oc.clamp(-.78 * Mf.GRAVITY_WORLD.velocity + 1, .8, 1.4), duration: .5 }), Xp.to(this._ball.scale, { x: oc.clamp(-.58 * Mf.GRAVITY_WORLD.velocity + 1, .8, 1.4), delay: .1, duration: .5 }), Xp.to(this._ball.rotation, { z: oc.clamp(-.58 * Mf.GRAVITY_WORLD.velocity + 1, .8, 1.5), delay: .1, duration: .2 }), Xp.to(this._trail.material.uniforms.uVelocity, { value: oc.clamp(Mf.GRAVITY_WORLD.velocity, -2, 2), duration: .1 }), this._ballGroup.position.y = Mf.BALL.position.y, Mf.GRAVITY_WORLD.velocity > Mf.GRAVITY_WORLD.jumpFactor + .07 && (Mf.CAMERA.position.y = this._ball.position.y + xA.cameraY, Mf.LIGHT.position.y = this._ball.position.y + 3), this._updateBoostTrail()) } }, { key: "_addToScene", value: function () { this.add(this._ball, this._ballGroup) } }, { key: "_setupBall", value: function () { var e = this; Mf.BALL_COLOR = Mf.GAME_COLORS.ballColorNormal; var t = new yo(.2, 32, 32), n = new Co({ side: 2, color: Mf.BALL_COLOR, roughness: .8 }); this._ball = new kt(t, n), this._ball.position.set(0, 5, -2.25), Mf.BALL = this._ball, Mf.GRAVITY_WORLD.yPos = this._ball.position.y, Mf.EVENT_DISPATCHER.addEventListener("ballStatusChange", (function (t) { e._updateBallStatus(t.data) })) } }, { key: "_setupBallTrail", value: function () { var e = { uVelocity: { value: 2 }, uColor: { value: new nt(Mf.BALL_COLOR) } }, t = new rn(.2, 1), n = new jt({ side: 2, vertexShader: "#define GLSLIFY 1\nvarying vec2 vUv;\nuniform float uVelocity;\nvoid main() {\n    vUv = uv;\n    vec3 transformed = position.xyz;\n    transformed.x *= 1.0 - uv.y + 0.1;\n    transformed.y *= uVelocity;\n    transformed.y += uVelocity / 2.;\n    gl_Position = projectionMatrix* modelViewMatrix * vec4(transformed.xyz, 1.0);\n}", fragmentShader: "#define GLSLIFY 1\nuniform vec3 uColor;\nuniform float uVelocity;\nvarying vec2 vUv;\nvoid main() {\n    gl_FragColor = vec4(uColor, 1.0 - vUv.y - 0.2 );\n}", uniforms: e, transparent: !0, depthWrite: !1 }); this._trail = new kt(t, n), this._trail.position.z = -2, this._ballGroup.add(this._trail) } }, { key: "_setupBoostSphere", value: function () { var e = new rn(1.2, 1.2), t = new it({ color: 16711680, side: 2, map: Sf.textures.BoostCircle, transparent: !0, opacity: .8 }); this._boostSphere = new kt(e, t), this._boostSphere.rotation.z += Math.PI / 2, this._boostSphere.position.z = -1.95, this._boostSphere.scale.set(0, 0, 0), this._ballGroup.add(this._boostSphere) } }, { key: "_setupBoostTrail", value: function () { var e = { uTime: { value: 0 }, uColor: { value: new nt(16711680) } }, t = new ws(1, 16, 0, 5), n = (new Ma).copy(t); this._instanceCount = 7; for (var i = [], r = 0; r < this._instanceCount; r++) { var s = .3 * r; i.push(s, 0, 1, 1) } this.buffer = new Float32Array(i), n.instanceCount = this._instanceCount, this._boostTrailMaterial = new jt({ fragmentShader: "#define GLSLIFY 1\nuniform sampler2D map;\nuniform float time;\nuniform vec3 uColor;\nvarying vec2 vUv;\nvarying float opacity;\n\nvoid main()\t{\n    vec2 pixelCord = vec2(vUv);\n\n    // vec4 color = texture2D(map, pixelCord);\n    gl_FragColor = vec4(uColor, opacity * 0.5); \n}", vertexShader: "#define GLSLIFY 1\nuniform float uTime;\nvarying vec2 vUv;\n\nattribute vec4 aProps;\n\nvarying float opacity;\n\nmat4 customRotation(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\nvoid main()\t{\n    float yPos = aProps.x;\n    float scale = aProps.z;\n    float yPosUpdate;\n    mat4 mvMatrix = modelViewMatrix;\n    mvMatrix *= customRotation(vec3(1.0, 0.0, 0.0), 1.57);\n\n    vUv = uv;\n    vec3 transformed = position.xyz;\n\n    yPosUpdate = uTime;\n\n    if(yPosUpdate + yPos > 2. ) {\n        yPosUpdate -= 2.;\n    }\n\n    transformed *= ((yPosUpdate+ 0.9) + yPos) * 0.22;\n    opacity = (yPos + yPosUpdate) * .3;\n    \n    gl_Position = projectionMatrix* mvMatrix * vec4(vec3(transformed.x , transformed.y, yPosUpdate + yPos), 1.);\n}", uniforms: e, transparent: !0, side: 2, depthWrite: !1 }), this._boostTrail = new kt(n, this._boostTrailMaterial), this._boostTrail.position.z = -2.5, this._boostTrail.position.y = .5, this._boostTrail.rotation.y -= 1, this._boostTrail.scale.set(0, 0, 0), n.setAttribute("aProps", new Ia(this.buffer, 4, !1).setUsage(35048)), this._ballGroup.add(this._boostTrail) } }, { key: "_setupBallBounceParticleSystem", value: function () { var e = this; this.particlesBounceStartTime = -2; var t = { position: new O(0, 2, 0), velocity: new O(0, 1, 0), acceleration: new O(0, -10, 0), color: new nt(Mf.BALL_COLOR), endColor: new nt(Mf.BALL_COLOR), colorRandomness: 0, lifetime: 1.5, fadeIn: .1, fadeOut: .1, size: .5, sizeRandomness: 1 }; this.particlesBounceSystem = new wA({ maxParticles: 200, particleSpriteTex: Sf.textures.ParticleCircle, onTick: function (n, i) { if (-1 === e.particlesBounceStartTime && (e.particlesBounceStartTime = i), i < e.particlesBounceStartTime + .07) for (var r = 0; r < 10; r++)t.position.set(oc.rand(-.2, .2), Mf.BALL.position.y, oc.rand(-2, -1.9)), t.velocity.set(oc.rand(-2, 2), 3.3, oc.rand(-2, 2)), n.spawnParticle(t) } }), Mf.SCENE.add(this.particlesBounceSystem) } }, { key: "_setupBallTrailParticleSystem", value: function () { var e = this; this.particlesTrailStartTime = -2; var t = { position: new O(0, 2, 0), velocity: new O(0, 1, 0), acceleration: new O(0, 0, 0), color: new nt(Mf.BALL_COLOR), endColor: new nt(Mf.BALL_COLOR), colorRandomness: 0, lifetime: 1, fadeIn: .1, fadeOut: .1, size: 1, sizeRandomness: 1 }; this.particlesTrailSystem = new wA({ maxParticles: 200, particleSpriteTex: Sf.textures.ParticleCircle, onTick: function (n, i) { -1 === e.particlesTrailStartTime && (e.particlesTrailStartTime = i), i < e.particlesTrailStartTime + .07 && (t.color.set(new nt(Mf.BALL_COLOR)), t.position.set(oc.rand(-.2, .2), Mf.BALL.position.y - .7, oc.rand(-2, -1.9)), t.velocity.set(oc.rand(-.5, .5), 0, oc.rand(-2, 2)), n.spawnParticle(t)) } }), Mf.SCENE.add(this.particlesTrailSystem) } }, { key: "_updateBallStatus", value: function (e) { var t; switch (this._ballPos = Mf.BALL.position.y, e) { case "normal": this.particlesBounceStartTime = -1, Mf.BALL_COLOR = Mf.GAME_COLORS.ballColorNormal, t = new nt(Mf.BALL_COLOR), this._ball.material.color.set(t), this._trail.material.uniforms.uColor.value.set(t), Xp.to(this._boostSphere.scale, { x: 0, y: 0, z: 0, repeat: 0, duration: .2 }), this._ballSuperFire = !1, Xp.to(this._boostTrail.scale, { x: 0, y: 0, z: 0, duration: 0 }), Mf.GRAVITY_WORLD.boostSpeed = 0; break; case "fire": Mf.BALL_COLOR = Mf.GAME_COLORS.ballColorNormal, t = new nt(Mf.BALL_COLOR), this._ball.material.color.set(t), this._trail.material.uniforms.uColor.value.set(t), this.particlesTrailStartTime = -1, this._boostTrail.material.uniforms.uColor.value = t, Xp.to(this._boostTrail.scale, { x: 1, y: 1, z: 1, duration: .05 }), this._ballSuperFire = !0; break; case "superFire": Mf.BALL_COLOR = Mf.GAME_COLORS.ballColorFire, t = new nt(Mf.BALL_COLOR), this._ball.material.color.set(t), this._trail.material.uniforms.uColor.value.set(t), 0 === Mf.GRAVITY_WORLD.boostSpeed && (Mf.GRAVITY_WORLD.boostSpeed = xA.ballAccelerationOnBoost), this.particlesTrailStartTime = -1, this._boostTrail.material.uniforms.uColor.value = t, Xp.fromTo(this._boostSphere.scale, { x: 1, y: 1, z: 1, duration: .05 }, { x: .9, y: .9, z: .9, yoyo: !0, duration: .05 }), Xp.to(this._boostTrail.scale, { x: 1, y: 1, z: 1, duration: .05 }) } } }, { key: "_updateBoostTrail", value: function () { this._boostTrail.material.uniforms.uTime.value += .008 * Mf.GRAVITY_WORLD.velocity, this._boostTrail.material.uniforms.uTime.value > 2 && (this._boostTrail.material.uniforms.uTime.value = 0) } }]) && sf(t.prototype, n), i && sf(t, i), s }(ke); function uf(e, t) { for (var n = 0; n < t.length; n++) { var i = t[n]; i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i) } } var hf = function () { function e() { var t = this; !function (e, t) { if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function") }(this, e), this.animationsEntities = {}, this.particleSystem = [], this._cylinderGroup = new ur, Mf.SCENE.add(this._cylinderGroup), Mf.CYLINDER_GROUP = this._cylinderGroup, this._createEntities(), this._createModels(), Mf.CAMERA.lookAt(0, xA.lookAtY, 0), Mf.EVENT_DISPATCHER.addEventListener("touchMove", (function (e) { return t._moveCylinder(e) })) } var t, n, i; return t = e, (n = [{ key: "startGame", value: function () { } }, { key: "pauseGame", value: function () { } }, { key: "createLevel", value: function () { } }, { key: "resize", value: function () { } }, { key: "tick", value: function () { if (!Mf.GAME.isPaused) { for (var e in this.elapsedTime = Mf.CLOCK.getElapsedTime(), this.sceneEntities) this.sceneEntities[e].update(Mf.DELTA_TIME, Mf.GAME.isReady); Mf.RENDERER.render(Mf.SCENE, Mf.CAMERA) } } }, { key: "_createModels", value: function () { for (var e in this.sceneEntities) this.sceneEntities[e].build(this._models), Mf.SCENE.add(this.sceneEntities[e]) } }, { key: "_createEntities", value: function () { this.sceneEntities = { lights: new SA, tube: new kA, ball: new Af, platforms: new nf } } }, { key: "_setupParticleSystem", value: function () { var e = this; this.particlesStartTime = -2, this.options = { position: new O(0, 2, 0), velocity: new O(0, -10, 0), acceleration: new O(0, 0, 0), color: new nt(1, 1, 1), endColor: new nt(.5, .5, .5), colorRandomness: 0, lifetime: 200, fadeIn: .01, fadeOut: .3, size: 1.8, sizeRandomness: 5 }, this.particlesSystem = new wA({ maxParticles: 2e3, particleSpriteTex: Sf.textures.points, onTick: function (t, n) { if (-1 === e.particlesStartTime && (e.particlesStartTime = n), n < e.particlesStartTime + .07) for (var i = 0; i < 100; i++)e.options.position.set(oc.rand(-20, 20), oc.rand(-20, 20), oc.rand(-20, 20)), t.spawnParticle(e.options) } }), setInterval((function () { e.particlesStartTime = -1 }), 1e3), Mf.SCENE.add(this.particlesSystem) } }, { key: "_emitWinParticles", value: function () { this._pointsToWin += 1, this._scoreText.innerHTML = this._pointsToWin, this.particlesStartTimeWin = -1, this.particlesWinBreak = !1 } }, { key: "_moveCylinder", value: function (e) { Mf.GAME.isLose || Mf.GAME.isPaused || (this._cylinderGroup.rotation.y += e.data.swipeSpeed * Mf.CONTROLS_OPTIONS.rotateSpeed) } }, { key: "_setupGUIParameters", value: function () { } }, { key: "_resetGame", value: function () { this.particlesStartTimeWin = 1, Mf.reset() } }]) && uf(t.prototype, n), i && uf(t, i), e }(); const df = { type: "change" }, pf = { type: "start" }, ff = { type: "end" }; class gf extends A { constructor(e, t) { super(), void 0 === t && console.warn('THREE.OrbitControls: The second parameter "domElement" is now mandatory.'), t === document && console.error('THREE.OrbitControls: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.'), this.object = e, this.domElement = t, this.domElement.style.touchAction = "none", this.enabled = !0, this.target = new O, this.minDistance = 0, this.maxDistance = 1 / 0, this.minZoom = 0, this.maxZoom = 1 / 0, this.minPolarAngle = 0, this.maxPolarAngle = Math.PI, this.minAzimuthAngle = -1 / 0, this.maxAzimuthAngle = 1 / 0, this.enableDamping = !1, this.dampingFactor = .05, this.enableZoom = !0, this.zoomSpeed = 1, this.enableRotate = !0, this.rotateSpeed = 1, this.enablePan = !0, this.panSpeed = 1, this.screenSpacePanning = !0, this.keyPanSpeed = 7, this.autoRotate = !1, this.autoRotateSpeed = 2, this.keys = { LEFT: "ArrowLeft", UP: "ArrowUp", RIGHT: "ArrowRight", BOTTOM: "ArrowDown" }, this.mouseButtons = { LEFT: i, MIDDLE: r, RIGHT: s }, this.touches = { ONE: o, TWO: l }, this.target0 = this.target.clone(), this.position0 = this.object.position.clone(), this.zoom0 = this.object.zoom, this._domElementKeyEvents = null, this.getPolarAngle = function () { return d.phi }, this.getAzimuthalAngle = function () { return d.theta }, this.listenToKeyEvents = function (e) { e.addEventListener("keydown", $), this._domElementKeyEvents = e }, this.saveState = function () { n.target0.copy(n.target), n.position0.copy(n.object.position), n.zoom0 = n.object.zoom }, this.reset = function () { n.target.copy(n.target0), n.object.position.copy(n.position0), n.object.zoom = n.zoom0, n.object.updateProjectionMatrix(), n.dispatchEvent(df), n.update(), u = A.NONE }, this.update = function () { const t = new O, i = (new L).setFromUnitVectors(e.up, new O(0, 1, 0)), r = i.clone().invert(), s = new O, o = new L, a = 2 * Math.PI; return function () { const e = n.object.position; t.copy(e).sub(n.target), t.applyQuaternion(i), d.setFromVector3(t), n.autoRotate && u === A.NONE && D(2 * Math.PI / 60 / 60 * n.autoRotateSpeed), n.enableDamping ? (d.theta += p.theta * n.dampingFactor, d.phi += p.phi * n.dampingFactor) : (d.theta += p.theta, d.phi += p.phi); let l = n.minAzimuthAngle, c = n.maxAzimuthAngle; return isFinite(l) && isFinite(c) && (l < -Math.PI ? l += a : l > Math.PI && (l -= a), c < -Math.PI ? c += a : c > Math.PI && (c -= a), d.theta = l <= c ? Math.max(l, Math.min(c, d.theta)) : d.theta > (l + c) / 2 ? Math.max(l, d.theta) : Math.min(c, d.theta)), d.phi = Math.max(n.minPolarAngle, Math.min(n.maxPolarAngle, d.phi)), d.makeSafe(), d.radius *= f, d.radius = Math.max(n.minDistance, Math.min(n.maxDistance, d.radius)), !0 === n.enableDamping ? n.target.addScaledVector(g, n.dampingFactor) : n.target.add(g), t.setFromSpherical(d), t.applyQuaternion(r), e.copy(n.target).add(t), n.object.lookAt(n.target), !0 === n.enableDamping ? (p.theta *= 1 - n.dampingFactor, p.phi *= 1 - n.dampingFactor, g.multiplyScalar(1 - n.dampingFactor)) : (p.set(0, 0, 0), g.set(0, 0, 0)), f = 1, !!(m || s.distanceToSquared(n.object.position) > h || 8 * (1 - o.dot(n.object.quaternion)) > h) && (n.dispatchEvent(df), s.copy(n.object.position), o.copy(n.object.quaternion), m = !1, !0) } }(), this.dispose = function () { n.domElement.removeEventListener("contextmenu", ee), n.domElement.removeEventListener("pointerdown", J), n.domElement.removeEventListener("pointercancel", q), n.domElement.removeEventListener("wheel", _), n.domElement.ownerDocument.removeEventListener("pointermove", K), n.domElement.ownerDocument.removeEventListener("pointerup", Z), null !== n._domElementKeyEvents && n._domElementKeyEvents.removeEventListener("keydown", $) }; const n = this, A = { NONE: -1, ROTATE: 0, DOLLY: 1, PAN: 2, TOUCH_ROTATE: 3, TOUCH_PAN: 4, TOUCH_DOLLY_PAN: 5, TOUCH_DOLLY_ROTATE: 6 }; let u = A.NONE; const h = 1e-6, d = new Ka, p = new Ka; let f = 1; const g = new O; let m = !1; const v = new b, y = new b, w = new b, x = new b, C = new b, M = new b, I = new b, E = new b, T = new b, P = [], S = {}; function B() { return Math.pow(.95, n.zoomSpeed) } function D(e) { p.theta -= e } function R(e) { p.phi -= e } const N = function () { const e = new O; return function (t, n) { e.setFromMatrixColumn(n, 0), e.multiplyScalar(-t), g.add(e) } }(), k = function () { const e = new O; return function (t, i) { !0 === n.screenSpacePanning ? e.setFromMatrixColumn(i, 1) : (e.setFromMatrixColumn(i, 0), e.crossVectors(n.object.up, e)), e.multiplyScalar(t), g.add(e) } }(), H = function () { const e = new O; return function (t, i) { const r = n.domElement; if (n.object.isPerspectiveCamera) { const s = n.object.position; e.copy(s).sub(n.target); let o = e.length(); o *= Math.tan(n.object.fov / 2 * Math.PI / 180), N(2 * t * o / r.clientHeight, n.object.matrix), k(2 * i * o / r.clientHeight, n.object.matrix) } else n.object.isOrthographicCamera ? (N(t * (n.object.right - n.object.left) / n.object.zoom / r.clientWidth, n.object.matrix), k(i * (n.object.top - n.object.bottom) / n.object.zoom / r.clientHeight, n.object.matrix)) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."), n.enablePan = !1) } }(); function z(e) { n.object.isPerspectiveCamera ? f /= e : n.object.isOrthographicCamera ? (n.object.zoom = Math.max(n.minZoom, Math.min(n.maxZoom, n.object.zoom * e)), n.object.updateProjectionMatrix(), m = !0) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), n.enableZoom = !1) } function F(e) { n.object.isPerspectiveCamera ? f *= e : n.object.isOrthographicCamera ? (n.object.zoom = Math.max(n.minZoom, Math.min(n.maxZoom, n.object.zoom / e)), n.object.updateProjectionMatrix(), m = !0) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), n.enableZoom = !1) } function Q(e) { v.set(e.clientX, e.clientY) } function G(e) { x.set(e.clientX, e.clientY) } function j() { if (1 === P.length) v.set(P[0].pageX, P[0].pageY); else { const e = .5 * (P[0].pageX + P[1].pageX), t = .5 * (P[0].pageY + P[1].pageY); v.set(e, t) } } function U() { if (1 === P.length) x.set(P[0].pageX, P[0].pageY); else { const e = .5 * (P[0].pageX + P[1].pageX), t = .5 * (P[0].pageY + P[1].pageY); x.set(e, t) } } function V() { const e = P[0].pageX - P[1].pageX, t = P[0].pageY - P[1].pageY, n = Math.sqrt(e * e + t * t); I.set(0, n) } function Y(e) { if (1 == P.length) y.set(e.pageX, e.pageY); else { const t = ie(e), n = .5 * (e.pageX + t.x), i = .5 * (e.pageY + t.y); y.set(n, i) } w.subVectors(y, v).multiplyScalar(n.rotateSpeed); const t = n.domElement; D(2 * Math.PI * w.x / t.clientHeight), R(2 * Math.PI * w.y / t.clientHeight), v.copy(y) } function W(e) { if (1 === P.length) C.set(e.pageX, e.pageY); else { const t = ie(e), n = .5 * (e.pageX + t.x), i = .5 * (e.pageY + t.y); C.set(n, i) } M.subVectors(C, x).multiplyScalar(n.panSpeed), H(M.x, M.y), x.copy(C) } function X(e) { const t = ie(e), i = e.pageX - t.x, r = e.pageY - t.y, s = Math.sqrt(i * i + r * r); E.set(0, s), T.set(0, Math.pow(E.y / I.y, n.zoomSpeed)), z(T.y), I.copy(E) } function J(e) { !1 !== n.enabled && (0 === P.length && (n.domElement.ownerDocument.addEventListener("pointermove", K), n.domElement.ownerDocument.addEventListener("pointerup", Z)), function (e) { P.push(e) }(e), "touch" === e.pointerType ? function (e) { switch (ne(e), P.length) { case 1: switch (n.touches.ONE) { case o: if (!1 === n.enableRotate) return; j(), u = A.TOUCH_ROTATE; break; case a: if (!1 === n.enablePan) return; U(), u = A.TOUCH_PAN; break; default: u = A.NONE }break; case 2: switch (n.touches.TWO) { case l: if (!1 === n.enableZoom && !1 === n.enablePan) return; n.enableZoom && V(), n.enablePan && U(), u = A.TOUCH_DOLLY_PAN; break; case c: if (!1 === n.enableZoom && !1 === n.enableRotate) return; n.enableZoom && V(), n.enableRotate && j(), u = A.TOUCH_DOLLY_ROTATE; break; default: u = A.NONE }break; default: u = A.NONE }u !== A.NONE && n.dispatchEvent(pf) }(e) : function (e) { let t; switch (e.button) { case 0: t = n.mouseButtons.LEFT; break; case 1: t = n.mouseButtons.MIDDLE; break; case 2: t = n.mouseButtons.RIGHT; break; default: t = -1 }switch (t) { case r: if (!1 === n.enableZoom) return; !function (e) { I.set(e.clientX, e.clientY) }(e), u = A.DOLLY; break; case i: if (e.ctrlKey || e.metaKey || e.shiftKey) { if (!1 === n.enablePan) return; G(e), u = A.PAN } else { if (!1 === n.enableRotate) return; Q(e), u = A.ROTATE } break; case s: if (e.ctrlKey || e.metaKey || e.shiftKey) { if (!1 === n.enableRotate) return; Q(e), u = A.ROTATE } else { if (!1 === n.enablePan) return; G(e), u = A.PAN } break; default: u = A.NONE }u !== A.NONE && n.dispatchEvent(pf) }(e)) } function K(e) { !1 !== n.enabled && ("touch" === e.pointerType ? function (e) { switch (ne(e), u) { case A.TOUCH_ROTATE: if (!1 === n.enableRotate) return; Y(e), n.update(); break; case A.TOUCH_PAN: if (!1 === n.enablePan) return; W(e), n.update(); break; case A.TOUCH_DOLLY_PAN: if (!1 === n.enableZoom && !1 === n.enablePan) return; !function (e) { n.enableZoom && X(e), n.enablePan && W(e) }(e), n.update(); break; case A.TOUCH_DOLLY_ROTATE: if (!1 === n.enableZoom && !1 === n.enableRotate) return; !function (e) { n.enableZoom && X(e), n.enableRotate && Y(e) }(e), n.update(); break; default: u = A.NONE } }(e) : function (e) { if (!1 === n.enabled) return; switch (u) { case A.ROTATE: if (!1 === n.enableRotate) return; !function (e) { y.set(e.clientX, e.clientY), w.subVectors(y, v).multiplyScalar(n.rotateSpeed); const t = n.domElement; D(2 * Math.PI * w.x / t.clientHeight), R(2 * Math.PI * w.y / t.clientHeight), v.copy(y), n.update() }(e); break; case A.DOLLY: if (!1 === n.enableZoom) return; !function (e) { E.set(e.clientX, e.clientY), T.subVectors(E, I), T.y > 0 ? z(B()) : T.y < 0 && F(B()), I.copy(E), n.update() }(e); break; case A.PAN: if (!1 === n.enablePan) return; !function (e) { C.set(e.clientX, e.clientY), M.subVectors(C, x).multiplyScalar(n.panSpeed), H(M.x, M.y), x.copy(C), n.update() }(e) } }(e)) } function Z(e) { !1 !== n.enabled && (e.pointerType, n.dispatchEvent(ff), u = A.NONE, te(e), 0 === P.length && (n.domElement.ownerDocument.removeEventListener("pointermove", K), n.domElement.ownerDocument.removeEventListener("pointerup", Z))) } function q(e) { te(e) } function _(e) { !1 === n.enabled || !1 === n.enableZoom || u !== A.NONE && u !== A.ROTATE || (e.preventDefault(), n.dispatchEvent(pf), function (e) { e.deltaY < 0 ? F(B()) : e.deltaY > 0 && z(B()), n.update() }(e), n.dispatchEvent(ff)) } function $(e) { !1 !== n.enabled && !1 !== n.enablePan && function (e) { let t = !1; switch (e.code) { case n.keys.UP: H(0, n.keyPanSpeed), t = !0; break; case n.keys.BOTTOM: H(0, -n.keyPanSpeed), t = !0; break; case n.keys.LEFT: H(n.keyPanSpeed, 0), t = !0; break; case n.keys.RIGHT: H(-n.keyPanSpeed, 0), t = !0 }t && (e.preventDefault(), n.update()) }(e) } function ee(e) { !1 !== n.enabled && e.preventDefault() } function te(e) { delete S[e.pointerId]; for (let t = 0; t < P.length; t++)if (P[t].pointerId == e.pointerId) return void P.splice(t, 1) } function ne(e) { let t = S[e.pointerId]; void 0 === t && (t = new b, S[e.pointerId] = t), t.set(e.pageX, e.pageY) } function ie(e) { const t = e.pointerId === P[0].pointerId ? P[1] : P[0]; return S[t.pointerId] } n.domElement.addEventListener("contextmenu", ee), n.domElement.addEventListener("pointerdown", J), n.domElement.addEventListener("pointercancel", q), n.domElement.addEventListener("wheel", _, { passive: !1 }), this.update() } } var mf = function () { var e = 0, t = document.createElement("div"); function n(e) { return t.appendChild(e.dom), e } function i(n) { for (var i = 0; i < t.children.length; i++)t.children[i].style.display = i === n ? "block" : "none"; e = n } t.style.cssText = "position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000", t.addEventListener("click", (function (n) { n.preventDefault(), i(++e % t.children.length) }), !1); var r = (performance || Date).now(), s = r, o = 0, a = n(new mf.Panel("FPS", "#0ff", "#002")), l = n(new mf.Panel("MS", "#0f0", "#020")); if (self.performance && self.performance.memory) var c = n(new mf.Panel("MB", "#f08", "#201")); return i(0), { REVISION: 16, dom: t, addPanel: n, showPanel: i, begin: function () { r = (performance || Date).now() }, end: function () { o++; var e = (performance || Date).now(); if (l.update(e - r, 200), e >= s + 1e3 && (a.update(1e3 * o / (e - s), 100), s = e, o = 0, c)) { var t = performance.memory; c.update(t.usedJSHeapSize / 1048576, t.jsHeapSizeLimit / 1048576) } return e }, update: function () { r = this.end() }, domElement: t, setMode: i } }; mf.Panel = function (e, t, n) { var i = 1 / 0, r = 0, s = Math.round, o = s(window.devicePixelRatio || 1), a = 80 * o, l = 48 * o, c = 3 * o, A = 2 * o, u = 3 * o, h = 15 * o, d = 74 * o, p = 30 * o, f = document.createElement("canvas"); f.width = a, f.height = l, f.style.cssText = "width:80px;height:48px"; var g = f.getContext("2d"); return g.font = "bold " + 9 * o + "px Helvetica,Arial,sans-serif", g.textBaseline = "top", g.fillStyle = n, g.fillRect(0, 0, a, l), g.fillStyle = t, g.fillText(e, c, A), g.fillRect(u, h, d, p), g.fillStyle = n, g.globalAlpha = .9, g.fillRect(u, h, d, p), { dom: f, update: function (l, m) { i = Math.min(i, l), r = Math.max(r, l), g.fillStyle = n, g.globalAlpha = 1, g.fillRect(0, 0, a, h), g.fillStyle = t, g.fillText(s(l) + " " + e + " (" + s(i) + "-" + s(r) + ")", c, A), g.drawImage(f, u + o, h, d - o, p, u, h, d - o, p), g.fillRect(u + d - o, h, o, p), g.fillStyle = n, g.globalAlpha = .9, g.fillRect(u + d - o, h, o, s((1 - l / m) * p)) } } }; var vf = mf, yf = n(0); function wf(e, t) { for (var n = 0; n < t.length; n++) { var i = t[n]; i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i) } } var xf = function () { function e() { var t = this; !function (e, t) { if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function") }(this, e), this._audioSources = [], this._soundIcon = document.querySelector(".js-sound"), this._soundIconStatus = document.querySelector(".speaker-status"), this._soundIcon.addEventListener("click", (function () { return t._toggleSound() })), this._soundPlaying = !0, window.H5SDK.getPlatform().isGameSnacks() && GAMESNACKS.subscribeToAudioUpdates((function () { t._setAudioEnabled() })) } var t, n, i; return t = e, (n = [{ key: "playSound", value: function (e) { this._soundPlaying && (Sf.sounds[e.name].rate(e.detuneValue + 1), Sf.sounds[e.name].play()) } }, { key: "pauseAllSounds", value: function () { for (var e = 0; e < this._audioSources.length; e++)this._audioSources[e] && this._audioSources[e].stop() } }, { key: "resetSound", value: function () { } }, { key: "_setAudioEnabled", value: function () { window.H5SDK.getPlatform().isGameSnacks() && (this._soundPlaying = GAMESNACKS.isAudioEnabled(), this._soundPlaying ? this._soundIconStatus.classList.add("hidden") : this._soundIconStatus.classList.remove("hidden")) } }, { key: "_toggleSound", value: function () { this._soundIconStatus.classList.toggle("hidden"), this._soundPlaying ? this._soundPlaying = !1 : this._soundPlaying = !0 } }]) && wf(t.prototype, n), i && wf(t, i), e }(); function Cf(e, t, n, i, r, s, o) { try { var a = e[s](o), l = a.value } catch (e) { return void n(e) } a.done ? t(l) : Promise.resolve(l).then(i, r) } function bf(e, t) { for (var n = 0; n < t.length; n++) { var i = t[n]; i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i) } } var Mf = new (function () { function e() { !function (e, t) { if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function") }(this, e), this._H5SDK = window.H5SDK, this._rewardHandler = this._rewardHandler.bind(this), this._noAdHandler = this._noAdHandler.bind(this), this._canvas = document.querySelector(".canvas"); var t = document.querySelector(".background-gradient"); this._startScreen = document.querySelector(".start-screen"), this._retryScreen = document.querySelector(".retry-screen"), this._endScreen = document.querySelector(".end-screen"), this._playText = document.querySelector(".play-text"), this._noVideoCTA = document.querySelector(".js-no-video"), this._retryVideo = document.querySelector(".video-replay"), this._circleSvg = document.querySelector(".js-circle-svg"), this._soundIcon = document.querySelector(".js-sound"), this._privacyIcon = document.querySelector(".js-privacy"), this._playIcon = document.querySelector(".js-play-icon"), this._pauseIcon = document.querySelector(".js-pause-icon"), this._pauseCTA = document.querySelector(".js-pause"), this._paramsCTA = document.querySelector(".js-params"), this._scoreContainer = document.querySelector(".score-container"), this._bestScoreGame = document.querySelector(".best-score"), this._bestScoreEndScreen = document.querySelector(".new-best-score"), Xp.ticker.fps(60), this._eventDispatcher = new A, this._gameStatus = { isReady: !1, isStarted: !1, isPaused: !1, isWin: !1, isLose: !1, isReset: !1, isFirstLose: !1, isFirstClick: !1, isRetryClick: !1, isDebug: !1, levelNumber: 0, FPS: 60 }, this._platforms = [], this._colliders = [], this._delta = 0, this._clock = new La, this._gameColors = xA.gameColors[Math.floor(Math.random() * xA.gameColors.length)], t.style.background = this._gameColors.backgroundGradient, this._touchValues = { mousePosition: { x: 0, y: 0 }, oldPos: { x: 0, z: 0 }, isPlayerTouch: !1, lastTouch: { x: 0, y: 0 }, swipeSpeed: 0 } } var t, n, i, r, s; return t = e, (n = [{ key: "SDK", get: function () { return this._H5SDK } }, { key: "RENDERER", get: function () { return this._renderer } }, { key: "SCENE", get: function () { return this._scene } }, { key: "CAMERA", get: function () { return this._camera } }, { key: "ICPARAMS", get: function () { return window.creative } }, { key: "GAME", get: function () { return this._gameStatus } }, { key: "DELTA_TIME", get: function () { return this.delta } }, { key: "CLOCK", get: function () { return this._clock } }, { key: "GRAVITY_WORLD", get: function () { return this._world } }, { key: "SOUND_MANAGER", get: function () { return this._soundManager } }, { key: "BALL", get: function () { return this._ball }, set: function (e) { this._ball = e } }, { key: "COLLIDERS", get: function () { return this._colliders } }, { key: "CYLINDER_GROUP", get: function () { return this._cylinder }, set: function (e) { this._cylinder = e } }, { key: "CONTROLS_OPTIONS", get: function () { return this._controlsOptions } }, { key: "SCORE", get: function () { return this._score }, set: function (e) { this._score = e } }, { key: "PLATFORMS", get: function () { return this._platforms } }, { key: "EVENT_DISPATCHER", get: function () { return this._eventDispatcher } }, { key: "BALL_COLOR", get: function () { return this._ballColor }, set: function (e) { this._ballColor = e } }, { key: "GAME_COLORS", get: function () { return this._gameColors } }, { key: "STORAGE", get: function () { return window.localStorage }, set: function (e) { window.localStorage = e } }, { key: "H5SDK", get: function () { return this._H5SDK } }, { key: "setup", value: function () { this._renderer = this._setupRenderer(), this._scene = this._setupScene(), this._camera = this._setupCamera(), this._soundManager = this._setupSoundManager(), this._controlsOptions = this._setupControlsOptions(), this._addFacebookButtons(), this._world = this._setupGravity(), this._gameStatus.isDebug && this._setupStats(), this.resize(), this._stage = this._setupStage(), this._setupEventListeners(), this.GAME.isReady = !0 } }, { key: "createLevel", value: function () { this.GAME.levelNumber += 1 } }, { key: "start", value: function () { this.H5SDK.notifyLevelStart(0), this.GAME.isStarted = !0, this.stage.startGame() } }, { key: "pause", value: function (e) { this.GAME.isPaused = e, this._soundManager.pauseAllSounds() } }, { key: "resize", value: function () { this._width = window.innerWidth, this._height = window.innerHeight, this._canvas.width = this._width, this._canvas.height = this._height, this.stage && this.stage.resize(this._width, this._height), this._camera.aspect = this._width / this._height, this._camera.updateProjectionMatrix(), this._renderer.setSize(this._width, this._height) } }, { key: "reset", value: function () { this.GAME = { isReady: !1, isStarted: !1, isPaused: !1, isWin: !1, isLose: !1, isReset: !1, isDebug: !0, FPS: 60 } } }, { key: "resetFirstGravity", value: function () { this._world = { yPos: 0, deltaTime: .1, velocity: 1.07, maxVelocity: 2, gravity: .07, collision: !1, boostSpeed: 0, jumpFactor: 1.3 } } }, { key: "resetNormalGravity", value: function () { this._world = { yPos: 6, deltaTime: .1, velocity: 1.07, maxVelocity: 2, gravity: .07, collision: !1, boostSpeed: 0, jumpFactor: 1.3 } } }, { key: "_setupGravity", value: function () { return { yPos: 6, deltaTime: .1, velocity: 1.07, maxVelocity: 2, gravity: .07, collision: !1, boostSpeed: 0, jumpFactor: 1.3 } } }, { key: "_setupStage", value: function () { this.stage = new hf } }, { key: "_setupSoundManager", value: function () { return new xf } }, { key: "_setupRenderer", value: function () { var e = new gr({ canvas: this._canvas, antialias: !0, alpha: !0 }); return e.setPixelRatio(Math.min(window.devicePixelRatio, 2)), e } }, { key: "_setupScene", value: function () { var e = new yr; return new nt(xA.fogColor), e } }, { key: "_setupCamera", value: function () { var e = new Vt(60, this._canvas.width / this._canvas.height, .01, 300); return e.position.x = xA.cameraX, e.position.y = xA.cameraY, e.position.z = xA.cameraZ, e } }, { key: "_setupControlsOptions", value: function () { return { height: 2, speed: .1, turnSpeed: .02 * Math.PI, rotateSpeed: .005 * Math.PI } } }, { key: "_setupEventListeners", value: function () { var e = this; Xp.ticker.add((function (t, n, i, r) { return e._tickHandler(t, n, i, r) })), document.addEventListener("click", (function () { return e._onFirstClick() })), this._paramsCTA.addEventListener("click", (function () { return e._openParametersHandler() })), this._pauseCTA.addEventListener("click", (function () { return e._pauseGameHandler() })), this._eventDispatcher.addEventListener("gameFirstLoose", (function () { return e._gameFirstLoose() })), this._eventDispatcher.addEventListener("gameNormalLoose", (function () { return e._gameNormalLoose() })), this._retryVideo.addEventListener("click", (function () { return e._showPreloaded() })), this._playText.addEventListener("click", (function () { return e._endScreenHandler() })), this._noVideoCTA.addEventListener("click", (function () { return e._abortBonusHandler() })), this._canvas.addEventListener("touchstart", (function (t) { return e._touchStartHandler(t) }), !1), this._canvas.addEventListener("touchmove", (function (t) { return e._touchMoveHandler(t) }), !1), this._canvas.addEventListener("touchend", (function (t) { return e._touchEndHandler(t) }), !1), this._canvas.addEventListener("mousedown", (function (t) { return e._touchStartHandler(t) }), !1), this._canvas.addEventListener("mousemove", (function (t) { return e._touchMoveHandler(t) }), !1), this._canvas.addEventListener("mouseup", (function (t) { return e._touchEndHandler(t) }), !1) } }, { key: "_tickDebug", value: function (e, t, n, i) { this.stats.begin(), this.delta = this._clock.getDelta(), this.stage.tick(), this.GAME.isLose || (this._world.collision && (this._world.velocity = -this._world.jumpFactor, this._world.yPos += .01, this._world.collision = !1), this._world.yPos -= this._world.velocity * this._world.deltaTime + this._world.boostSpeed, this._world.velocity <= this._world.maxVelocity && (this._world.velocity += this._world.gravity), this.stats.end()) } }, { key: "_tick", value: function (e, t, n, i) { this.GAME.isPaused || (this.delta = this._clock.getDelta(), this.stage.tick(), this.GAME.isLose || (this._world.collision && (this._world.velocity = -this._world.jumpFactor, this._world.yPos += .01, this._world.collision = !1), this._world.yPos -= this._world.velocity * this._world.deltaTime + this._world.boostSpeed, this._world.velocity <= this._world.maxVelocity && (this._world.velocity += this._world.gravity))) } }, { key: "_onFirstClick", value: function () { this.GAME.isFirstClick || (this.GAME.isFirstClick = !0, this._startScreen.classList.add("hidden")) } }, { key: "_gameFirstLoose", value: function () { this.GAME.isFirstLose = !0, this.GAME.isLose = !0, this.H5SDK.notifyLevelEnd(0, this.SCORE, !1), this._retry() } }, { key: "_gameNormalLoose", value: function () { clearTimeout(this._retryTimeOut), this._endScreen.classList.remove("hidden"), this.GAME.isLose = !0, this._scoreContainer.classList.add("variant-end-screen"), this.H5SDK.notifyLevelEnd(0, this.SCORE, !1), this._showInterstitialAd() } }, { key: "_tickHandler", value: function (e, t, n, i) { this.GAME.isDebug ? this._tickDebug(e, t, n, i) : this._tick(e, t, n, i) } }, { key: "_touchStartHandler", value: function (e) { this.GAME.isFirstClick || (this.GAME.isFirstClick = !0, this._startScreen.classList.add("hidden")), this._soundIcon.classList.add("hidden"), this._privacyIcon.classList.add("hidden"), this._touchValues.isPlayerTouch = !0, this._touchValues.mousePosition.x = e.touches ? e.touches[0].pageX : e.clientX, this._touchValues.mousePosition.y = e.touches ? e.touches[0].pageY : e.clientY, this._touchValues.oldPos.x = e.touches ? e.touches[0].pageX : e.pageX, this._touchValues.oldPos.y = e.touches ? e.touches[0].pageY : e.pageY, this._eventDispatcher.dispatchEvent({ type: "touchStart", data: this._touchValues }) } }, { key: "_touchMoveHandler", value: function (e) { this._touchValues.isPlayerTouch && (this._touchValues.mousePosition.x = e.touches ? e.touches[0].pageX : e.pageX, this._touchValues.mousePosition.y = e.touches ? e.touches[0].pageY : e.pageY, (this._touchValues.mousePosition.x < this._touchValues.oldPos.x && this._touchValues.isPlayerTouch || this._touchValues.mousePosition.x > this._touchValues.oldPos.x && this._touchValues.isPlayerTouch) && (this._touchValues.swipeSpeed = this._touchValues.mousePosition.x - this._touchValues.oldPos.x), this._touchValues.oldPos.x = this._touchValues.mousePosition.x, this._touchValues.oldPos.y = this._touchValues.mousePosition.y, this._eventDispatcher.dispatchEvent({ type: "touchMove", data: this._touchValues })) } }, { key: "_abortBonusHandler", value: function () { this.GAME.isRetryClick || (this._retryScreen.classList.add("hidden"), this._eventDispatcher.dispatchEvent({ type: "touchRetryScreen", data: "" }), this._gameNormalLoose()) } }, { key: "_touchEndHandler", value: function () { this._touchValues.isPlayerTouch = !1, this._touchValues.oldPos.x = 0, this._touchValues.oldPos.y = 0, this._touchValues.mousePosition.x = 0, this._touchValues.mousePosition.y = 0, this._touchValues.swipeSpeed = 0, this._eventDispatcher.dispatchEvent({ type: "touchEnd", data: this._touchValues }) } }, { key: "_rewardHandler", value: function (e) { e ? (this.resetNormalGravity(), this.GAME.isRetryClick = !0, this.GAME.isLose = !1, this._eventDispatcher.dispatchEvent({ type: "touchRetryScreen", data: "" }), this._retryScreen.classList.add("hidden")) : this._abortBonusHandler() } }, { key: "_showPreloaded", value: function () { clearTimeout(this._retryTimeOut), this.H5SDK.showPreloadedRewardedAd().then(this._rewardHandler).catch(console.log) } }, { key: "_noAdHandler", value: function () { this.GAME.isRetryClick || (this._retryScreen.classList.add("hidden"), this._eventDispatcher.dispatchEvent({ type: "touchRetryScreen", data: "" }), this._gameNormalLoose()) } }, { key: "_retry", value: (r = regeneratorRuntime.mark((function e() { var t = this; return regeneratorRuntime.wrap((function (e) { for (; ;)switch (e.prev = e.next) { case 0: this.H5SDK.getPlatform().adTimeout = 1500, this.H5SDK.preloadRewardedAd().then((function (e) { e ? (t._retryScreen.classList.remove("hidden"), t._circleSvg.classList.add("active"), t._retryTimeOut = setTimeout(t._noAdHandler, 9e3)) : t._noAdHandler() })).catch((function () { t._noAdHandler() })); case 2: case "end": return e.stop() } }), e, this) })), s = function () { var e = this, t = arguments; return new Promise((function (n, i) { var s = r.apply(e, t); function o(e) { Cf(s, n, i, o, a, "next", e) } function a(e) { Cf(s, n, i, o, a, "throw", e) } o(void 0) })) }, function () { return s.apply(this, arguments) }) }, { key: "_showInterstitialAd", value: function () { var e = this; this.H5SDK.requestInterstitialAd().then((function () { e.H5SDK.getPlatform().isFacebook() && e.H5SDK.getPlatform().showTournamentCreatorPopup().then((function () { })) })) } }, { key: "_endScreenHandler", value: function () { var e = this; this.resetNormalGravity(), this.GAME.isLose = !1, this.GAME.isRetryClick = !1, this.GAME.isFirstLose = !1, clearTimeout(this._retryTimeOut), this._eventDispatcher.dispatchEvent({ type: "touchRestartScreen", data: "" }), this._endScreen.classList.add("hidden"), this._scoreContainer.classList.remove("variant-end-screen"), this._circleSvg.classList.remove("active"), setTimeout((function () { e.GAME.isFirstClick = !1, e._startScreen.classList.remove("hidden") }), 300) } }, { key: "_addFacebookButtons", value: function () { var e = this, t = this.H5SDK.getPlatform().isFacebook(); console.log(this.H5SDK.getPlatform()), console.log(this.H5SDK.getPlatform().isFacebook); var n = document.querySelector(".invite-friends-button"), i = document.querySelector(".share-friends-button"), r = "data:image/png;base64,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b20vcGhvdG9zaG9wLzEuMC8iIHhtbG5zOnhtcE1NPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvbW0vIiB4bWxuczpzdEV2dD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL3NUeXBlL1Jlc291cmNlRXZlbnQjIiB4bWxuczpleGlmPSJodHRwOi8vbnMuYWRvYmUuY29tL2V4aWYvMS4wLyIgeG1wOkNyZWF0ZURhdGU9IjIwMTgtMDItMDZUMjA6MDc6MjkrMDI6MDAiIHhtcDpNb2RpZnlEYXRlPSIyMDE4LTA1LTIzVDEyOjU2OjQ4KzAzOjAwIiB4bXA6TWV0YWRhdGFEYXRlPSIyMDE4LTA1LTIzVDEyOjU2OjQ4KzAzOjAwIiBkYzpmb3JtYXQ9ImltYWdlL3BuZyIgcGhvdG9zaG9wOkNvbG9yTW9kZT0iMyIgcGhvdG9zaG9wOklDQ1Byb2ZpbGU9IkRpc3BsYXkiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6NzM1OGVmZjAtZGNlZS00NjY1LWJiNDgtMWQ1MzY0NDA3NGNkIiB4bXBNTTpEb2N1bWVudElEPSJhZG9iZTpkb2NpZDpwaG90b3Nob3A6ZTg4MTQ0NDEtOWI5MC0zZTRjLTkxN2EtNDYyMzQ0NzQ0NjAyIiB4bXBNTTpPcmlnaW5hbERvY3VtZW50SUQ9InhtcC5kaWQ6NWU0NzVlYzctOWUwYS00M2E4LTg4NzQtM2ViYjU2ZTM5YzcyIiBleGlmOlBpeGVsWERpbWVuc2lvbj0iMTIyOCIgZXhpZjpQaXhlbFlEaW1lbnNpb249IjExNjAiPiA8eG1wTU06SGlzdG9yeT4gPHJkZjpTZXE+IDxyZGY6bGkgc3RFdnQ6YWN0aW9uPSJzYXZlZCIgc3RFdnQ6aW5zdGFuY2VJRD0ieG1wLmlpZDo1ZTQ3NWVjNy05ZTBhLTQzYTgtODg3NC0zZWJiNTZlMzljNzIiIHN0RXZ0OndoZW49IjIwMTgtMDItMDZUMjA6MTI6MTkrMDI6MDAiIHN0RXZ0OnNvZnR3YXJlQWdlbnQ9IkFkb2JlIFBob3Rvc2hvcCBDQyAoTWFjaW50b3NoKSIgc3RFdnQ6Y2hhbmdlZD0iLyIvPiA8cmRmOmxpIHN0RXZ0OmFjdGlv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"; t && (n.style.display = "flex", i.style.display = "flex", i.addEventListener("click", (function () { e.H5SDK.getPlatform().shareWithFriends(r, "My best score is ".concat(e.SCORE, ". Try to beat me !")) })), n.addEventListener("click", (function () { e.H5SDK.getPlatform().inviteFriends(r, "My best score is ".concat(e.SCORE, ". Can you do better ?")) }))) } }, { key: "_openParametersHandler", value: function () { this._soundIcon.classList.toggle("hidden"), this._privacyIcon.classList.toggle("hidden") } }, { key: "_pauseGameHandler", value: function () { this.GAME.isPaused = !this.GAME.isPaused, this._playIcon.classList.toggle("active"), this._pauseIcon.classList.toggle("active") } }, { key: "_setupStats", value: function () { this.stats = new vf, this.stats.showPanel(0), document.body.appendChild(this.stats.dom) } }, { key: "_setupOrbitControls", value: function () { this._controls = new gf(this._camera, this._canvas), this._controls.update(), this._controls.enabled = this.GAME.isDebug, this._controls.target = new O(0, 1, 0) } }]) && bf(t.prototype, n), i && bf(t, i), e }()); function If(e, t) { for (var n = 0; n < t.length; n++) { var i = t[n]; i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i) } } var Ef = function () { function e(t) { !function (e, t) { if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function") }(this, e), this.model = t.model, this.animations = t.animations, this.actions = [], this.actionType = {}, this.mixer = null, this.currentAnim = null, this._firstPlaying = !0, this._weight = { val: 0 }, this._setupMixer(t.skinnedMesh); for (var n = 0; n < this.animations.length; n++) { var i = this.animations[n]; this._setupMultipleAnimations(i, i.name, n) } this._activateAllActions(), this._setupEventListeners() } var t, n, i; return t = e, (n = [{ key: "playAnimation", value: function (e) { var t = this; this.currentAnim = this.actionType[e.animation].getClip(), this.actionType[e.animation].time = 0, e.loop ? this.actionType[e.animation].loop = 2201 : (this.actionType[e.animation].clampWhenFinished = !0, this.actionType[e.animation].loop = 2200), e.yoyo && (this.actionType[e.animation].clampWhenFinished = !0, this.actionType[e.animation].loop = 2202, this.actionType[e.animation].repetitions = 2), this._setWeight(this.actionType[e.animation], 1), this.actionType[e.animation].paused = !1, this.actionType[e.animation].play(), this.actionType[e.animation].timeScale = e.speed ? e.speed : 1, this.actionType[e.animation].time = e.delay ? e.delay : 0, this._firstPlaying && (this._firstPlaying = !1, Xp.ticker.add((function () { return t._update() }))) } }, { key: "revertAnimation", value: function (e) { this.actionType[e.animation].timeScale = -1, this.actionType[e.animation].loop = 2200 } }, { key: "pauseAnimation", value: function (e) { this.actionType[e.animation].paused = !0 } }, { key: "pauseAllActions", value: function () { this.actions.forEach((function (e) { e.paused = !0 })) } }, { key: "unPauseAllActions", value: function () { this.actions.forEach((function (e) { e.paused = !1 })) } }, { key: "animFade", value: function (e) { this.unPauseAllActions(), this._setWeight(this.actionType[e.to], 1), this.actionType[e.to].time = 0, this.actionType[e.from].crossFadeTo(this.actionType[e.to], e.duration ? e.duration : 1, !0), this.playAnimation({ animation: e.to, loop: e.loop, speed: e.speed }) } }, { key: "setAnimationProgress", value: function (e) { this.playAnimation(e); var t = this.currentAnim.duration * e.progress; this.actionType[e.animation].paused = !0, e.animation.time = t } }, { key: "getAnimationProgress", value: function (e) { return e.animation.time } }, { key: "getCurrentAnim", value: function () { return this.currentAnim.name } }, { key: "_update", value: function (e) { this.mixer.update(Mf.DELTA_TIME) } }, { key: "onAnimationComplete", value: function (e) { this.completeCallback = e } }, { key: "_setupMixer", value: function (e) { this.mixer = new Xa(e || this.model.scene) } }, { key: "_setupMultipleAnimations", value: function (e, t, n) { this.actionType[t] = this.mixer.clipAction(this.animations[n]), this.actions.push(this.actionType[t]) } }, { key: "_setupAnimations", value: function (e) { var t = this; e.forEach((function (e) { t.actionType[e.name] = t.mixer.clipAction(e), t.actions.push(t.actionType[e.name]) })) } }, { key: "_setWeight", value: function (e, t) { e.enabled = !0, e.setEffectiveTimeScale(1), e.setEffectiveWeight(t) } }, { key: "_activateAllActions", value: function (e, t) { var n = this; this.actions.forEach((function (e) { n._setWeight(e, 1) })) } }, { key: "_setupEventListeners", value: function () { var e = this; this.mixer.addEventListener("finished", (function (t) { e.completeCallback && e.completeCallback(t) })) } }]) && If(t.prototype, n), i && If(t, i), e }(); function Tf(e, t) { for (var n = 0; n < t.length; n++) { var i = t[n]; i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i) } } var Pf = { models: {}, sounds: {}, textures: {} }, Sf = new (function () { function e() { !function (e, t) { if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function") }(this, e), this._promises = [], this._gltfLoader = new ul, this._textureLoader = new $o } var t, i, r; return t = e, (i = [{ key: "loadFont", value: function (e, t) { if (e.length > 0) { var n = document.createElement("div"); document.body.appendChild(n), n.innerText = "giItTWQy01234&@=-i?0", n.style.display = "inline", n.style.visibility = "hidden", n.style.position = "fixed"; var i = document.createElement("div"); document.body.appendChild(i), i.innerText = "giItTWQy01234&@=-i?0", i.style.display = "inline", i.style.visibility = "hidden", i.style.position = "fixed", s = setInterval((function () { i.style.fontFamily = e[r], n.getBoundingClientRect().width !== i.getBoundingClientRect().width && (console.log(e[r] + " loaded"), r >= e.length - 1 ? (clearInterval(s), document.body.removeChild(n), document.body.removeChild(i), setTimeout((function () { t() }), 200)) : r++) }), 100); var r = 0 } else t(); var s } }, { key: "loadAssets", value: function () { return this._loadTextures(), this._loadModels(), this._loadSounds(), Promise.all(this._promises) } }, { key: "_loadTextures", value: function () { var e = this, t = []; for (var i in this.importAll(n(3), t), this.additionalTextures) this.additionalTextures[i] && (t[i] = { file: this.additionalTextures[i], name: i }); var r = function (n) { var i = new Promise((function (i, r) { e._textureLoader.load(t[n].file.default, i), Pf.textures[t[n].name] = {} })).then((function (e) { e.encoding = 3001, e.flipY = !1, Pf.textures[t[n].name] = e })); e._promises.push(i) }; for (var s in t) r(s) } }, { key: "_loadModels", value: function () { var e = this, t = []; this.importAll(n(13), t); var i = function (n) { var i = new Promise((function (i, r) { e._gltfLoader.load(t[n].file.default, i), Pf.models[t[n].name] = {} })).then((function (e) { e.animations.forEach((function (e) { for (var t = e.tracks.length - 1; t >= 0; t--) { for (var n = e.tracks[t], i = !0, r = "quaternion" == n.name.split(".")[1] ? 4 : 3, s = 0; s < n.values.length - r; s += r) { for (var o = 0; o < r; o++)if (Math.abs(n.values[s + o] - n.values[s + o + r]) > 1e-6) { i = !1; break } if (!i) break } i && e.tracks.splice(t, 1) } })), e.animations[0] && (e.animationComponent = new Ef({ model: e, animations: e.animations })), Pf.models[t[n].name] = e })); e._promises.push(i) }; for (var r in t) i(r) } }, { key: "_loadSounds", value: function () { var e = this, t = []; this.importAll(n(19), t); var i = function (n) { var i = new Promise((function (e, i) { e(new yf.Howl({ src: t[n].file.default, preload: !1 }).load()), Pf.sounds[t[n].name] = {} })).then((function (e) { Pf.sounds[t[n].name] = e })); e._promises.push(i) }; for (var r in t) i(r) } }, { key: "GLTFLoader", get: function () { return this._gltfLoader } }, { key: "TextureLoader", get: function () { return this._textureLoader } }, { key: "models", get: function () { return Pf.models } }, { key: "sounds", get: function () { return Pf.sounds } }, { key: "textures", get: function () { return Pf.textures } }, { key: "importAll", value: function (e, t) { e.keys().forEach((function (n) { var i = n.match(/([^:\\/]*?)(?:\.([^ :\\/.]*))?$/), r = null === i ? "" : i[1]; t[n] = { file: e(n), name: r } })) } }]) && Tf(t.prototype, i), r && Tf(t, r), e }()), Bf = (n(22), document.querySelector(".loading-screen")), Df = document.querySelector(".loading-text"); function Rf() { Mf.H5SDK.addEventListener("startLoading", Lf), Mf.H5SDK.addEventListener("pause", Of), Mf.H5SDK.addEventListener("resume", Nf) } function Lf() { Sf.loadAssets().then((function () { console.log(Sf.sounds), Mf.H5SDK.notifyLoadingProgress(100), Mf.H5SDK.notifyLoadingComplete(), Bf.classList.add("hidden"), Df.classList.add("hidden"), Mf.setup(), Mf.createLevel() })) } function Of() { Mf.pause(!0) } function Nf() { Mf.pause(!1) } "loading" === Mf.H5SDK.getState() ? Mf.H5SDK.addEventListener("ready", Rf) : Rf(), Mf.H5SDK.init(), window.addEventListener("resize", (function () { Mf.resize() })) }]);